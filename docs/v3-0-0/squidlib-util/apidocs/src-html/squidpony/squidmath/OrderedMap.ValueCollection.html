<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Source code</title>
<meta name="description" content="source: package: squidpony.squidmath, class: OrderedMap, class: ValueCollection">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source">
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">/*</a>
<span class="sourceLineNo">002</span><a id="line.2"> * Copyright (C) 2002-2015 Sebastiano Vigna</a>
<span class="sourceLineNo">003</span><a id="line.3"> *</a>
<span class="sourceLineNo">004</span><a id="line.4"> * Licensed under the Apache License, Version 2.0 (the "License");</a>
<span class="sourceLineNo">005</span><a id="line.5"> * you may not use this file except in compliance with the License.</a>
<span class="sourceLineNo">006</span><a id="line.6"> * You may obtain a copy of the License at</a>
<span class="sourceLineNo">007</span><a id="line.7"> *</a>
<span class="sourceLineNo">008</span><a id="line.8"> *     http://www.apache.org/licenses/LICENSE-2.0</a>
<span class="sourceLineNo">009</span><a id="line.9"> *</a>
<span class="sourceLineNo">010</span><a id="line.10"> * Unless required by applicable law or agreed to in writing, software</a>
<span class="sourceLineNo">011</span><a id="line.11"> * distributed under the License is distributed on an "AS IS" BASIS,</a>
<span class="sourceLineNo">012</span><a id="line.12"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</a>
<span class="sourceLineNo">013</span><a id="line.13"> * See the License for the specific language governing permissions and</a>
<span class="sourceLineNo">014</span><a id="line.14"> * limitations under the License.</a>
<span class="sourceLineNo">015</span><a id="line.15"> */</a>
<span class="sourceLineNo">016</span><a id="line.16">package squidpony.squidmath;</a>
<span class="sourceLineNo">017</span><a id="line.17"></a>
<span class="sourceLineNo">018</span><a id="line.18">import squidpony.annotation.GwtIncompatible;</a>
<span class="sourceLineNo">019</span><a id="line.19"></a>
<span class="sourceLineNo">020</span><a id="line.20">import java.io.Serializable;</a>
<span class="sourceLineNo">021</span><a id="line.21">import java.util.*;</a>
<span class="sourceLineNo">022</span><a id="line.22"></a>
<span class="sourceLineNo">023</span><a id="line.23">/**</a>
<span class="sourceLineNo">024</span><a id="line.24"> * A generic insertion-ordered hash map with with a fast implementation, originally from fastutil as</a>
<span class="sourceLineNo">025</span><a id="line.25"> * Object2ObjectLinkedOpenHashMap but modified to support constant-time indexed access of keys, values, and entries,</a>
<span class="sourceLineNo">026</span><a id="line.26"> * reordering, and optional hash strategies for unusual keys, such as arrays or usually-dense numeric values.</a>
<span class="sourceLineNo">027</span><a id="line.27"> * &lt;br&gt;</a>
<span class="sourceLineNo">028</span><a id="line.28"> * Instances of this class use a hash table to represent a map. The table is filled up to a specified &lt;em&gt;load factor&lt;/em&gt;, and then doubled in size to accommodate new entries. If the table is</a>
<span class="sourceLineNo">029</span><a id="line.29"> * emptied below &lt;em&gt;one fourth&lt;/em&gt; of the load factor, it is halved in size. However, halving is not performed when deleting entries from an iterator, as it would interfere with the iteration</a>
<span class="sourceLineNo">030</span><a id="line.30"> * process.</a>
<span class="sourceLineNo">031</span><a id="line.31"> * &lt;br&gt;</a>
<span class="sourceLineNo">032</span><a id="line.32"> * Note that {@link #clear()} does not modify the hash table size. Rather, a family of {@linkplain #trim() trimming methods} lets you control the size of the table; this is particularly useful if</a>
<span class="sourceLineNo">033</span><a id="line.33"> * you reuse instances of this class.</a>
<span class="sourceLineNo">034</span><a id="line.34"> * &lt;br&gt;</a>
<span class="sourceLineNo">035</span><a id="line.35"> * Iterators generated by this map will enumerate pairs in the same order in which they have been added to the map (addition of pairs whose key is already present in the set does not change the</a>
<span class="sourceLineNo">036</span><a id="line.36"> * iteration order). Note that this order has nothing in common with the natural order of the keys. The order is kept by means of a int-specialized list, {@link IntVLA}, and is modifiable with this</a>
<span class="sourceLineNo">037</span><a id="line.37"> * class' {@link #reorder(int...)} and {@link #shuffle(IRNG)} methods, among other tools. It may be preferable to avoid instantiating an Iterator object and instead</a>
<span class="sourceLineNo">038</span><a id="line.38"> * use a normal int-based for loop with {@link #getAt(int)} called in each iteration. Though this doesn't allow easy deletion of items during iteration, it may be the</a>
<span class="sourceLineNo">039</span><a id="line.39"> * fastest way to iterate through an OrderedMap.</a>
<span class="sourceLineNo">040</span><a id="line.40"> * &lt;br&gt;</a>
<span class="sourceLineNo">041</span><a id="line.41"> * This class implements the interface of a sorted map, so to allow easy access of the iteration order: for instance, you can get the first key in iteration order with {@code firstKey()} without</a>
<span class="sourceLineNo">042</span><a id="line.42"> * having to create an iterator; however, this class partially violates the {@link SortedMap} contract because all submap methods throw an exception and {@link #comparator()} returns always</a>
<span class="sourceLineNo">043</span><a id="line.43"> * &lt;code&gt;null&lt;/code&gt;.</a>
<span class="sourceLineNo">044</span><a id="line.44"> * &lt;br&gt;</a>
<span class="sourceLineNo">045</span><a id="line.45"> * Additional methods, such as &lt;code&gt;getAndMoveToFirst()&lt;/code&gt;, make it easy to use instances of this class as a cache (e.g., with LRU policy).</a>
<span class="sourceLineNo">046</span><a id="line.46"> * &lt;br&gt;</a>
<span class="sourceLineNo">047</span><a id="line.47"> * This class allows approximately constant-time lookup of keys or values by their index in the ordering, which can</a>
<span class="sourceLineNo">048</span><a id="line.48"> * allow some novel usage of the data structure. {@link OrderedSet} can be used like a list of unique elements, keeping</a>
<span class="sourceLineNo">049</span><a id="line.49"> * order like a list does but also allowing rapid checks for whether an item exists in the OrderedSet, and OrderedMap</a>
<span class="sourceLineNo">050</span><a id="line.50"> * can be used like that but with values associated as well (where OrderedSet uses contains(), OrderedMap uses</a>
<span class="sourceLineNo">051</span><a id="line.51"> * containsKey()). You can also set the key and value at a position with {@link #putAt(Object, Object, int)}, or alter</a>
<span class="sourceLineNo">052</span><a id="line.52"> * the key while keeping its value and index the same with {@link #alter(Object, Object)}. Reordering works here too,</a>
<span class="sourceLineNo">053</span><a id="line.53"> * both with completely random orders from {@link #shuffle(IRNG)} or with a previously-generated ordering from</a>
<span class="sourceLineNo">054</span><a id="line.54"> * {@link #reorder(int...)} (you can produce such an ordering for a given size and reuse it across multiple Ordered data</a>
<span class="sourceLineNo">055</span><a id="line.55"> * structures with {@link IRNG#randomOrdering(int)}). Note that putAt() and {@link #removeAt(int)} do not run in constant</a>
<span class="sourceLineNo">056</span><a id="line.56"> * time, and depending on the point of insertion/removal, they are likely to run in linear time (but also note that most</a>
<span class="sourceLineNo">057</span><a id="line.57"> * insertion-ordered Maps and Sets don't allow insertion or removal at anywhere but the beginning or end of the order).</a>
<span class="sourceLineNo">058</span><a id="line.58"> * &lt;br&gt;</a>
<span class="sourceLineNo">059</span><a id="line.59"> * You can pass a {@link CrossHash.IHasher} instance such as {@link CrossHash#generalHasher} as an extra parameter to</a>
<span class="sourceLineNo">060</span><a id="line.60"> * most of this class' constructors, which allows the OrderedMap to use arrays (usually primitive arrays) as keys. If</a>
<span class="sourceLineNo">061</span><a id="line.61"> * you expect only one type of array, you can use an instance like {@link CrossHash#intHasher} to hash int arrays, or</a>
<span class="sourceLineNo">062</span><a id="line.62"> * the aforementioned generalHasher to hash most kinds of arrays (it can't handle most multi-dimensional arrays well).</a>
<span class="sourceLineNo">063</span><a id="line.63"> * If you aren't using arrays as keys, you don't need to give an IHasher to the constructor and can ignore this feature</a>
<span class="sourceLineNo">064</span><a id="line.64"> * most of the time. However, the default IHasher this uses if none is specified performs a small but significant</a>
<span class="sourceLineNo">065</span><a id="line.65"> * "mixing" step to make the default generated hashCode() implementation many classes use into a higher-quality</a>
<span class="sourceLineNo">066</span><a id="line.66"> * random-like value. This isn't always optimal; if you plan to insert 1000 sequential Integer keys with some small</a>
<span class="sourceLineNo">067</span><a id="line.67"> * amount of random Integers after them, then the mixing actually increases the likelihood of a collision and takes time</a>
<span class="sourceLineNo">068</span><a id="line.68"> * to calculate. You could use a very simple IHasher in that case, relying on the fact that only Integers will be added:</a>
<span class="sourceLineNo">069</span><a id="line.69"> * &lt;pre&gt;</a>
<span class="sourceLineNo">070</span><a id="line.70"> * new CrossHash.IHasher() {</a>
<span class="sourceLineNo">071</span><a id="line.71"> *     public int hash(Object data) { return (int)data; }</a>
<span class="sourceLineNo">072</span><a id="line.72"> *     public boolean areEqual(Object left, Object right) { return Objects.equals(left, right); }</a>
<span class="sourceLineNo">073</span><a id="line.73"> * };</a>
<span class="sourceLineNo">074</span><a id="line.74"> * &lt;/pre&gt;</a>
<span class="sourceLineNo">075</span><a id="line.75"> * This is just one example of a case where a custom IHasher can be useful for performance reasons; there are also cases</a>
<span class="sourceLineNo">076</span><a id="line.76"> * where an IHasher is needed to enforce hashing by identity or by value, which affect program logic. Note that the</a>
<span class="sourceLineNo">077</span><a id="line.77"> * given IHasher is likely to be sub-optimal for many situations with Integer keys, and you may want to try a few</a>
<span class="sourceLineNo">078</span><a id="line.78"> * different approaches if you know OrderedMap is a bottleneck in your application. If the IHasher is a performance</a>
<span class="sourceLineNo">079</span><a id="line.79"> * problem, it will be at its worst if the OrderedMap needs to resize, and thus rehash, many times; this won't happen if</a>
<span class="sourceLineNo">080</span><a id="line.80"> * the capacity is set correctly when the OrderedMap is created (with the capacity equal to or greater than the maximum</a>
<span class="sourceLineNo">081</span><a id="line.81"> * number of entries that will be added).</a>
<span class="sourceLineNo">082</span><a id="line.82"> * &lt;br&gt;</a>
<span class="sourceLineNo">083</span><a id="line.83"> * Thank you, Sebastiano Vigna, for making FastUtil available to the public with such high quality.</a>
<span class="sourceLineNo">084</span><a id="line.84"> * &lt;br&gt;</a>
<span class="sourceLineNo">085</span><a id="line.85"> * See https://github.com/vigna/fastutil for the original library.</a>
<span class="sourceLineNo">086</span><a id="line.86"> * @author Sebastiano Vigna (responsible for all the hard parts)</a>
<span class="sourceLineNo">087</span><a id="line.87"> * @author Tommy Ettinger (mostly responsible for squashing several layers of parent classes into one monster class)</a>
<span class="sourceLineNo">088</span><a id="line.88"> */</a>
<span class="sourceLineNo">089</span><a id="line.89">public class OrderedMap&lt;K, V&gt; implements SortedMap&lt;K, V&gt;, java.io.Serializable, Cloneable {</a>
<span class="sourceLineNo">090</span><a id="line.90">    private static final long serialVersionUID = 0L;</a>
<span class="sourceLineNo">091</span><a id="line.91">    /**</a>
<span class="sourceLineNo">092</span><a id="line.92">     * The array of keys.</a>
<span class="sourceLineNo">093</span><a id="line.93">     */</a>
<span class="sourceLineNo">094</span><a id="line.94">    protected K[] key;</a>
<span class="sourceLineNo">095</span><a id="line.95">    /**</a>
<span class="sourceLineNo">096</span><a id="line.96">     * The array of values.</a>
<span class="sourceLineNo">097</span><a id="line.97">     */</a>
<span class="sourceLineNo">098</span><a id="line.98">    protected V[] value;</a>
<span class="sourceLineNo">099</span><a id="line.99">    /**</a>
<span class="sourceLineNo">100</span><a id="line.100">     * The mask for wrapping a position counter.</a>
<span class="sourceLineNo">101</span><a id="line.101">     */</a>
<span class="sourceLineNo">102</span><a id="line.102">    protected int mask;</a>
<span class="sourceLineNo">103</span><a id="line.103">    /**</a>
<span class="sourceLineNo">104</span><a id="line.104">     * Whether this set contains the key zero.</a>
<span class="sourceLineNo">105</span><a id="line.105">     */</a>
<span class="sourceLineNo">106</span><a id="line.106">    protected boolean containsNullKey;</a>
<span class="sourceLineNo">107</span><a id="line.107">    /**</a>
<span class="sourceLineNo">108</span><a id="line.108">     * An IntVLA (variable-length int sequence) that stores the positions in the key array of specific keys, with the</a>
<span class="sourceLineNo">109</span><a id="line.109">     * positions in insertion order. The order can be changed with {@link #reorder(int...)} and other methods.</a>
<span class="sourceLineNo">110</span><a id="line.110">     */</a>
<span class="sourceLineNo">111</span><a id="line.111">    protected IntVLA order;</a>
<span class="sourceLineNo">112</span><a id="line.112">    /**</a>
<span class="sourceLineNo">113</span><a id="line.113">     * The current table size.</a>
<span class="sourceLineNo">114</span><a id="line.114">     */</a>
<span class="sourceLineNo">115</span><a id="line.115">    protected int n;</a>
<span class="sourceLineNo">116</span><a id="line.116">    /**</a>
<span class="sourceLineNo">117</span><a id="line.117">     * Threshold after which we rehash. It must be the table size times {@link #f}.</a>
<span class="sourceLineNo">118</span><a id="line.118">     */</a>
<span class="sourceLineNo">119</span><a id="line.119">    protected int maxFill;</a>
<span class="sourceLineNo">120</span><a id="line.120">    /**</a>
<span class="sourceLineNo">121</span><a id="line.121">     * Number of entries in the set (including the key zero, if present).</a>
<span class="sourceLineNo">122</span><a id="line.122">     */</a>
<span class="sourceLineNo">123</span><a id="line.123">    protected int size;</a>
<span class="sourceLineNo">124</span><a id="line.124">    /**</a>
<span class="sourceLineNo">125</span><a id="line.125">     * The acceptable load factor.</a>
<span class="sourceLineNo">126</span><a id="line.126">     */</a>
<span class="sourceLineNo">127</span><a id="line.127">    public final float f;</a>
<span class="sourceLineNo">128</span><a id="line.128">    /**</a>
<span class="sourceLineNo">129</span><a id="line.129">     * Cached set of entries.</a>
<span class="sourceLineNo">130</span><a id="line.130">     */</a>
<span class="sourceLineNo">131</span><a id="line.131">    protected volatile MapEntrySet entries;</a>
<span class="sourceLineNo">132</span><a id="line.132">    /**</a>
<span class="sourceLineNo">133</span><a id="line.133">     * Cached set of keys.</a>
<span class="sourceLineNo">134</span><a id="line.134">     */</a>
<span class="sourceLineNo">135</span><a id="line.135">    protected volatile KeySet keys;</a>
<span class="sourceLineNo">136</span><a id="line.136">    /**</a>
<span class="sourceLineNo">137</span><a id="line.137">     * Cached collection of values.</a>
<span class="sourceLineNo">138</span><a id="line.138">     */</a>
<span class="sourceLineNo">139</span><a id="line.139">    protected volatile Collection&lt;V&gt; values;</a>
<span class="sourceLineNo">140</span><a id="line.140">    /**</a>
<span class="sourceLineNo">141</span><a id="line.141">     * Default return value.</a>
<span class="sourceLineNo">142</span><a id="line.142">     */</a>
<span class="sourceLineNo">143</span><a id="line.143">    protected V defRetValue;</a>
<span class="sourceLineNo">144</span><a id="line.144"></a>
<span class="sourceLineNo">145</span><a id="line.145">    /**</a>
<span class="sourceLineNo">146</span><a id="line.146">     * The initial default size of a hash table.</a>
<span class="sourceLineNo">147</span><a id="line.147">     */</a>
<span class="sourceLineNo">148</span><a id="line.148">    public static final int DEFAULT_INITIAL_SIZE = 16;</a>
<span class="sourceLineNo">149</span><a id="line.149">    /**</a>
<span class="sourceLineNo">150</span><a id="line.150">     * The default load factor of a hash table.</a>
<span class="sourceLineNo">151</span><a id="line.151">     */</a>
<span class="sourceLineNo">152</span><a id="line.152">    public static final float DEFAULT_LOAD_FACTOR = .25f; // .1875f; // .75f;</a>
<span class="sourceLineNo">153</span><a id="line.153">    /**</a>
<span class="sourceLineNo">154</span><a id="line.154">     * The load factor for a (usually small) table that is meant to be particularly fast.</a>
<span class="sourceLineNo">155</span><a id="line.155">     */</a>
<span class="sourceLineNo">156</span><a id="line.156">    public static final float FAST_LOAD_FACTOR = .5f;</a>
<span class="sourceLineNo">157</span><a id="line.157">    /**</a>
<span class="sourceLineNo">158</span><a id="line.158">     * The load factor for a (usually very small) table that is meant to be extremely fast.</a>
<span class="sourceLineNo">159</span><a id="line.159">     */</a>
<span class="sourceLineNo">160</span><a id="line.160">    public static final float VERY_FAST_LOAD_FACTOR = .25f;</a>
<span class="sourceLineNo">161</span><a id="line.161"></a>
<span class="sourceLineNo">162</span><a id="line.162">    protected final CrossHash.IHasher hasher;</a>
<span class="sourceLineNo">163</span><a id="line.163"></a>
<span class="sourceLineNo">164</span><a id="line.164">    public void defaultReturnValue(final V rv) {</a>
<span class="sourceLineNo">165</span><a id="line.165">        defRetValue = rv;</a>
<span class="sourceLineNo">166</span><a id="line.166">    }</a>
<span class="sourceLineNo">167</span><a id="line.167"></a>
<span class="sourceLineNo">168</span><a id="line.168">    public V defaultReturnValue() {</a>
<span class="sourceLineNo">169</span><a id="line.169">        return defRetValue;</a>
<span class="sourceLineNo">170</span><a id="line.170">    }</a>
<span class="sourceLineNo">171</span><a id="line.171"></a>
<span class="sourceLineNo">172</span><a id="line.172">    /**</a>
<span class="sourceLineNo">173</span><a id="line.173">     * Creates a new OrderedMap.</a>
<span class="sourceLineNo">174</span><a id="line.174">     * &lt;p&gt;</a>
<span class="sourceLineNo">175</span><a id="line.175">     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.</a>
<span class="sourceLineNo">176</span><a id="line.176">     *</a>
<span class="sourceLineNo">177</span><a id="line.177">     * @param expected the expected number of elements in the hash set.</a>
<span class="sourceLineNo">178</span><a id="line.178">     * @param f        the load factor.</a>
<span class="sourceLineNo">179</span><a id="line.179">     */</a>
<span class="sourceLineNo">180</span><a id="line.180"></a>
<span class="sourceLineNo">181</span><a id="line.181">    @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">182</span><a id="line.182">    public OrderedMap(final int expected, final float f) {</a>
<span class="sourceLineNo">183</span><a id="line.183">        if (f &lt;= 0 || f &gt; 1)</a>
<span class="sourceLineNo">184</span><a id="line.184">            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");</a>
<span class="sourceLineNo">185</span><a id="line.185">        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");</a>
<span class="sourceLineNo">186</span><a id="line.186">        this.f = f;</a>
<span class="sourceLineNo">187</span><a id="line.187">        n = arraySize(expected, f);</a>
<span class="sourceLineNo">188</span><a id="line.188">        mask = n - 1;</a>
<span class="sourceLineNo">189</span><a id="line.189">        maxFill = maxFill(n, f);</a>
<span class="sourceLineNo">190</span><a id="line.190">        key = (K[]) new Object[n + 1];</a>
<span class="sourceLineNo">191</span><a id="line.191">        value = (V[]) new Object[n + 1];</a>
<span class="sourceLineNo">192</span><a id="line.192">        //link = new long[n + 1];</a>
<span class="sourceLineNo">193</span><a id="line.193">        order = new IntVLA(expected);</a>
<span class="sourceLineNo">194</span><a id="line.194">        hasher = CrossHash.mildHasher;</a>
<span class="sourceLineNo">195</span><a id="line.195">    }</a>
<span class="sourceLineNo">196</span><a id="line.196"></a>
<span class="sourceLineNo">197</span><a id="line.197">    /**</a>
<span class="sourceLineNo">198</span><a id="line.198">     * Creates a new OrderedMap with 0.75f as load factor.</a>
<span class="sourceLineNo">199</span><a id="line.199">     *</a>
<span class="sourceLineNo">200</span><a id="line.200">     * @param expected the expected number of elements in the OrderedMap.</a>
<span class="sourceLineNo">201</span><a id="line.201">     */</a>
<span class="sourceLineNo">202</span><a id="line.202">    public OrderedMap(final int expected) {</a>
<span class="sourceLineNo">203</span><a id="line.203">        this(expected, DEFAULT_LOAD_FACTOR);</a>
<span class="sourceLineNo">204</span><a id="line.204">    }</a>
<span class="sourceLineNo">205</span><a id="line.205"></a>
<span class="sourceLineNo">206</span><a id="line.206">    /**</a>
<span class="sourceLineNo">207</span><a id="line.207">     * Creates a new OrderedMap with initial expected 16 entries and 0.75f as load factor.</a>
<span class="sourceLineNo">208</span><a id="line.208">     */</a>
<span class="sourceLineNo">209</span><a id="line.209">    public OrderedMap() {</a>
<span class="sourceLineNo">210</span><a id="line.210">        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);</a>
<span class="sourceLineNo">211</span><a id="line.211">    }</a>
<span class="sourceLineNo">212</span><a id="line.212"></a>
<span class="sourceLineNo">213</span><a id="line.213">    /**</a>
<span class="sourceLineNo">214</span><a id="line.214">     * Creates a new OrderedMap copying a given one.</a>
<span class="sourceLineNo">215</span><a id="line.215">     *</a>
<span class="sourceLineNo">216</span><a id="line.216">     * @param m a {@link Map} to be copied into the new OrderedMap.</a>
<span class="sourceLineNo">217</span><a id="line.217">     * @param f the load factor.</a>
<span class="sourceLineNo">218</span><a id="line.218">     */</a>
<span class="sourceLineNo">219</span><a id="line.219">    public OrderedMap(final Map&lt;? extends K, ? extends V&gt; m, final float f) {</a>
<span class="sourceLineNo">220</span><a id="line.220">        this(m.size(), f, (m instanceof OrderedMap) ? ((OrderedMap) m).hasher : CrossHash.mildHasher);</a>
<span class="sourceLineNo">221</span><a id="line.221">        putAll(m);</a>
<span class="sourceLineNo">222</span><a id="line.222">    }</a>
<span class="sourceLineNo">223</span><a id="line.223"></a>
<span class="sourceLineNo">224</span><a id="line.224">    /**</a>
<span class="sourceLineNo">225</span><a id="line.225">     * Creates a new OrderedMap with 0.75f as load factor copying a given one.</a>
<span class="sourceLineNo">226</span><a id="line.226">     *</a>
<span class="sourceLineNo">227</span><a id="line.227">     * @param m a {@link Map} to be copied into the new OrderedMap.</a>
<span class="sourceLineNo">228</span><a id="line.228">     */</a>
<span class="sourceLineNo">229</span><a id="line.229">    public OrderedMap(final Map&lt;? extends K, ? extends V&gt; m) {</a>
<span class="sourceLineNo">230</span><a id="line.230">        this(m, (m instanceof OrderedMap) ? ((OrderedMap) m).f : DEFAULT_LOAD_FACTOR, (m instanceof OrderedMap) ? ((OrderedMap) m).hasher : CrossHash.mildHasher);</a>
<span class="sourceLineNo">231</span><a id="line.231">    }</a>
<span class="sourceLineNo">232</span><a id="line.232"></a>
<span class="sourceLineNo">233</span><a id="line.233">    /**</a>
<span class="sourceLineNo">234</span><a id="line.234">     * Creates a new OrderedMap using the elements of two parallel arrays.</a>
<span class="sourceLineNo">235</span><a id="line.235">     *</a>
<span class="sourceLineNo">236</span><a id="line.236">     * @param keyArray the array of keys of the new OrderedMap.</a>
<span class="sourceLineNo">237</span><a id="line.237">     * @param valueArray the array of corresponding values in the new OrderedMap.</a>
<span class="sourceLineNo">238</span><a id="line.238">     * @param f the load factor.</a>
<span class="sourceLineNo">239</span><a id="line.239">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</a>
<span class="sourceLineNo">240</span><a id="line.240">     */</a>
<span class="sourceLineNo">241</span><a id="line.241">    public OrderedMap(final K[] keyArray, final V[] valueArray, final float f) {</a>
<span class="sourceLineNo">242</span><a id="line.242">        this(keyArray.length, f);</a>
<span class="sourceLineNo">243</span><a id="line.243">        if (keyArray.length != valueArray.length)</a>
<span class="sourceLineNo">244</span><a id="line.244">            throw new IllegalArgumentException("The key array and the value array have different lengths (" + keyArray.length + " and " + valueArray.length + ")");</a>
<span class="sourceLineNo">245</span><a id="line.245">        for (int i = 0; i &lt; keyArray.length; i++)</a>
<span class="sourceLineNo">246</span><a id="line.246">            put(keyArray[i], valueArray[i]);</a>
<span class="sourceLineNo">247</span><a id="line.247">    }</a>
<span class="sourceLineNo">248</span><a id="line.248">    /**</a>
<span class="sourceLineNo">249</span><a id="line.249">     * Creates a new OrderedMap using the elements of two parallel arrays.</a>
<span class="sourceLineNo">250</span><a id="line.250">     *</a>
<span class="sourceLineNo">251</span><a id="line.251">     * @param keyColl the collection of keys of the new OrderedMap.</a>
<span class="sourceLineNo">252</span><a id="line.252">     * @param valueColl the collection of corresponding values in the new OrderedMap.</a>
<span class="sourceLineNo">253</span><a id="line.253">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</a>
<span class="sourceLineNo">254</span><a id="line.254">     */</a>
<span class="sourceLineNo">255</span><a id="line.255">    public OrderedMap(final Collection&lt;K&gt; keyColl, final Collection&lt;V&gt; valueColl) {</a>
<span class="sourceLineNo">256</span><a id="line.256">        this(keyColl, valueColl, DEFAULT_LOAD_FACTOR);</a>
<span class="sourceLineNo">257</span><a id="line.257">    }</a>
<span class="sourceLineNo">258</span><a id="line.258">    /**</a>
<span class="sourceLineNo">259</span><a id="line.259">     * Creates a new OrderedMap using the elements of two parallel arrays.</a>
<span class="sourceLineNo">260</span><a id="line.260">     *</a>
<span class="sourceLineNo">261</span><a id="line.261">     * @param keyColl the collection of keys of the new OrderedMap.</a>
<span class="sourceLineNo">262</span><a id="line.262">     * @param valueColl the collection of corresponding values in the new OrderedMap.</a>
<span class="sourceLineNo">263</span><a id="line.263">     * @param f the load factor.</a>
<span class="sourceLineNo">264</span><a id="line.264">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</a>
<span class="sourceLineNo">265</span><a id="line.265">     */</a>
<span class="sourceLineNo">266</span><a id="line.266">    public OrderedMap(final Collection&lt;K&gt; keyColl, final Collection&lt;V&gt; valueColl, final float f) {</a>
<span class="sourceLineNo">267</span><a id="line.267">        this(keyColl.size(), f);</a>
<span class="sourceLineNo">268</span><a id="line.268">        if (keyColl.size() != valueColl.size())</a>
<span class="sourceLineNo">269</span><a id="line.269">            throw new IllegalArgumentException("The key array and the value array have different lengths (" + keyColl.size() + " and " + valueColl.size() + ")");</a>
<span class="sourceLineNo">270</span><a id="line.270">        Iterator&lt;K&gt; ki = keyColl.iterator();</a>
<span class="sourceLineNo">271</span><a id="line.271">        Iterator&lt;V&gt; vi = valueColl.iterator();</a>
<span class="sourceLineNo">272</span><a id="line.272">        while (ki.hasNext() &amp;&amp; vi.hasNext())</a>
<span class="sourceLineNo">273</span><a id="line.273">        {</a>
<span class="sourceLineNo">274</span><a id="line.274">            put(ki.next(), vi.next());</a>
<span class="sourceLineNo">275</span><a id="line.275">        }</a>
<span class="sourceLineNo">276</span><a id="line.276">    }</a>
<span class="sourceLineNo">277</span><a id="line.277"></a>
<span class="sourceLineNo">278</span><a id="line.278">    /**</a>
<span class="sourceLineNo">279</span><a id="line.279">     * Creates a new OrderedMap with 0.75f as load factor using the elements of two parallel arrays.</a>
<span class="sourceLineNo">280</span><a id="line.280">     *</a>
<span class="sourceLineNo">281</span><a id="line.281">     * @param keyArray the array of keys of the new OrderedMap.</a>
<span class="sourceLineNo">282</span><a id="line.282">     * @param valueArray the array of corresponding values in the new OrderedMap.</a>
<span class="sourceLineNo">283</span><a id="line.283">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</a>
<span class="sourceLineNo">284</span><a id="line.284">     */</a>
<span class="sourceLineNo">285</span><a id="line.285">    public OrderedMap(final K[] keyArray, final V[] valueArray) {</a>
<span class="sourceLineNo">286</span><a id="line.286">        this(keyArray, valueArray, DEFAULT_LOAD_FACTOR);</a>
<span class="sourceLineNo">287</span><a id="line.287">    }</a>
<span class="sourceLineNo">288</span><a id="line.288"></a>
<span class="sourceLineNo">289</span><a id="line.289">    /**</a>
<span class="sourceLineNo">290</span><a id="line.290">     * Creates a new OrderedMap.</a>
<span class="sourceLineNo">291</span><a id="line.291">     * &lt;p&gt;</a>
<span class="sourceLineNo">292</span><a id="line.292">     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.</a>
<span class="sourceLineNo">293</span><a id="line.293">     *</a>
<span class="sourceLineNo">294</span><a id="line.294">     * @param expected the expected number of elements in the hash set.</a>
<span class="sourceLineNo">295</span><a id="line.295">     * @param f        the load factor.</a>
<span class="sourceLineNo">296</span><a id="line.296">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</a>
<span class="sourceLineNo">297</span><a id="line.297">     */</a>
<span class="sourceLineNo">298</span><a id="line.298"></a>
<span class="sourceLineNo">299</span><a id="line.299">    @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">300</span><a id="line.300">    public OrderedMap(final int expected, final float f, CrossHash.IHasher hasher) {</a>
<span class="sourceLineNo">301</span><a id="line.301">        if (f &lt;= 0 || f &gt; 1)</a>
<span class="sourceLineNo">302</span><a id="line.302">            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");</a>
<span class="sourceLineNo">303</span><a id="line.303">        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");</a>
<span class="sourceLineNo">304</span><a id="line.304">        this.f = f;</a>
<span class="sourceLineNo">305</span><a id="line.305">        n = arraySize(expected, f);</a>
<span class="sourceLineNo">306</span><a id="line.306">        mask = n - 1;</a>
<span class="sourceLineNo">307</span><a id="line.307">        maxFill = maxFill(n, f);</a>
<span class="sourceLineNo">308</span><a id="line.308">        key = (K[]) new Object[n + 1];</a>
<span class="sourceLineNo">309</span><a id="line.309">        value = (V[]) new Object[n + 1];</a>
<span class="sourceLineNo">310</span><a id="line.310">        //link = new long[n + 1];</a>
<span class="sourceLineNo">311</span><a id="line.311">        order = new IntVLA(expected);</a>
<span class="sourceLineNo">312</span><a id="line.312">        this.hasher = (hasher == null) ? CrossHash.mildHasher : hasher;</a>
<span class="sourceLineNo">313</span><a id="line.313">    }</a>
<span class="sourceLineNo">314</span><a id="line.314">    /**</a>
<span class="sourceLineNo">315</span><a id="line.315">     * Creates a new OrderedMap with 0.75f as load factor.</a>
<span class="sourceLineNo">316</span><a id="line.316">     *</a>
<span class="sourceLineNo">317</span><a id="line.317">     * @param expected the expected number of elements in the OrderedMap.</a>
<span class="sourceLineNo">318</span><a id="line.318">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</a>
<span class="sourceLineNo">319</span><a id="line.319">     */</a>
<span class="sourceLineNo">320</span><a id="line.320">    public OrderedMap(final int expected, CrossHash.IHasher hasher) {</a>
<span class="sourceLineNo">321</span><a id="line.321">        this(expected, DEFAULT_LOAD_FACTOR, hasher);</a>
<span class="sourceLineNo">322</span><a id="line.322">    }</a>
<span class="sourceLineNo">323</span><a id="line.323"></a>
<span class="sourceLineNo">324</span><a id="line.324">    /**</a>
<span class="sourceLineNo">325</span><a id="line.325">     * Creates a new OrderedMap with initial expected 16 entries and 0.75f as load factor.</a>
<span class="sourceLineNo">326</span><a id="line.326">     */</a>
<span class="sourceLineNo">327</span><a id="line.327">    public OrderedMap(CrossHash.IHasher hasher) {</a>
<span class="sourceLineNo">328</span><a id="line.328">        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, hasher);</a>
<span class="sourceLineNo">329</span><a id="line.329">    }</a>
<span class="sourceLineNo">330</span><a id="line.330"></a>
<span class="sourceLineNo">331</span><a id="line.331">    /**</a>
<span class="sourceLineNo">332</span><a id="line.332">     * Creates a new OrderedMap copying a given one.</a>
<span class="sourceLineNo">333</span><a id="line.333">     *</a>
<span class="sourceLineNo">334</span><a id="line.334">     * @param m a {@link Map} to be copied into the new OrderedMap.</a>
<span class="sourceLineNo">335</span><a id="line.335">     * @param f the load factor.</a>
<span class="sourceLineNo">336</span><a id="line.336">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</a>
<span class="sourceLineNo">337</span><a id="line.337">     */</a>
<span class="sourceLineNo">338</span><a id="line.338">    public OrderedMap(final Map&lt;? extends K, ? extends V&gt; m, final float f, CrossHash.IHasher hasher) {</a>
<span class="sourceLineNo">339</span><a id="line.339">        this(m.size(), f, hasher);</a>
<span class="sourceLineNo">340</span><a id="line.340">        putAll(m);</a>
<span class="sourceLineNo">341</span><a id="line.341">    }</a>
<span class="sourceLineNo">342</span><a id="line.342"></a>
<span class="sourceLineNo">343</span><a id="line.343">    /**</a>
<span class="sourceLineNo">344</span><a id="line.344">     * Creates a new OrderedMap with 0.75f as load factor copying a given one.</a>
<span class="sourceLineNo">345</span><a id="line.345">     * @param m a {@link Map} to be copied into the new OrderedMap.</a>
<span class="sourceLineNo">346</span><a id="line.346">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</a>
<span class="sourceLineNo">347</span><a id="line.347">     */</a>
<span class="sourceLineNo">348</span><a id="line.348">    public OrderedMap(final Map&lt;? extends K, ? extends V&gt; m, CrossHash.IHasher hasher) {</a>
<span class="sourceLineNo">349</span><a id="line.349">        this(m, DEFAULT_LOAD_FACTOR, hasher);</a>
<span class="sourceLineNo">350</span><a id="line.350">    }</a>
<span class="sourceLineNo">351</span><a id="line.351"></a>
<span class="sourceLineNo">352</span><a id="line.352">    /**</a>
<span class="sourceLineNo">353</span><a id="line.353">     * Creates a new OrderedMap using the elements of two parallel arrays.</a>
<span class="sourceLineNo">354</span><a id="line.354">     *</a>
<span class="sourceLineNo">355</span><a id="line.355">     * @param keyArray the array of keys of the new OrderedMap.</a>
<span class="sourceLineNo">356</span><a id="line.356">     * @param valueArray the array of corresponding values in the new OrderedMap.</a>
<span class="sourceLineNo">357</span><a id="line.357">     * @param f the load factor.</a>
<span class="sourceLineNo">358</span><a id="line.358">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</a>
<span class="sourceLineNo">359</span><a id="line.359">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</a>
<span class="sourceLineNo">360</span><a id="line.360">     */</a>
<span class="sourceLineNo">361</span><a id="line.361">    public OrderedMap(final K[] keyArray, final V[] valueArray, final float f, CrossHash.IHasher hasher) {</a>
<span class="sourceLineNo">362</span><a id="line.362">        this(keyArray.length, f, hasher);</a>
<span class="sourceLineNo">363</span><a id="line.363">        if (keyArray.length != valueArray.length)</a>
<span class="sourceLineNo">364</span><a id="line.364">            throw new IllegalArgumentException("The key array and the value array have different lengths (" + keyArray.length + " and " + valueArray.length + ")");</a>
<span class="sourceLineNo">365</span><a id="line.365">        for (int i = 0; i &lt; keyArray.length; i++)</a>
<span class="sourceLineNo">366</span><a id="line.366">            put(keyArray[i], valueArray[i]);</a>
<span class="sourceLineNo">367</span><a id="line.367">    }</a>
<span class="sourceLineNo">368</span><a id="line.368">    /**</a>
<span class="sourceLineNo">369</span><a id="line.369">     * Creates a new OrderedMap with 0.75f as load factor using the elements of two parallel arrays.</a>
<span class="sourceLineNo">370</span><a id="line.370">     *</a>
<span class="sourceLineNo">371</span><a id="line.371">     * @param keyArray the array of keys of the new OrderedMap.</a>
<span class="sourceLineNo">372</span><a id="line.372">     * @param valueArray the array of corresponding values in the new OrderedMap.</a>
<span class="sourceLineNo">373</span><a id="line.373">     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations</a>
<span class="sourceLineNo">374</span><a id="line.374">     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.</a>
<span class="sourceLineNo">375</span><a id="line.375">     */</a>
<span class="sourceLineNo">376</span><a id="line.376">    public OrderedMap(final K[] keyArray, final V[] valueArray, CrossHash.IHasher hasher) {</a>
<span class="sourceLineNo">377</span><a id="line.377">        this(keyArray, valueArray, DEFAULT_LOAD_FACTOR, hasher);</a>
<span class="sourceLineNo">378</span><a id="line.378">    }</a>
<span class="sourceLineNo">379</span><a id="line.379"></a>
<span class="sourceLineNo">380</span><a id="line.380">    private int realSize() {</a>
<span class="sourceLineNo">381</span><a id="line.381">        return containsNullKey ? size - 1 : size;</a>
<span class="sourceLineNo">382</span><a id="line.382">    }</a>
<span class="sourceLineNo">383</span><a id="line.383">    </a>
<span class="sourceLineNo">384</span><a id="line.384">    public void ensureCapacity(final int capacity) {</a>
<span class="sourceLineNo">385</span><a id="line.385">        final int needed = arraySize(capacity, f);</a>
<span class="sourceLineNo">386</span><a id="line.386">        if (needed &gt; n)</a>
<span class="sourceLineNo">387</span><a id="line.387">            rehash(needed);</a>
<span class="sourceLineNo">388</span><a id="line.388">    }</a>
<span class="sourceLineNo">389</span><a id="line.389">    private void tryCapacity(final long capacity) {</a>
<span class="sourceLineNo">390</span><a id="line.390">        final int needed = (int) Math.min(</a>
<span class="sourceLineNo">391</span><a id="line.391">                1 &lt;&lt; 30,</a>
<span class="sourceLineNo">392</span><a id="line.392">                Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity</a>
<span class="sourceLineNo">393</span><a id="line.393">                        / f))));</a>
<span class="sourceLineNo">394</span><a id="line.394">        if (needed &gt; n)</a>
<span class="sourceLineNo">395</span><a id="line.395">            rehash(needed);</a>
<span class="sourceLineNo">396</span><a id="line.396">    }</a>
<span class="sourceLineNo">397</span><a id="line.397">    protected V removeEntry(final int pos) {</a>
<span class="sourceLineNo">398</span><a id="line.398">        final V oldValue = value[pos];</a>
<span class="sourceLineNo">399</span><a id="line.399">        value[pos] = null;</a>
<span class="sourceLineNo">400</span><a id="line.400">        size--;</a>
<span class="sourceLineNo">401</span><a id="line.401">        fixOrder(pos);</a>
<span class="sourceLineNo">402</span><a id="line.402">        shiftKeys(pos);</a>
<span class="sourceLineNo">403</span><a id="line.403">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</a>
<span class="sourceLineNo">404</span><a id="line.404">            rehash(n / 2);</a>
<span class="sourceLineNo">405</span><a id="line.405">        return oldValue;</a>
<span class="sourceLineNo">406</span><a id="line.406">    }</a>
<span class="sourceLineNo">407</span><a id="line.407">    protected V removeNullEntry() {</a>
<span class="sourceLineNo">408</span><a id="line.408">        containsNullKey = false;</a>
<span class="sourceLineNo">409</span><a id="line.409">        key[n] = null;</a>
<span class="sourceLineNo">410</span><a id="line.410">        final V oldValue = value[n];</a>
<span class="sourceLineNo">411</span><a id="line.411">        value[n] = null;</a>
<span class="sourceLineNo">412</span><a id="line.412">        size--;</a>
<span class="sourceLineNo">413</span><a id="line.413">        fixOrder(n);</a>
<span class="sourceLineNo">414</span><a id="line.414">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</a>
<span class="sourceLineNo">415</span><a id="line.415">            rehash(n / 2);</a>
<span class="sourceLineNo">416</span><a id="line.416">        return oldValue;</a>
<span class="sourceLineNo">417</span><a id="line.417">    }</a>
<span class="sourceLineNo">418</span><a id="line.418"></a>
<span class="sourceLineNo">419</span><a id="line.419">    /**</a>
<span class="sourceLineNo">420</span><a id="line.420">     * Puts the first key in keyArray with the first value in valueArray, then the second in each and so on.</a>
<span class="sourceLineNo">421</span><a id="line.421">     * The entries are all appended to the end of the iteration order, unless a key was already present. Then,</a>
<span class="sourceLineNo">422</span><a id="line.422">     * its value is changed at the existing position in the iteration order.</a>
<span class="sourceLineNo">423</span><a id="line.423">     * If the lengths of the two arrays are not equal, this puts a number of entries equal to the lesser length.</a>
<span class="sourceLineNo">424</span><a id="line.424">     * If either array is null, this returns without performing any changes.</a>
<span class="sourceLineNo">425</span><a id="line.425">     * @param keyArray an array of K keys that should usually have the same length as valueArray</a>
<span class="sourceLineNo">426</span><a id="line.426">     * @param valueArray an array of V values that should usually have the same length as keyArray</a>
<span class="sourceLineNo">427</span><a id="line.427">     */</a>
<span class="sourceLineNo">428</span><a id="line.428">    public void putAll(final K[] keyArray, final V[] valueArray)</a>
<span class="sourceLineNo">429</span><a id="line.429">    {</a>
<span class="sourceLineNo">430</span><a id="line.430">        if(keyArray == null || valueArray == null)</a>
<span class="sourceLineNo">431</span><a id="line.431">            return;</a>
<span class="sourceLineNo">432</span><a id="line.432">        for (int i = 0; i &lt; keyArray.length &amp;&amp; i &lt; valueArray.length; i++)</a>
<span class="sourceLineNo">433</span><a id="line.433">            put(keyArray[i], valueArray[i]);</a>
<span class="sourceLineNo">434</span><a id="line.434"></a>
<span class="sourceLineNo">435</span><a id="line.435">    }</a>
<span class="sourceLineNo">436</span><a id="line.436"></a>
<span class="sourceLineNo">437</span><a id="line.437">    /**</a>
<span class="sourceLineNo">438</span><a id="line.438">     * Puts all key-value pairs in the Map m into this OrderedMap.</a>
<span class="sourceLineNo">439</span><a id="line.439">     * The entries are all appended to the end of the iteration order, unless a key was already present. Then,</a>
<span class="sourceLineNo">440</span><a id="line.440">     * its value is changed at the existing position in the iteration order. This can take any kind of Map,</a>
<span class="sourceLineNo">441</span><a id="line.441">     * including unordered HashMap objects; if the Map does not have stable ordering, the order in which entries</a>
<span class="sourceLineNo">442</span><a id="line.442">     * will be appended is not stable either. For this reason, OrderedMap, LinkedHashMap, and TreeMap (or other</a>
<span class="sourceLineNo">443</span><a id="line.443">     * SortedMap implementations) will work best when order matters.</a>
<span class="sourceLineNo">444</span><a id="line.444">     * @param m a Map that should have the same or compatible K key and V value types; OrderedMap and TreeMap work best</a>
<span class="sourceLineNo">445</span><a id="line.445">     */</a>
<span class="sourceLineNo">446</span><a id="line.446">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {</a>
<span class="sourceLineNo">447</span><a id="line.447">        if (f &lt;= .5)</a>
<span class="sourceLineNo">448</span><a id="line.448">            ensureCapacity(m.size()); // The resulting map will be sized for</a>
<span class="sourceLineNo">449</span><a id="line.449">            // m.size() elements</a>
<span class="sourceLineNo">450</span><a id="line.450">        else</a>
<span class="sourceLineNo">451</span><a id="line.451">            tryCapacity(size() + m.size()); // The resulting map will be</a>
<span class="sourceLineNo">452</span><a id="line.452">        int n = m.size();</a>
<span class="sourceLineNo">453</span><a id="line.453">        final Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m</a>
<span class="sourceLineNo">454</span><a id="line.454">                .entrySet().iterator();</a>
<span class="sourceLineNo">455</span><a id="line.455">        if (m instanceof OrderedMap) {</a>
<span class="sourceLineNo">456</span><a id="line.456">            Entry&lt;? extends K, ? extends V&gt; e;</a>
<span class="sourceLineNo">457</span><a id="line.457">            while (n-- != 0) {</a>
<span class="sourceLineNo">458</span><a id="line.458">                e = i.next();</a>
<span class="sourceLineNo">459</span><a id="line.459">                put(e.getKey(), e.getValue());</a>
<span class="sourceLineNo">460</span><a id="line.460">            }</a>
<span class="sourceLineNo">461</span><a id="line.461">        } else {</a>
<span class="sourceLineNo">462</span><a id="line.462">            Map.Entry&lt;? extends K, ? extends V&gt; e;</a>
<span class="sourceLineNo">463</span><a id="line.463">            while (n-- != 0) {</a>
<span class="sourceLineNo">464</span><a id="line.464">                e = i.next();</a>
<span class="sourceLineNo">465</span><a id="line.465">                put(e.getKey(), e.getValue());</a>
<span class="sourceLineNo">466</span><a id="line.466">            }</a>
<span class="sourceLineNo">467</span><a id="line.467">        }</a>
<span class="sourceLineNo">468</span><a id="line.468">    }</a>
<span class="sourceLineNo">469</span><a id="line.469">    private int insert(final K k, final V v) {</a>
<span class="sourceLineNo">470</span><a id="line.470">        int pos;</a>
<span class="sourceLineNo">471</span><a id="line.471">        if (k == null) {</a>
<span class="sourceLineNo">472</span><a id="line.472">            if (containsNullKey)</a>
<span class="sourceLineNo">473</span><a id="line.473">                return n;</a>
<span class="sourceLineNo">474</span><a id="line.474">            containsNullKey = true;</a>
<span class="sourceLineNo">475</span><a id="line.475">            pos = n;</a>
<span class="sourceLineNo">476</span><a id="line.476">        } else {</a>
<span class="sourceLineNo">477</span><a id="line.477">            K curr;</a>
<span class="sourceLineNo">478</span><a id="line.478">            final K[] key = this.key;</a>
<span class="sourceLineNo">479</span><a id="line.479">            // The starting point.</a>
<span class="sourceLineNo">480</span><a id="line.480">            if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) != null) {</a>
<span class="sourceLineNo">481</span><a id="line.481">                if (hasher.areEqual(curr, k))</a>
<span class="sourceLineNo">482</span><a id="line.482">                    return pos;</a>
<span class="sourceLineNo">483</span><a id="line.483">                while ((curr = key[pos = (pos + 1) &amp; mask]) != null)</a>
<span class="sourceLineNo">484</span><a id="line.484">                    if (hasher.areEqual(curr, k))</a>
<span class="sourceLineNo">485</span><a id="line.485">                        return pos;</a>
<span class="sourceLineNo">486</span><a id="line.486">            }</a>
<span class="sourceLineNo">487</span><a id="line.487">        }</a>
<span class="sourceLineNo">488</span><a id="line.488">        key[pos] = k;</a>
<span class="sourceLineNo">489</span><a id="line.489">        value[pos] = v;</a>
<span class="sourceLineNo">490</span><a id="line.490">        order.add(pos);</a>
<span class="sourceLineNo">491</span><a id="line.491">        if (size++ &gt;= maxFill)</a>
<span class="sourceLineNo">492</span><a id="line.492">            rehash(arraySize(size + 1, f));</a>
<span class="sourceLineNo">493</span><a id="line.493">        return -1;</a>
<span class="sourceLineNo">494</span><a id="line.494">    }</a>
<span class="sourceLineNo">495</span><a id="line.495">    private int insertAt(final K k, final V v, final int idx) {</a>
<span class="sourceLineNo">496</span><a id="line.496">        int pos;</a>
<span class="sourceLineNo">497</span><a id="line.497">        if (k == null) {</a>
<span class="sourceLineNo">498</span><a id="line.498">            if (containsNullKey)</a>
<span class="sourceLineNo">499</span><a id="line.499">            {</a>
<span class="sourceLineNo">500</span><a id="line.500">                fixOrder(n);</a>
<span class="sourceLineNo">501</span><a id="line.501">                order.insert(idx, n);</a>
<span class="sourceLineNo">502</span><a id="line.502">                return n;</a>
<span class="sourceLineNo">503</span><a id="line.503">            }</a>
<span class="sourceLineNo">504</span><a id="line.504">            containsNullKey = true;</a>
<span class="sourceLineNo">505</span><a id="line.505">            pos = n;</a>
<span class="sourceLineNo">506</span><a id="line.506">        } else {</a>
<span class="sourceLineNo">507</span><a id="line.507">            K curr;</a>
<span class="sourceLineNo">508</span><a id="line.508">            final K[] key = this.key;</a>
<span class="sourceLineNo">509</span><a id="line.509">            // The starting point.</a>
<span class="sourceLineNo">510</span><a id="line.510">            if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) != null) {</a>
<span class="sourceLineNo">511</span><a id="line.511">                if (hasher.areEqual(curr, k))</a>
<span class="sourceLineNo">512</span><a id="line.512">                {</a>
<span class="sourceLineNo">513</span><a id="line.513">                    fixOrder(pos);</a>
<span class="sourceLineNo">514</span><a id="line.514">                    order.insert(idx, pos);</a>
<span class="sourceLineNo">515</span><a id="line.515">                    return pos;</a>
<span class="sourceLineNo">516</span><a id="line.516">                }</a>
<span class="sourceLineNo">517</span><a id="line.517">                while ((curr = key[pos = (pos + 1) &amp; mask]) != null)</a>
<span class="sourceLineNo">518</span><a id="line.518">                    if (hasher.areEqual(curr, k))</a>
<span class="sourceLineNo">519</span><a id="line.519">                    {</a>
<span class="sourceLineNo">520</span><a id="line.520">                        fixOrder(pos);</a>
<span class="sourceLineNo">521</span><a id="line.521">                        order.insert(idx, pos);</a>
<span class="sourceLineNo">522</span><a id="line.522">                        return pos;</a>
<span class="sourceLineNo">523</span><a id="line.523">                    }</a>
<span class="sourceLineNo">524</span><a id="line.524">            }</a>
<span class="sourceLineNo">525</span><a id="line.525">        }</a>
<span class="sourceLineNo">526</span><a id="line.526">        key[pos] = k;</a>
<span class="sourceLineNo">527</span><a id="line.527">        value[pos] = v;</a>
<span class="sourceLineNo">528</span><a id="line.528">        order.insert(idx, pos);</a>
<span class="sourceLineNo">529</span><a id="line.529">        if (size++ &gt;= maxFill)</a>
<span class="sourceLineNo">530</span><a id="line.530">            rehash(arraySize(size + 1, f));</a>
<span class="sourceLineNo">531</span><a id="line.531">        return -1;</a>
<span class="sourceLineNo">532</span><a id="line.532">    }</a>
<span class="sourceLineNo">533</span><a id="line.533">    public V put(final K k, final V v) {</a>
<span class="sourceLineNo">534</span><a id="line.534">        final int pos = insert(k, v);</a>
<span class="sourceLineNo">535</span><a id="line.535">        if (pos &lt; 0)</a>
<span class="sourceLineNo">536</span><a id="line.536">            return defRetValue;</a>
<span class="sourceLineNo">537</span><a id="line.537">        final V oldValue = value[pos];</a>
<span class="sourceLineNo">538</span><a id="line.538">        value[pos] = v;</a>
<span class="sourceLineNo">539</span><a id="line.539">        return oldValue;</a>
<span class="sourceLineNo">540</span><a id="line.540">    }</a>
<span class="sourceLineNo">541</span><a id="line.541">    public V putAt(final K k, final V v, final int idx) {</a>
<span class="sourceLineNo">542</span><a id="line.542">        final int pos = insertAt(k, v, idx);</a>
<span class="sourceLineNo">543</span><a id="line.543">        if (pos &lt; 0)</a>
<span class="sourceLineNo">544</span><a id="line.544">            return defRetValue;</a>
<span class="sourceLineNo">545</span><a id="line.545">        final V oldValue = value[pos];</a>
<span class="sourceLineNo">546</span><a id="line.546">        value[pos] = v;</a>
<span class="sourceLineNo">547</span><a id="line.547">        return oldValue;</a>
<span class="sourceLineNo">548</span><a id="line.548">    }</a>
<span class="sourceLineNo">549</span><a id="line.549">    /**</a>
<span class="sourceLineNo">550</span><a id="line.550">     * Shifts left entries with the specified hash code, starting at the</a>
<span class="sourceLineNo">551</span><a id="line.551">     * specified position, and empties the resulting free entry.</a>
<span class="sourceLineNo">552</span><a id="line.552">     *</a>
<span class="sourceLineNo">553</span><a id="line.553">     * @param pos</a>
<span class="sourceLineNo">554</span><a id="line.554">     *            a starting position.</a>
<span class="sourceLineNo">555</span><a id="line.555">     */</a>
<span class="sourceLineNo">556</span><a id="line.556">    protected final void shiftKeys(int pos) {</a>
<span class="sourceLineNo">557</span><a id="line.557">        // Shift entries with the same hash.</a>
<span class="sourceLineNo">558</span><a id="line.558">        int last, slot;</a>
<span class="sourceLineNo">559</span><a id="line.559">        K curr;</a>
<span class="sourceLineNo">560</span><a id="line.560">        final K[] key = this.key;</a>
<span class="sourceLineNo">561</span><a id="line.561">        for (;;) {</a>
<span class="sourceLineNo">562</span><a id="line.562">            pos = ((last = pos) + 1) &amp; mask;</a>
<span class="sourceLineNo">563</span><a id="line.563">            for (;;) {</a>
<span class="sourceLineNo">564</span><a id="line.564">                if ((curr = key[pos]) == null) {</a>
<span class="sourceLineNo">565</span><a id="line.565">                    key[last] = null;</a>
<span class="sourceLineNo">566</span><a id="line.566">                    value[last] = null;</a>
<span class="sourceLineNo">567</span><a id="line.567">                    return;</a>
<span class="sourceLineNo">568</span><a id="line.568">                }</a>
<span class="sourceLineNo">569</span><a id="line.569">                slot = (hasher.hash(curr))</a>
<span class="sourceLineNo">570</span><a id="line.570">                        &amp; mask;</a>
<span class="sourceLineNo">571</span><a id="line.571">                if (last &lt;= pos ? last &gt;= slot || slot &gt; pos : last &gt;= slot</a>
<span class="sourceLineNo">572</span><a id="line.572">                        &amp;&amp; slot &gt; pos)</a>
<span class="sourceLineNo">573</span><a id="line.573">                    break;</a>
<span class="sourceLineNo">574</span><a id="line.574">                pos = (pos + 1) &amp; mask;</a>
<span class="sourceLineNo">575</span><a id="line.575">            }</a>
<span class="sourceLineNo">576</span><a id="line.576">            key[last] = curr;</a>
<span class="sourceLineNo">577</span><a id="line.577">            value[last] = value[pos];</a>
<span class="sourceLineNo">578</span><a id="line.578">            fixOrder(pos, last);</a>
<span class="sourceLineNo">579</span><a id="line.579">        }</a>
<span class="sourceLineNo">580</span><a id="line.580">    }</a>
<span class="sourceLineNo">581</span><a id="line.581">    public V remove(final Object k) {</a>
<span class="sourceLineNo">582</span><a id="line.582">        if (k == null) {</a>
<span class="sourceLineNo">583</span><a id="line.583">            if (containsNullKey)</a>
<span class="sourceLineNo">584</span><a id="line.584">                return removeNullEntry();</a>
<span class="sourceLineNo">585</span><a id="line.585">            return defRetValue;</a>
<span class="sourceLineNo">586</span><a id="line.586">        }</a>
<span class="sourceLineNo">587</span><a id="line.587">        K curr;</a>
<span class="sourceLineNo">588</span><a id="line.588">        final K[] key = this.key;</a>
<span class="sourceLineNo">589</span><a id="line.589">        int pos;</a>
<span class="sourceLineNo">590</span><a id="line.590">        // The starting point.</a>
<span class="sourceLineNo">591</span><a id="line.591">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</a>
<span class="sourceLineNo">592</span><a id="line.592">            return defRetValue;</a>
<span class="sourceLineNo">593</span><a id="line.593">        if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">594</span><a id="line.594">            return removeEntry(pos);</a>
<span class="sourceLineNo">595</span><a id="line.595">        while (true) {</a>
<span class="sourceLineNo">596</span><a id="line.596">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</a>
<span class="sourceLineNo">597</span><a id="line.597">                return defRetValue;</a>
<span class="sourceLineNo">598</span><a id="line.598">            if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">599</span><a id="line.599">                return removeEntry(pos);</a>
<span class="sourceLineNo">600</span><a id="line.600">        }</a>
<span class="sourceLineNo">601</span><a id="line.601">    }</a>
<span class="sourceLineNo">602</span><a id="line.602">    private V setValue(final int pos, final V v) {</a>
<span class="sourceLineNo">603</span><a id="line.603">        final V oldValue = value[pos];</a>
<span class="sourceLineNo">604</span><a id="line.604">        value[pos] = v;</a>
<span class="sourceLineNo">605</span><a id="line.605">        return oldValue;</a>
<span class="sourceLineNo">606</span><a id="line.606">    }</a>
<span class="sourceLineNo">607</span><a id="line.607">    /**</a>
<span class="sourceLineNo">608</span><a id="line.608">     * Removes the mapping associated with the first key in iteration order.</a>
<span class="sourceLineNo">609</span><a id="line.609">     *</a>
<span class="sourceLineNo">610</span><a id="line.610">     * @return the value previously associated with the first key in iteration</a>
<span class="sourceLineNo">611</span><a id="line.611">     *         order.</a>
<span class="sourceLineNo">612</span><a id="line.612">     * @throws NoSuchElementException</a>
<span class="sourceLineNo">613</span><a id="line.613">     *             is this map is empty.</a>
<span class="sourceLineNo">614</span><a id="line.614">     */</a>
<span class="sourceLineNo">615</span><a id="line.615">    public V removeFirst() {</a>
<span class="sourceLineNo">616</span><a id="line.616">        if (size == 0)</a>
<span class="sourceLineNo">617</span><a id="line.617">            throw new NoSuchElementException();</a>
<span class="sourceLineNo">618</span><a id="line.618">        final int pos = order.removeIndex(0);</a>
<span class="sourceLineNo">619</span><a id="line.619"></a>
<span class="sourceLineNo">620</span><a id="line.620">        size--;</a>
<span class="sourceLineNo">621</span><a id="line.621">        final V v = value[pos];</a>
<span class="sourceLineNo">622</span><a id="line.622">        if (pos == n) {</a>
<span class="sourceLineNo">623</span><a id="line.623">            containsNullKey = false;</a>
<span class="sourceLineNo">624</span><a id="line.624">            key[n] = null;</a>
<span class="sourceLineNo">625</span><a id="line.625">            value[n] = null;</a>
<span class="sourceLineNo">626</span><a id="line.626">        } else</a>
<span class="sourceLineNo">627</span><a id="line.627">            shiftKeys(pos);</a>
<span class="sourceLineNo">628</span><a id="line.628">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</a>
<span class="sourceLineNo">629</span><a id="line.629">            rehash(n / 2);</a>
<span class="sourceLineNo">630</span><a id="line.630">        return v;</a>
<span class="sourceLineNo">631</span><a id="line.631">    }</a>
<span class="sourceLineNo">632</span><a id="line.632">    /**</a>
<span class="sourceLineNo">633</span><a id="line.633">     * Removes the mapping associated with the last key in iteration order.</a>
<span class="sourceLineNo">634</span><a id="line.634">     *</a>
<span class="sourceLineNo">635</span><a id="line.635">     * @return the value previously associated with the last key in iteration</a>
<span class="sourceLineNo">636</span><a id="line.636">     *         order.</a>
<span class="sourceLineNo">637</span><a id="line.637">     * @throws NoSuchElementException</a>
<span class="sourceLineNo">638</span><a id="line.638">     *             is this map is empty.</a>
<span class="sourceLineNo">639</span><a id="line.639">     */</a>
<span class="sourceLineNo">640</span><a id="line.640">    public V removeLast() {</a>
<span class="sourceLineNo">641</span><a id="line.641">        if (size == 0)</a>
<span class="sourceLineNo">642</span><a id="line.642">            throw new NoSuchElementException();</a>
<span class="sourceLineNo">643</span><a id="line.643">        final int pos = order.items[order.size-1];</a>
<span class="sourceLineNo">644</span><a id="line.644">        order.pop();</a>
<span class="sourceLineNo">645</span><a id="line.645">        size--;</a>
<span class="sourceLineNo">646</span><a id="line.646">        final V v = value[pos];</a>
<span class="sourceLineNo">647</span><a id="line.647">        if (pos == n) {</a>
<span class="sourceLineNo">648</span><a id="line.648">            containsNullKey = false;</a>
<span class="sourceLineNo">649</span><a id="line.649">            key[n] = null;</a>
<span class="sourceLineNo">650</span><a id="line.650">            value[n] = null;</a>
<span class="sourceLineNo">651</span><a id="line.651">        } else</a>
<span class="sourceLineNo">652</span><a id="line.652">            shiftKeys(pos);</a>
<span class="sourceLineNo">653</span><a id="line.653">        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)</a>
<span class="sourceLineNo">654</span><a id="line.654">            rehash(n / 2);</a>
<span class="sourceLineNo">655</span><a id="line.655">        return v;</a>
<span class="sourceLineNo">656</span><a id="line.656">    }</a>
<span class="sourceLineNo">657</span><a id="line.657">    private void moveIndexToFirst(final int i) {</a>
<span class="sourceLineNo">658</span><a id="line.658">        if(size &lt;= 1 || order.items[0] == i)</a>
<span class="sourceLineNo">659</span><a id="line.659">            return;</a>
<span class="sourceLineNo">660</span><a id="line.660">        order.moveToFirst(i);</a>
<span class="sourceLineNo">661</span><a id="line.661">    }</a>
<span class="sourceLineNo">662</span><a id="line.662">    private void moveIndexToLast(final int i) {</a>
<span class="sourceLineNo">663</span><a id="line.663">        if(size &lt;= 1 || order.items[order.size-1] == i)</a>
<span class="sourceLineNo">664</span><a id="line.664">            return;</a>
<span class="sourceLineNo">665</span><a id="line.665">        order.moveToLast(i);</a>
<span class="sourceLineNo">666</span><a id="line.666">    }</a>
<span class="sourceLineNo">667</span><a id="line.667">    /**</a>
<span class="sourceLineNo">668</span><a id="line.668">     * Returns the value to which the given key is mapped; if the key is</a>
<span class="sourceLineNo">669</span><a id="line.669">     * present, it is moved to the first position of the iteration order.</a>
<span class="sourceLineNo">670</span><a id="line.670">     *</a>
<span class="sourceLineNo">671</span><a id="line.671">     * @param k</a>
<span class="sourceLineNo">672</span><a id="line.672">     *            the key.</a>
<span class="sourceLineNo">673</span><a id="line.673">     * @return the corresponding value, or the</a>
<span class="sourceLineNo">674</span><a id="line.674">     *         {@linkplain #defaultReturnValue() default return value} if no</a>
<span class="sourceLineNo">675</span><a id="line.675">     *         value was present for the given key.</a>
<span class="sourceLineNo">676</span><a id="line.676">     */</a>
<span class="sourceLineNo">677</span><a id="line.677">    public V getAndMoveToFirst(final K k) {</a>
<span class="sourceLineNo">678</span><a id="line.678">        if (k == null) {</a>
<span class="sourceLineNo">679</span><a id="line.679">            if (containsNullKey) {</a>
<span class="sourceLineNo">680</span><a id="line.680">                moveIndexToFirst(n);</a>
<span class="sourceLineNo">681</span><a id="line.681">                return value[n];</a>
<span class="sourceLineNo">682</span><a id="line.682">            }</a>
<span class="sourceLineNo">683</span><a id="line.683">            return defRetValue;</a>
<span class="sourceLineNo">684</span><a id="line.684">        }</a>
<span class="sourceLineNo">685</span><a id="line.685">        K curr;</a>
<span class="sourceLineNo">686</span><a id="line.686">        final K[] key = this.key;</a>
<span class="sourceLineNo">687</span><a id="line.687">        int pos;</a>
<span class="sourceLineNo">688</span><a id="line.688">        // The starting point.</a>
<span class="sourceLineNo">689</span><a id="line.689">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</a>
<span class="sourceLineNo">690</span><a id="line.690">            return defRetValue;</a>
<span class="sourceLineNo">691</span><a id="line.691">        if (hasher.areEqual(k, curr)) {</a>
<span class="sourceLineNo">692</span><a id="line.692">            moveIndexToFirst(pos);</a>
<span class="sourceLineNo">693</span><a id="line.693">            return value[pos];</a>
<span class="sourceLineNo">694</span><a id="line.694">        }</a>
<span class="sourceLineNo">695</span><a id="line.695">        // There's always an unused entry.</a>
<span class="sourceLineNo">696</span><a id="line.696">        while (true) {</a>
<span class="sourceLineNo">697</span><a id="line.697">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</a>
<span class="sourceLineNo">698</span><a id="line.698">                return defRetValue;</a>
<span class="sourceLineNo">699</span><a id="line.699">            if (hasher.areEqual(k, curr)) {</a>
<span class="sourceLineNo">700</span><a id="line.700">                moveIndexToFirst(pos);</a>
<span class="sourceLineNo">701</span><a id="line.701">                return value[pos];</a>
<span class="sourceLineNo">702</span><a id="line.702">            }</a>
<span class="sourceLineNo">703</span><a id="line.703">        }</a>
<span class="sourceLineNo">704</span><a id="line.704">    }</a>
<span class="sourceLineNo">705</span><a id="line.705">    /**</a>
<span class="sourceLineNo">706</span><a id="line.706">     * Returns the value to which the given key is mapped; if the key is</a>
<span class="sourceLineNo">707</span><a id="line.707">     * present, it is moved to the last position of the iteration order.</a>
<span class="sourceLineNo">708</span><a id="line.708">     *</a>
<span class="sourceLineNo">709</span><a id="line.709">     * @param k the key.</a>
<span class="sourceLineNo">710</span><a id="line.710">     * @return the corresponding value, or the</a>
<span class="sourceLineNo">711</span><a id="line.711">     *         {@linkplain #defaultReturnValue() default return value} if no</a>
<span class="sourceLineNo">712</span><a id="line.712">     *         value was present for the given key.</a>
<span class="sourceLineNo">713</span><a id="line.713">     */</a>
<span class="sourceLineNo">714</span><a id="line.714">    public V getAndMoveToLast(final K k) {</a>
<span class="sourceLineNo">715</span><a id="line.715">        if (k == null) {</a>
<span class="sourceLineNo">716</span><a id="line.716">            if (containsNullKey) {</a>
<span class="sourceLineNo">717</span><a id="line.717">                moveIndexToLast(n);</a>
<span class="sourceLineNo">718</span><a id="line.718">                return value[n];</a>
<span class="sourceLineNo">719</span><a id="line.719">            }</a>
<span class="sourceLineNo">720</span><a id="line.720">            return defRetValue;</a>
<span class="sourceLineNo">721</span><a id="line.721">        }</a>
<span class="sourceLineNo">722</span><a id="line.722">        K curr;</a>
<span class="sourceLineNo">723</span><a id="line.723">        final K[] key = this.key;</a>
<span class="sourceLineNo">724</span><a id="line.724">        int pos;</a>
<span class="sourceLineNo">725</span><a id="line.725">        // The starting point.</a>
<span class="sourceLineNo">726</span><a id="line.726">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</a>
<span class="sourceLineNo">727</span><a id="line.727">            return defRetValue;</a>
<span class="sourceLineNo">728</span><a id="line.728">        if (hasher.areEqual(k, curr)) {</a>
<span class="sourceLineNo">729</span><a id="line.729">            moveIndexToLast(pos);</a>
<span class="sourceLineNo">730</span><a id="line.730">            return value[pos];</a>
<span class="sourceLineNo">731</span><a id="line.731">        }</a>
<span class="sourceLineNo">732</span><a id="line.732">        // There's always an unused entry.</a>
<span class="sourceLineNo">733</span><a id="line.733">        while (true) {</a>
<span class="sourceLineNo">734</span><a id="line.734">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</a>
<span class="sourceLineNo">735</span><a id="line.735">                return defRetValue;</a>
<span class="sourceLineNo">736</span><a id="line.736">            if (hasher.areEqual(k, curr)) {</a>
<span class="sourceLineNo">737</span><a id="line.737">                moveIndexToLast(pos);</a>
<span class="sourceLineNo">738</span><a id="line.738">                return value[pos];</a>
<span class="sourceLineNo">739</span><a id="line.739">            }</a>
<span class="sourceLineNo">740</span><a id="line.740">        }</a>
<span class="sourceLineNo">741</span><a id="line.741">    }</a>
<span class="sourceLineNo">742</span><a id="line.742">    /**</a>
<span class="sourceLineNo">743</span><a id="line.743">     * Adds a pair to the map; if the key is already present, it is moved to the</a>
<span class="sourceLineNo">744</span><a id="line.744">     * first position of the iteration order.</a>
<span class="sourceLineNo">745</span><a id="line.745">     *</a>
<span class="sourceLineNo">746</span><a id="line.746">     * @param k</a>
<span class="sourceLineNo">747</span><a id="line.747">     *            the key.</a>
<span class="sourceLineNo">748</span><a id="line.748">     * @param v</a>
<span class="sourceLineNo">749</span><a id="line.749">     *            the value.</a>
<span class="sourceLineNo">750</span><a id="line.750">     * @return the old value, or the {@linkplain #defaultReturnValue() default</a>
<span class="sourceLineNo">751</span><a id="line.751">     *         return value} if no value was present for the given key.</a>
<span class="sourceLineNo">752</span><a id="line.752">     */</a>
<span class="sourceLineNo">753</span><a id="line.753">    public V putAndMoveToFirst(final K k, final V v) {</a>
<span class="sourceLineNo">754</span><a id="line.754">        int pos;</a>
<span class="sourceLineNo">755</span><a id="line.755">        if (k == null) {</a>
<span class="sourceLineNo">756</span><a id="line.756">            if (containsNullKey) {</a>
<span class="sourceLineNo">757</span><a id="line.757">                moveIndexToFirst(n);</a>
<span class="sourceLineNo">758</span><a id="line.758">                return setValue(n, v);</a>
<span class="sourceLineNo">759</span><a id="line.759">            }</a>
<span class="sourceLineNo">760</span><a id="line.760">            containsNullKey = true;</a>
<span class="sourceLineNo">761</span><a id="line.761">            pos = n;</a>
<span class="sourceLineNo">762</span><a id="line.762">        } else {</a>
<span class="sourceLineNo">763</span><a id="line.763">            K curr;</a>
<span class="sourceLineNo">764</span><a id="line.764">            final K[] key = this.key;</a>
<span class="sourceLineNo">765</span><a id="line.765">            // The starting point.</a>
<span class="sourceLineNo">766</span><a id="line.766">            if (!((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)) {</a>
<span class="sourceLineNo">767</span><a id="line.767">                if (hasher.areEqual(curr, k)) {</a>
<span class="sourceLineNo">768</span><a id="line.768">                    moveIndexToFirst(pos);</a>
<span class="sourceLineNo">769</span><a id="line.769">                    return setValue(pos, v);</a>
<span class="sourceLineNo">770</span><a id="line.770">                }</a>
<span class="sourceLineNo">771</span><a id="line.771">                while (!((curr = key[pos = (pos + 1) &amp; mask]) == null))</a>
<span class="sourceLineNo">772</span><a id="line.772">                    if (hasher.areEqual(curr, k)) {</a>
<span class="sourceLineNo">773</span><a id="line.773">                        moveIndexToFirst(pos);</a>
<span class="sourceLineNo">774</span><a id="line.774">                        return setValue(pos, v);</a>
<span class="sourceLineNo">775</span><a id="line.775">                    }</a>
<span class="sourceLineNo">776</span><a id="line.776">            }</a>
<span class="sourceLineNo">777</span><a id="line.777">        }</a>
<span class="sourceLineNo">778</span><a id="line.778">        key[pos] = k;</a>
<span class="sourceLineNo">779</span><a id="line.779">        value[pos] = v;</a>
<span class="sourceLineNo">780</span><a id="line.780">        order.insert(0, pos);</a>
<span class="sourceLineNo">781</span><a id="line.781">        if (size++ &gt;= maxFill)</a>
<span class="sourceLineNo">782</span><a id="line.782">            rehash(arraySize(size, f));</a>
<span class="sourceLineNo">783</span><a id="line.783">        return defRetValue;</a>
<span class="sourceLineNo">784</span><a id="line.784">    }</a>
<span class="sourceLineNo">785</span><a id="line.785">    /**</a>
<span class="sourceLineNo">786</span><a id="line.786">     * Adds a pair to the map; if the key is already present, it is moved to the</a>
<span class="sourceLineNo">787</span><a id="line.787">     * last position of the iteration order.</a>
<span class="sourceLineNo">788</span><a id="line.788">     *</a>
<span class="sourceLineNo">789</span><a id="line.789">     * @param k</a>
<span class="sourceLineNo">790</span><a id="line.790">     *            the key.</a>
<span class="sourceLineNo">791</span><a id="line.791">     * @param v</a>
<span class="sourceLineNo">792</span><a id="line.792">     *            the value.</a>
<span class="sourceLineNo">793</span><a id="line.793">     * @return the old value, or the {@linkplain #defaultReturnValue() default</a>
<span class="sourceLineNo">794</span><a id="line.794">     *         return value} if no value was present for the given key.</a>
<span class="sourceLineNo">795</span><a id="line.795">     */</a>
<span class="sourceLineNo">796</span><a id="line.796">    public V putAndMoveToLast(final K k, final V v) {</a>
<span class="sourceLineNo">797</span><a id="line.797">        int pos;</a>
<span class="sourceLineNo">798</span><a id="line.798">        if (k == null) {</a>
<span class="sourceLineNo">799</span><a id="line.799">            if (containsNullKey) {</a>
<span class="sourceLineNo">800</span><a id="line.800">                moveIndexToLast(n);</a>
<span class="sourceLineNo">801</span><a id="line.801">                return setValue(n, v);</a>
<span class="sourceLineNo">802</span><a id="line.802">            }</a>
<span class="sourceLineNo">803</span><a id="line.803">            containsNullKey = true;</a>
<span class="sourceLineNo">804</span><a id="line.804">            pos = n;</a>
<span class="sourceLineNo">805</span><a id="line.805">        } else {</a>
<span class="sourceLineNo">806</span><a id="line.806">            K curr;</a>
<span class="sourceLineNo">807</span><a id="line.807">            final K[] key = this.key;</a>
<span class="sourceLineNo">808</span><a id="line.808">            // The starting point.</a>
<span class="sourceLineNo">809</span><a id="line.809">            if (!((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)) {</a>
<span class="sourceLineNo">810</span><a id="line.810">                if (hasher.areEqual(curr, k)) {</a>
<span class="sourceLineNo">811</span><a id="line.811">                    moveIndexToLast(pos);</a>
<span class="sourceLineNo">812</span><a id="line.812">                    return setValue(pos, v);</a>
<span class="sourceLineNo">813</span><a id="line.813">                }</a>
<span class="sourceLineNo">814</span><a id="line.814">                while (!((curr = key[pos = (pos + 1) &amp; mask]) == null))</a>
<span class="sourceLineNo">815</span><a id="line.815">                    if (hasher.areEqual(curr, k)) {</a>
<span class="sourceLineNo">816</span><a id="line.816">                        moveIndexToLast(pos);</a>
<span class="sourceLineNo">817</span><a id="line.817">                        return setValue(pos, v);</a>
<span class="sourceLineNo">818</span><a id="line.818">                    }</a>
<span class="sourceLineNo">819</span><a id="line.819">            }</a>
<span class="sourceLineNo">820</span><a id="line.820">        }</a>
<span class="sourceLineNo">821</span><a id="line.821">        key[pos] = k;</a>
<span class="sourceLineNo">822</span><a id="line.822">        value[pos] = v;</a>
<span class="sourceLineNo">823</span><a id="line.823">        if(order.peek() != pos)</a>
<span class="sourceLineNo">824</span><a id="line.824">            order.add(pos);</a>
<span class="sourceLineNo">825</span><a id="line.825">        if (size++ &gt;= maxFill)</a>
<span class="sourceLineNo">826</span><a id="line.826">            rehash(arraySize(size, f));</a>
<span class="sourceLineNo">827</span><a id="line.827">        return defRetValue;</a>
<span class="sourceLineNo">828</span><a id="line.828">    }</a>
<span class="sourceLineNo">829</span><a id="line.829">    public V get(final Object k) {</a>
<span class="sourceLineNo">830</span><a id="line.830">        if (k == null)</a>
<span class="sourceLineNo">831</span><a id="line.831">            return containsNullKey ? value[n] : defRetValue;</a>
<span class="sourceLineNo">832</span><a id="line.832">        K curr;</a>
<span class="sourceLineNo">833</span><a id="line.833">        final K[] key = this.key;</a>
<span class="sourceLineNo">834</span><a id="line.834">        int pos;</a>
<span class="sourceLineNo">835</span><a id="line.835">        // The starting point.</a>
<span class="sourceLineNo">836</span><a id="line.836">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</a>
<span class="sourceLineNo">837</span><a id="line.837">            return defRetValue;</a>
<span class="sourceLineNo">838</span><a id="line.838">        if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">839</span><a id="line.839">            return value[pos];</a>
<span class="sourceLineNo">840</span><a id="line.840">        // There's always an unused entry.</a>
<span class="sourceLineNo">841</span><a id="line.841">        while (true) {</a>
<span class="sourceLineNo">842</span><a id="line.842">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</a>
<span class="sourceLineNo">843</span><a id="line.843">                return defRetValue;</a>
<span class="sourceLineNo">844</span><a id="line.844">            if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">845</span><a id="line.845">                return value[pos];</a>
<span class="sourceLineNo">846</span><a id="line.846">        }</a>
<span class="sourceLineNo">847</span><a id="line.847">    }</a>
<span class="sourceLineNo">848</span><a id="line.848"></a>
<span class="sourceLineNo">849</span><a id="line.849"></a>
<span class="sourceLineNo">850</span><a id="line.850">    public V getOrDefault(final Object k, final V defaultValue) {</a>
<span class="sourceLineNo">851</span><a id="line.851">        if (k == null)</a>
<span class="sourceLineNo">852</span><a id="line.852">            return containsNullKey ? value[n] : defaultValue;</a>
<span class="sourceLineNo">853</span><a id="line.853">        K curr;</a>
<span class="sourceLineNo">854</span><a id="line.854">        final K[] key = this.key;</a>
<span class="sourceLineNo">855</span><a id="line.855">        int pos;</a>
<span class="sourceLineNo">856</span><a id="line.856">        // The starting point.</a>
<span class="sourceLineNo">857</span><a id="line.857">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</a>
<span class="sourceLineNo">858</span><a id="line.858">            return defaultValue;</a>
<span class="sourceLineNo">859</span><a id="line.859">        if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">860</span><a id="line.860">            return value[pos];</a>
<span class="sourceLineNo">861</span><a id="line.861">        // There's always an unused entry.</a>
<span class="sourceLineNo">862</span><a id="line.862">        while (true) {</a>
<span class="sourceLineNo">863</span><a id="line.863">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</a>
<span class="sourceLineNo">864</span><a id="line.864">                return defaultValue;</a>
<span class="sourceLineNo">865</span><a id="line.865">            if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">866</span><a id="line.866">                return value[pos];</a>
<span class="sourceLineNo">867</span><a id="line.867">        }</a>
<span class="sourceLineNo">868</span><a id="line.868">    }</a>
<span class="sourceLineNo">869</span><a id="line.869"></a>
<span class="sourceLineNo">870</span><a id="line.870">    protected int positionOf(final Object k) {</a>
<span class="sourceLineNo">871</span><a id="line.871">        if (k == null)</a>
<span class="sourceLineNo">872</span><a id="line.872">        {</a>
<span class="sourceLineNo">873</span><a id="line.873">            if(containsNullKey)</a>
<span class="sourceLineNo">874</span><a id="line.874">                return n;</a>
<span class="sourceLineNo">875</span><a id="line.875">            else</a>
<span class="sourceLineNo">876</span><a id="line.876">                return -1;</a>
<span class="sourceLineNo">877</span><a id="line.877">        }</a>
<span class="sourceLineNo">878</span><a id="line.878">        K curr;</a>
<span class="sourceLineNo">879</span><a id="line.879">        final K[] key = this.key;</a>
<span class="sourceLineNo">880</span><a id="line.880">        int pos;</a>
<span class="sourceLineNo">881</span><a id="line.881">        // The starting point.</a>
<span class="sourceLineNo">882</span><a id="line.882">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</a>
<span class="sourceLineNo">883</span><a id="line.883">            return -1;</a>
<span class="sourceLineNo">884</span><a id="line.884">        if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">885</span><a id="line.885">            return pos;</a>
<span class="sourceLineNo">886</span><a id="line.886">        // There's always an unused entry.</a>
<span class="sourceLineNo">887</span><a id="line.887">        while (true) {</a>
<span class="sourceLineNo">888</span><a id="line.888">            if ((curr = key[pos = pos + 1 &amp; mask]) == null)</a>
<span class="sourceLineNo">889</span><a id="line.889">                return -1;</a>
<span class="sourceLineNo">890</span><a id="line.890">            if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">891</span><a id="line.891">                return pos;</a>
<span class="sourceLineNo">892</span><a id="line.892">        }</a>
<span class="sourceLineNo">893</span><a id="line.893">    }</a>
<span class="sourceLineNo">894</span><a id="line.894"></a>
<span class="sourceLineNo">895</span><a id="line.895">    /**</a>
<span class="sourceLineNo">896</span><a id="line.896">     * Gets the position in the ordering of the given key, though not as efficiently as some data structures can do it</a>
<span class="sourceLineNo">897</span><a id="line.897">     * (e.g. {@link Arrangement} can access ordering position very quickly but doesn't store other values on its own).</a>
<span class="sourceLineNo">898</span><a id="line.898">     * Returns a value that is at least 0 if it found k, or -1 if k was not present.</a>
<span class="sourceLineNo">899</span><a id="line.899">     * @param k a key or possible key that this should find the index of</a>
<span class="sourceLineNo">900</span><a id="line.900">     * @return the index of k, if present, or -1 if it is not present in this OrderedMap</a>
<span class="sourceLineNo">901</span><a id="line.901">     */</a>
<span class="sourceLineNo">902</span><a id="line.902">    public int indexOf(final Object k)</a>
<span class="sourceLineNo">903</span><a id="line.903">    {</a>
<span class="sourceLineNo">904</span><a id="line.904">        int pos = positionOf(k);</a>
<span class="sourceLineNo">905</span><a id="line.905">        return (pos &lt; 0) ? -1 : order.indexOf(pos);</a>
<span class="sourceLineNo">906</span><a id="line.906">    }</a>
<span class="sourceLineNo">907</span><a id="line.907"></a>
<span class="sourceLineNo">908</span><a id="line.908">    /**</a>
<span class="sourceLineNo">909</span><a id="line.909">     * Swaps the positions in the ordering for the given items, if they are both present. Returns true if the ordering</a>
<span class="sourceLineNo">910</span><a id="line.910">     * changed as a result of this call, or false if it stayed the same (which can be because left or right was not</a>
<span class="sourceLineNo">911</span><a id="line.911">     * present, or because left and right are the same reference (so swapping would do nothing)).</a>
<span class="sourceLineNo">912</span><a id="line.912">     * @param left an item that should be present in this OrderedMap</a>
<span class="sourceLineNo">913</span><a id="line.913">     * @param right an item that should be present in this OrderedMap</a>
<span class="sourceLineNo">914</span><a id="line.914">     * @return true if this OrderedMap changed in ordering as a result of this call, or false otherwise</a>
<span class="sourceLineNo">915</span><a id="line.915">     */</a>
<span class="sourceLineNo">916</span><a id="line.916">    public boolean swap(final K left, final K right)</a>
<span class="sourceLineNo">917</span><a id="line.917">    {</a>
<span class="sourceLineNo">918</span><a id="line.918">        if(left == right) return false;</a>
<span class="sourceLineNo">919</span><a id="line.919">        int l = indexOf(left);</a>
<span class="sourceLineNo">920</span><a id="line.920">        if(l &lt; 0) return false;</a>
<span class="sourceLineNo">921</span><a id="line.921">        int r = indexOf(right);</a>
<span class="sourceLineNo">922</span><a id="line.922">        if(r &lt; 0) return false;</a>
<span class="sourceLineNo">923</span><a id="line.923">        order.swap(l, r);</a>
<span class="sourceLineNo">924</span><a id="line.924">        return true;</a>
<span class="sourceLineNo">925</span><a id="line.925">    }</a>
<span class="sourceLineNo">926</span><a id="line.926">    /**</a>
<span class="sourceLineNo">927</span><a id="line.927">     * Swaps the given indices in the ordering, if they are both valid int indices. Returns true if the ordering</a>
<span class="sourceLineNo">928</span><a id="line.928">     * changed as a result of this call, or false if it stayed the same (which can be because left or right referred to</a>
<span class="sourceLineNo">929</span><a id="line.929">     * an out-of-bounds index, or because left and right are equal (so swapping would do nothing)).</a>
<span class="sourceLineNo">930</span><a id="line.930">     * @param left an index of an item in this OrderedMap, at least 0 and less than {@link #size()}</a>
<span class="sourceLineNo">931</span><a id="line.931">     * @param right an index of an item in this OrderedMap, at least 0 and less than {@link #size()}</a>
<span class="sourceLineNo">932</span><a id="line.932">     * @return true if this OrderedMap changed in ordering as a result of this call, or false otherwise</a>
<span class="sourceLineNo">933</span><a id="line.933">     */</a>
<span class="sourceLineNo">934</span><a id="line.934">    public boolean swapIndices(final int left, final int right)</a>
<span class="sourceLineNo">935</span><a id="line.935">    {</a>
<span class="sourceLineNo">936</span><a id="line.936">        if(left &lt; 0 || right &lt; 0 || left &gt;= order.size || right &gt;= order.size || left == right) return false;</a>
<span class="sourceLineNo">937</span><a id="line.937">        order.swap(left, right);</a>
<span class="sourceLineNo">938</span><a id="line.938">        return true;</a>
<span class="sourceLineNo">939</span><a id="line.939">    }</a>
<span class="sourceLineNo">940</span><a id="line.940"></a>
<span class="sourceLineNo">941</span><a id="line.941"></a>
<span class="sourceLineNo">942</span><a id="line.942">    public boolean containsKey(final Object k) {</a>
<span class="sourceLineNo">943</span><a id="line.943">        if (k == null)</a>
<span class="sourceLineNo">944</span><a id="line.944">            return containsNullKey;</a>
<span class="sourceLineNo">945</span><a id="line.945">        K curr;</a>
<span class="sourceLineNo">946</span><a id="line.946">        final K[] key = this.key;</a>
<span class="sourceLineNo">947</span><a id="line.947">        int pos;</a>
<span class="sourceLineNo">948</span><a id="line.948">        // The starting point.</a>
<span class="sourceLineNo">949</span><a id="line.949">        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</a>
<span class="sourceLineNo">950</span><a id="line.950">            return false;</a>
<span class="sourceLineNo">951</span><a id="line.951">        if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">952</span><a id="line.952">            return true;</a>
<span class="sourceLineNo">953</span><a id="line.953">        // There's always an unused entry.</a>
<span class="sourceLineNo">954</span><a id="line.954">        while (true) {</a>
<span class="sourceLineNo">955</span><a id="line.955">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</a>
<span class="sourceLineNo">956</span><a id="line.956">                return false;</a>
<span class="sourceLineNo">957</span><a id="line.957">            if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">958</span><a id="line.958">                return true;</a>
<span class="sourceLineNo">959</span><a id="line.959">        }</a>
<span class="sourceLineNo">960</span><a id="line.960">    }</a>
<span class="sourceLineNo">961</span><a id="line.961">    public boolean containsValue(final Object v) {</a>
<span class="sourceLineNo">962</span><a id="line.962">        final V[] value = this.value;</a>
<span class="sourceLineNo">963</span><a id="line.963">        final K[] key = this.key;</a>
<span class="sourceLineNo">964</span><a id="line.964">        if (containsNullKey</a>
<span class="sourceLineNo">965</span><a id="line.965">                &amp;&amp; (value[n] == null ? v == null : value[n].equals(v)))</a>
<span class="sourceLineNo">966</span><a id="line.966">            return true;</a>
<span class="sourceLineNo">967</span><a id="line.967">        for (int i = n; i-- != 0;)</a>
<span class="sourceLineNo">968</span><a id="line.968">            if (key[i] != null</a>
<span class="sourceLineNo">969</span><a id="line.969">                    &amp;&amp; (value[i] == null ? v == null : value[i].equals(v)))</a>
<span class="sourceLineNo">970</span><a id="line.970">                return true;</a>
<span class="sourceLineNo">971</span><a id="line.971">        return false;</a>
<span class="sourceLineNo">972</span><a id="line.972">    }</a>
<span class="sourceLineNo">973</span><a id="line.973">    /*</a>
<span class="sourceLineNo">974</span><a id="line.974">     * Removes all elements from this map.</a>
<span class="sourceLineNo">975</span><a id="line.975">     *</a>
<span class="sourceLineNo">976</span><a id="line.976">     * &lt;P&gt;To increase object reuse, this method does not change the table size.</a>
<span class="sourceLineNo">977</span><a id="line.977">     * If you want to reduce the table size, you must use {@link #trim()}.</a>
<span class="sourceLineNo">978</span><a id="line.978">     */</a>
<span class="sourceLineNo">979</span><a id="line.979">    public void clear() {</a>
<span class="sourceLineNo">980</span><a id="line.980">        if (size == 0)</a>
<span class="sourceLineNo">981</span><a id="line.981">            return;</a>
<span class="sourceLineNo">982</span><a id="line.982">        size = 0;</a>
<span class="sourceLineNo">983</span><a id="line.983">        containsNullKey = false;</a>
<span class="sourceLineNo">984</span><a id="line.984">        Arrays.fill(key, null);</a>
<span class="sourceLineNo">985</span><a id="line.985">        Arrays.fill(value, null);</a>
<span class="sourceLineNo">986</span><a id="line.986">        order.clear();</a>
<span class="sourceLineNo">987</span><a id="line.987">    }</a>
<span class="sourceLineNo">988</span><a id="line.988"></a>
<span class="sourceLineNo">989</span><a id="line.989">    public int size() {</a>
<span class="sourceLineNo">990</span><a id="line.990">        return size;</a>
<span class="sourceLineNo">991</span><a id="line.991">    }</a>
<span class="sourceLineNo">992</span><a id="line.992"></a>
<span class="sourceLineNo">993</span><a id="line.993">    public boolean isEmpty() {</a>
<span class="sourceLineNo">994</span><a id="line.994">        return size == 0;</a>
<span class="sourceLineNo">995</span><a id="line.995">    }</a>
<span class="sourceLineNo">996</span><a id="line.996"></a>
<span class="sourceLineNo">997</span><a id="line.997">    /**</a>
<span class="sourceLineNo">998</span><a id="line.998">     * The entry class for a OrderedMap does not record key and value, but rather the position in the hash table of the corresponding entry. This is necessary so that calls to</a>
<span class="sourceLineNo">999</span><a id="line.999">     * {@link Entry#setValue(Object)} are reflected in the map</a>
<span class="sourceLineNo">1000</span><a id="line.1000">     */</a>
<span class="sourceLineNo">1001</span><a id="line.1001">    final class MapEntry</a>
<span class="sourceLineNo">1002</span><a id="line.1002">            implements</a>
<span class="sourceLineNo">1003</span><a id="line.1003">            Entry&lt;K, V&gt; {</a>
<span class="sourceLineNo">1004</span><a id="line.1004">        // The table index this entry refers to, or -1 if this entry has been</a>
<span class="sourceLineNo">1005</span><a id="line.1005">        // deleted.</a>
<span class="sourceLineNo">1006</span><a id="line.1006">        int index;</a>
<span class="sourceLineNo">1007</span><a id="line.1007">        MapEntry(final int index) {</a>
<span class="sourceLineNo">1008</span><a id="line.1008">            this.index = index;</a>
<span class="sourceLineNo">1009</span><a id="line.1009">        }</a>
<span class="sourceLineNo">1010</span><a id="line.1010">        MapEntry() {</a>
<span class="sourceLineNo">1011</span><a id="line.1011">        }</a>
<span class="sourceLineNo">1012</span><a id="line.1012">        public K getKey() {</a>
<span class="sourceLineNo">1013</span><a id="line.1013">            return key[index];</a>
<span class="sourceLineNo">1014</span><a id="line.1014">        }</a>
<span class="sourceLineNo">1015</span><a id="line.1015">        public V getValue() {</a>
<span class="sourceLineNo">1016</span><a id="line.1016">            return value[index];</a>
<span class="sourceLineNo">1017</span><a id="line.1017">        }</a>
<span class="sourceLineNo">1018</span><a id="line.1018">        public V setValue(final V v) {</a>
<span class="sourceLineNo">1019</span><a id="line.1019">            final V oldValue = value[index];</a>
<span class="sourceLineNo">1020</span><a id="line.1020">            value[index] = v;</a>
<span class="sourceLineNo">1021</span><a id="line.1021">            return oldValue;</a>
<span class="sourceLineNo">1022</span><a id="line.1022">        }</a>
<span class="sourceLineNo">1023</span><a id="line.1023">        @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">1024</span><a id="line.1024">        public boolean equals(final Object o) {</a>
<span class="sourceLineNo">1025</span><a id="line.1025">            if (!(o instanceof Map.Entry))</a>
<span class="sourceLineNo">1026</span><a id="line.1026">                return false;</a>
<span class="sourceLineNo">1027</span><a id="line.1027">            Map.Entry&lt;K, V&gt; e = (Map.Entry&lt;K, V&gt;) o;</a>
<span class="sourceLineNo">1028</span><a id="line.1028">            return (key[index] == null</a>
<span class="sourceLineNo">1029</span><a id="line.1029">                    ? e.getKey() == null</a>
<span class="sourceLineNo">1030</span><a id="line.1030">                    : hasher.areEqual(key[index], e.getKey()))</a>
<span class="sourceLineNo">1031</span><a id="line.1031">                    &amp;&amp; (value[index] == null</a>
<span class="sourceLineNo">1032</span><a id="line.1032">                    ? e.getValue() == null</a>
<span class="sourceLineNo">1033</span><a id="line.1033">                    : value[index].equals(e.getValue()));</a>
<span class="sourceLineNo">1034</span><a id="line.1034">        }</a>
<span class="sourceLineNo">1035</span><a id="line.1035">        public int hashCode() {</a>
<span class="sourceLineNo">1036</span><a id="line.1036">            return hasher.hash(key[index])</a>
<span class="sourceLineNo">1037</span><a id="line.1037">                    ^ (value[index] == null ? 0 : value[index].hashCode());</a>
<span class="sourceLineNo">1038</span><a id="line.1038">        }</a>
<span class="sourceLineNo">1039</span><a id="line.1039">        @Override</a>
<span class="sourceLineNo">1040</span><a id="line.1040">        public String toString() {</a>
<span class="sourceLineNo">1041</span><a id="line.1041">            return (key[index] == OrderedMap.this ? "(this collection)" : String.valueOf(key[index]))</a>
<span class="sourceLineNo">1042</span><a id="line.1042">                    + "=&gt;"</a>
<span class="sourceLineNo">1043</span><a id="line.1043">                    + (value[index] == OrderedMap.this ? "(this collection)" : String.valueOf(value[index]));</a>
<span class="sourceLineNo">1044</span><a id="line.1044">        }</a>
<span class="sourceLineNo">1045</span><a id="line.1045">    }</a>
<span class="sourceLineNo">1046</span><a id="line.1046"></a>
<span class="sourceLineNo">1047</span><a id="line.1047">    /**</a>
<span class="sourceLineNo">1048</span><a id="line.1048">     * Modifies the ordering so that the given entry is removed. This method will complete in linear time.</a>
<span class="sourceLineNo">1049</span><a id="line.1049">     *</a>
<span class="sourceLineNo">1050</span><a id="line.1050">     * @param i the index of an entry.</a>
<span class="sourceLineNo">1051</span><a id="line.1051">     * @return the iteration-order index of the removed entry</a>
<span class="sourceLineNo">1052</span><a id="line.1052">     */</a>
<span class="sourceLineNo">1053</span><a id="line.1053">    protected int fixOrder(final int i) {</a>
<span class="sourceLineNo">1054</span><a id="line.1054">        if (size == 0) {</a>
<span class="sourceLineNo">1055</span><a id="line.1055">            order.clear();</a>
<span class="sourceLineNo">1056</span><a id="line.1056">            return -1;</a>
<span class="sourceLineNo">1057</span><a id="line.1057">        }</a>
<span class="sourceLineNo">1058</span><a id="line.1058">        return order.removeValue(i);</a>
<span class="sourceLineNo">1059</span><a id="line.1059">    }</a>
<span class="sourceLineNo">1060</span><a id="line.1060"></a>
<span class="sourceLineNo">1061</span><a id="line.1061">    /**</a>
<span class="sourceLineNo">1062</span><a id="line.1062">     * Modifies the ordering for a shift from s to d.</a>
<span class="sourceLineNo">1063</span><a id="line.1063">     * &lt;br&gt;</a>
<span class="sourceLineNo">1064</span><a id="line.1064">     * This method will complete in linear time unless the source position is first or last.</a>
<span class="sourceLineNo">1065</span><a id="line.1065">     *</a>
<span class="sourceLineNo">1066</span><a id="line.1066">     * @param s the source position.</a>
<span class="sourceLineNo">1067</span><a id="line.1067">     * @param d the destination position.</a>
<span class="sourceLineNo">1068</span><a id="line.1068">     */</a>
<span class="sourceLineNo">1069</span><a id="line.1069">    protected void fixOrder(int s, int d) {</a>
<span class="sourceLineNo">1070</span><a id="line.1070">        if(size == 0)</a>
<span class="sourceLineNo">1071</span><a id="line.1071">            return;</a>
<span class="sourceLineNo">1072</span><a id="line.1072">        if (size == 1 || order.items[0] == s) {</a>
<span class="sourceLineNo">1073</span><a id="line.1073">            order.set(0, d);</a>
<span class="sourceLineNo">1074</span><a id="line.1074">        }</a>
<span class="sourceLineNo">1075</span><a id="line.1075">        else if (order.items[order.size-1] == s) {</a>
<span class="sourceLineNo">1076</span><a id="line.1076">            order.set(order.size - 1, d);</a>
<span class="sourceLineNo">1077</span><a id="line.1077">        }</a>
<span class="sourceLineNo">1078</span><a id="line.1078">        else</a>
<span class="sourceLineNo">1079</span><a id="line.1079">        {</a>
<span class="sourceLineNo">1080</span><a id="line.1080">            order.set(order.indexOf(s), d);</a>
<span class="sourceLineNo">1081</span><a id="line.1081">        }</a>
<span class="sourceLineNo">1082</span><a id="line.1082">    }</a>
<span class="sourceLineNo">1083</span><a id="line.1083"></a>
<span class="sourceLineNo">1084</span><a id="line.1084">    /**</a>
<span class="sourceLineNo">1085</span><a id="line.1085">     * Returns the first key of this map in iteration order.</a>
<span class="sourceLineNo">1086</span><a id="line.1086">     *</a>
<span class="sourceLineNo">1087</span><a id="line.1087">     * @return the first key in iteration order.</a>
<span class="sourceLineNo">1088</span><a id="line.1088">     */</a>
<span class="sourceLineNo">1089</span><a id="line.1089">    public K firstKey() {</a>
<span class="sourceLineNo">1090</span><a id="line.1090">        if (size == 0)</a>
<span class="sourceLineNo">1091</span><a id="line.1091">            throw new NoSuchElementException();</a>
<span class="sourceLineNo">1092</span><a id="line.1092">        return key[order.items[0]];</a>
<span class="sourceLineNo">1093</span><a id="line.1093">    }</a>
<span class="sourceLineNo">1094</span><a id="line.1094">    /**</a>
<span class="sourceLineNo">1095</span><a id="line.1095">     * Returns the last key of this map in iteration order.</a>
<span class="sourceLineNo">1096</span><a id="line.1096">     *</a>
<span class="sourceLineNo">1097</span><a id="line.1097">     * @return the last key in iteration order.</a>
<span class="sourceLineNo">1098</span><a id="line.1098">     */</a>
<span class="sourceLineNo">1099</span><a id="line.1099">    public K lastKey() {</a>
<span class="sourceLineNo">1100</span><a id="line.1100">        if (size == 0)</a>
<span class="sourceLineNo">1101</span><a id="line.1101">            throw new NoSuchElementException();</a>
<span class="sourceLineNo">1102</span><a id="line.1102">        return key[order.items[order.size-1]];</a>
<span class="sourceLineNo">1103</span><a id="line.1103">    }</a>
<span class="sourceLineNo">1104</span><a id="line.1104">    public Comparator&lt;? super K&gt; comparator() {</a>
<span class="sourceLineNo">1105</span><a id="line.1105">        return null;</a>
<span class="sourceLineNo">1106</span><a id="line.1106">    }</a>
<span class="sourceLineNo">1107</span><a id="line.1107">    public SortedMap&lt;K, V&gt; tailMap(K from) {</a>
<span class="sourceLineNo">1108</span><a id="line.1108">        throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1109</span><a id="line.1109">    }</a>
<span class="sourceLineNo">1110</span><a id="line.1110">    public SortedMap&lt;K, V&gt; headMap(K to) {</a>
<span class="sourceLineNo">1111</span><a id="line.1111">        throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1112</span><a id="line.1112">    }</a>
<span class="sourceLineNo">1113</span><a id="line.1113">    public SortedMap&lt;K, V&gt; subMap(K from, K to) {</a>
<span class="sourceLineNo">1114</span><a id="line.1114">        throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1115</span><a id="line.1115">    }</a>
<span class="sourceLineNo">1116</span><a id="line.1116">    /**</a>
<span class="sourceLineNo">1117</span><a id="line.1117">     * A list iterator over a OrderedMap.</a>
<span class="sourceLineNo">1118</span><a id="line.1118">     *</a>
<span class="sourceLineNo">1119</span><a id="line.1119">     * &lt;P&gt;</a>
<span class="sourceLineNo">1120</span><a id="line.1120">     * This class provides a list iterator over a OrderedMap. The</a>
<span class="sourceLineNo">1121</span><a id="line.1121">     * constructor runs in constant time.</a>
<span class="sourceLineNo">1122</span><a id="line.1122">     */</a>
<span class="sourceLineNo">1123</span><a id="line.1123">    private class MapIterator {</a>
<span class="sourceLineNo">1124</span><a id="line.1124">        /**</a>
<span class="sourceLineNo">1125</span><a id="line.1125">         * The entry that will be returned by the next call to</a>
<span class="sourceLineNo">1126</span><a id="line.1126">         * {@link java.util.ListIterator#previous()} (or &lt;code&gt;null&lt;/code&gt; if no</a>
<span class="sourceLineNo">1127</span><a id="line.1127">         * previous entry exists).</a>
<span class="sourceLineNo">1128</span><a id="line.1128">         */</a>
<span class="sourceLineNo">1129</span><a id="line.1129">        int prev = -1;</a>
<span class="sourceLineNo">1130</span><a id="line.1130">        /**</a>
<span class="sourceLineNo">1131</span><a id="line.1131">         * The entry that will be returned by the next call to</a>
<span class="sourceLineNo">1132</span><a id="line.1132">         * {@link java.util.ListIterator#next()} (or &lt;code&gt;null&lt;/code&gt; if no</a>
<span class="sourceLineNo">1133</span><a id="line.1133">         * next entry exists).</a>
<span class="sourceLineNo">1134</span><a id="line.1134">         */</a>
<span class="sourceLineNo">1135</span><a id="line.1135">        int next;</a>
<span class="sourceLineNo">1136</span><a id="line.1136">        /**</a>
<span class="sourceLineNo">1137</span><a id="line.1137">         * The last entry that was returned (or -1 if we did not iterate or used</a>
<span class="sourceLineNo">1138</span><a id="line.1138">         * {@link java.util.Iterator#remove()}).</a>
<span class="sourceLineNo">1139</span><a id="line.1139">         */</a>
<span class="sourceLineNo">1140</span><a id="line.1140">        int curr = -1;</a>
<span class="sourceLineNo">1141</span><a id="line.1141">        /**</a>
<span class="sourceLineNo">1142</span><a id="line.1142">         * The current index (in the sense of a {@link java.util.ListIterator}).</a>
<span class="sourceLineNo">1143</span><a id="line.1143">         * Note that this value is not meaningful when this iterator has been</a>
<span class="sourceLineNo">1144</span><a id="line.1144">         * created using the nonempty constructor.</a>
<span class="sourceLineNo">1145</span><a id="line.1145">         */</a>
<span class="sourceLineNo">1146</span><a id="line.1146">        int index;</a>
<span class="sourceLineNo">1147</span><a id="line.1147">        private MapIterator() {</a>
<span class="sourceLineNo">1148</span><a id="line.1148">            next = size == 0 ? -1 : order.items[0];</a>
<span class="sourceLineNo">1149</span><a id="line.1149">            index = 0;</a>
<span class="sourceLineNo">1150</span><a id="line.1150">        }</a>
<span class="sourceLineNo">1151</span><a id="line.1151">        public boolean hasNext() {</a>
<span class="sourceLineNo">1152</span><a id="line.1152">            return next != -1;</a>
<span class="sourceLineNo">1153</span><a id="line.1153">        }</a>
<span class="sourceLineNo">1154</span><a id="line.1154">        public boolean hasPrevious() {</a>
<span class="sourceLineNo">1155</span><a id="line.1155">            return prev != -1;</a>
<span class="sourceLineNo">1156</span><a id="line.1156">        }</a>
<span class="sourceLineNo">1157</span><a id="line.1157">        private void ensureIndexKnown() {</a>
<span class="sourceLineNo">1158</span><a id="line.1158">            if (index &gt;= 0)</a>
<span class="sourceLineNo">1159</span><a id="line.1159">                return;</a>
<span class="sourceLineNo">1160</span><a id="line.1160">            if (prev == -1) {</a>
<span class="sourceLineNo">1161</span><a id="line.1161">                index = 0;</a>
<span class="sourceLineNo">1162</span><a id="line.1162">                return;</a>
<span class="sourceLineNo">1163</span><a id="line.1163">            }</a>
<span class="sourceLineNo">1164</span><a id="line.1164">            if (next == -1) {</a>
<span class="sourceLineNo">1165</span><a id="line.1165">                index = size;</a>
<span class="sourceLineNo">1166</span><a id="line.1166">                return;</a>
<span class="sourceLineNo">1167</span><a id="line.1167">            }</a>
<span class="sourceLineNo">1168</span><a id="line.1168">            index = 0;</a>
<span class="sourceLineNo">1169</span><a id="line.1169">        }</a>
<span class="sourceLineNo">1170</span><a id="line.1170">        public int nextIndex() {</a>
<span class="sourceLineNo">1171</span><a id="line.1171">            ensureIndexKnown();</a>
<span class="sourceLineNo">1172</span><a id="line.1172">            return index + 1;</a>
<span class="sourceLineNo">1173</span><a id="line.1173">        }</a>
<span class="sourceLineNo">1174</span><a id="line.1174">        public int previousIndex() {</a>
<span class="sourceLineNo">1175</span><a id="line.1175">            ensureIndexKnown();</a>
<span class="sourceLineNo">1176</span><a id="line.1176">            return index - 1;</a>
<span class="sourceLineNo">1177</span><a id="line.1177">        }</a>
<span class="sourceLineNo">1178</span><a id="line.1178">        public int nextEntry() {</a>
<span class="sourceLineNo">1179</span><a id="line.1179">            if (!hasNext())</a>
<span class="sourceLineNo">1180</span><a id="line.1180">                throw new NoSuchElementException();</a>
<span class="sourceLineNo">1181</span><a id="line.1181">            curr = next;</a>
<span class="sourceLineNo">1182</span><a id="line.1182">            if(++index &gt;= order.size)</a>
<span class="sourceLineNo">1183</span><a id="line.1183">                next = -1;</a>
<span class="sourceLineNo">1184</span><a id="line.1184">            else</a>
<span class="sourceLineNo">1185</span><a id="line.1185">                next = order.get(index);//(int) link[curr];</a>
<span class="sourceLineNo">1186</span><a id="line.1186">            prev = curr;</a>
<span class="sourceLineNo">1187</span><a id="line.1187">            return curr;</a>
<span class="sourceLineNo">1188</span><a id="line.1188">        }</a>
<span class="sourceLineNo">1189</span><a id="line.1189">        public int previousEntry() {</a>
<span class="sourceLineNo">1190</span><a id="line.1190">            if (!hasPrevious())</a>
<span class="sourceLineNo">1191</span><a id="line.1191">                throw new NoSuchElementException();</a>
<span class="sourceLineNo">1192</span><a id="line.1192">            curr = prev;</a>
<span class="sourceLineNo">1193</span><a id="line.1193">            if(--index &lt; 1)</a>
<span class="sourceLineNo">1194</span><a id="line.1194">                prev = -1;</a>
<span class="sourceLineNo">1195</span><a id="line.1195">            else</a>
<span class="sourceLineNo">1196</span><a id="line.1196">                prev = order.get(index - 1);</a>
<span class="sourceLineNo">1197</span><a id="line.1197">            next = curr;</a>
<span class="sourceLineNo">1198</span><a id="line.1198">            return curr;</a>
<span class="sourceLineNo">1199</span><a id="line.1199">        }</a>
<span class="sourceLineNo">1200</span><a id="line.1200">        public void remove() {</a>
<span class="sourceLineNo">1201</span><a id="line.1201">            ensureIndexKnown();</a>
<span class="sourceLineNo">1202</span><a id="line.1202">            if (curr == -1)</a>
<span class="sourceLineNo">1203</span><a id="line.1203">                throw new IllegalStateException();</a>
<span class="sourceLineNo">1204</span><a id="line.1204">            if (curr == prev) {</a>
<span class="sourceLineNo">1205</span><a id="line.1205">                /*</a>
<span class="sourceLineNo">1206</span><a id="line.1206">                 * If the last operation was a next(), we are removing an entry</a>
<span class="sourceLineNo">1207</span><a id="line.1207">                 * that precedes the current index, and thus we must decrement</a>
<span class="sourceLineNo">1208</span><a id="line.1208">                 * it.</a>
<span class="sourceLineNo">1209</span><a id="line.1209">                 */</a>
<span class="sourceLineNo">1210</span><a id="line.1210">                if(--index &gt;= 1)</a>
<span class="sourceLineNo">1211</span><a id="line.1211">                    prev = order.get(index - 1); //(int) (link[curr] &gt;&gt;&gt; 32);</a>
<span class="sourceLineNo">1212</span><a id="line.1212">                else</a>
<span class="sourceLineNo">1213</span><a id="line.1213">                    prev = -1;</a>
<span class="sourceLineNo">1214</span><a id="line.1214">            } else {</a>
<span class="sourceLineNo">1215</span><a id="line.1215">                if(index &lt; order.size - 1)</a>
<span class="sourceLineNo">1216</span><a id="line.1216">                    next = order.get(index + 1);</a>
<span class="sourceLineNo">1217</span><a id="line.1217">                else</a>
<span class="sourceLineNo">1218</span><a id="line.1218">                    next = -1;</a>
<span class="sourceLineNo">1219</span><a id="line.1219">            }</a>
<span class="sourceLineNo">1220</span><a id="line.1220">            order.removeIndex(index);</a>
<span class="sourceLineNo">1221</span><a id="line.1221">            size--;</a>
<span class="sourceLineNo">1222</span><a id="line.1222">            int last, slot, pos = curr;</a>
<span class="sourceLineNo">1223</span><a id="line.1223">            curr = -1;</a>
<span class="sourceLineNo">1224</span><a id="line.1224">            if (pos == n) {</a>
<span class="sourceLineNo">1225</span><a id="line.1225">                containsNullKey = false;</a>
<span class="sourceLineNo">1226</span><a id="line.1226">                key[n] = null;</a>
<span class="sourceLineNo">1227</span><a id="line.1227">                value[n] = null;</a>
<span class="sourceLineNo">1228</span><a id="line.1228">            } else {</a>
<span class="sourceLineNo">1229</span><a id="line.1229">                K curr;</a>
<span class="sourceLineNo">1230</span><a id="line.1230">                final K[] key = OrderedMap.this.key;</a>
<span class="sourceLineNo">1231</span><a id="line.1231">                // We have to horribly duplicate the shiftKeys() code because we</a>
<span class="sourceLineNo">1232</span><a id="line.1232">                // need to update next/prev.</a>
<span class="sourceLineNo">1233</span><a id="line.1233">                for (;;) {</a>
<span class="sourceLineNo">1234</span><a id="line.1234">                    pos = ((last = pos) + 1) &amp; mask;</a>
<span class="sourceLineNo">1235</span><a id="line.1235">                    for (;;) {</a>
<span class="sourceLineNo">1236</span><a id="line.1236">                        if ((curr = key[pos]) == null) {</a>
<span class="sourceLineNo">1237</span><a id="line.1237">                            key[last] = null;</a>
<span class="sourceLineNo">1238</span><a id="line.1238">                            value[last] = null;</a>
<span class="sourceLineNo">1239</span><a id="line.1239">                            return;</a>
<span class="sourceLineNo">1240</span><a id="line.1240">                        }</a>
<span class="sourceLineNo">1241</span><a id="line.1241">                        slot = (hasher.hash(curr)) &amp; mask;</a>
<span class="sourceLineNo">1242</span><a id="line.1242">                        if (last &lt;= pos</a>
<span class="sourceLineNo">1243</span><a id="line.1243">                                ? last &gt;= slot || slot &gt; pos</a>
<span class="sourceLineNo">1244</span><a id="line.1244">                                : last &gt;= slot &amp;&amp; slot &gt; pos)</a>
<span class="sourceLineNo">1245</span><a id="line.1245">                            break;</a>
<span class="sourceLineNo">1246</span><a id="line.1246">                        pos = (pos + 1) &amp; mask;</a>
<span class="sourceLineNo">1247</span><a id="line.1247">                    }</a>
<span class="sourceLineNo">1248</span><a id="line.1248">                    key[last] = curr;</a>
<span class="sourceLineNo">1249</span><a id="line.1249">                    value[last] = value[pos];</a>
<span class="sourceLineNo">1250</span><a id="line.1250">                    if (next == pos)</a>
<span class="sourceLineNo">1251</span><a id="line.1251">                        next = last;</a>
<span class="sourceLineNo">1252</span><a id="line.1252">                    if (prev == pos)</a>
<span class="sourceLineNo">1253</span><a id="line.1253">                        prev = last;</a>
<span class="sourceLineNo">1254</span><a id="line.1254">                    fixOrder(pos, last);</a>
<span class="sourceLineNo">1255</span><a id="line.1255">                }</a>
<span class="sourceLineNo">1256</span><a id="line.1256">            }</a>
<span class="sourceLineNo">1257</span><a id="line.1257">        }</a>
<span class="sourceLineNo">1258</span><a id="line.1258">        public int skip(final int n) {</a>
<span class="sourceLineNo">1259</span><a id="line.1259">            int i = n;</a>
<span class="sourceLineNo">1260</span><a id="line.1260">            while (i-- != 0 &amp;&amp; hasNext())</a>
<span class="sourceLineNo">1261</span><a id="line.1261">                nextEntry();</a>
<span class="sourceLineNo">1262</span><a id="line.1262">            return n - i - 1;</a>
<span class="sourceLineNo">1263</span><a id="line.1263">        }</a>
<span class="sourceLineNo">1264</span><a id="line.1264">        public int back(final int n) {</a>
<span class="sourceLineNo">1265</span><a id="line.1265">            int i = n;</a>
<span class="sourceLineNo">1266</span><a id="line.1266">            while (i-- != 0 &amp;&amp; hasPrevious())</a>
<span class="sourceLineNo">1267</span><a id="line.1267">                previousEntry();</a>
<span class="sourceLineNo">1268</span><a id="line.1268">            return n - i - 1;</a>
<span class="sourceLineNo">1269</span><a id="line.1269">        }</a>
<span class="sourceLineNo">1270</span><a id="line.1270">    }</a>
<span class="sourceLineNo">1271</span><a id="line.1271">    private class EntryIterator extends MapIterator</a>
<span class="sourceLineNo">1272</span><a id="line.1272">            implements</a>
<span class="sourceLineNo">1273</span><a id="line.1273">            Iterator&lt;Entry&lt;K, V&gt;&gt;, Serializable {</a>
<span class="sourceLineNo">1274</span><a id="line.1274">        private static final long serialVersionUID = 0L;</a>
<span class="sourceLineNo">1275</span><a id="line.1275"></a>
<span class="sourceLineNo">1276</span><a id="line.1276">        private MapEntry entry;</a>
<span class="sourceLineNo">1277</span><a id="line.1277">        public EntryIterator() {</a>
<span class="sourceLineNo">1278</span><a id="line.1278">        }</a>
<span class="sourceLineNo">1279</span><a id="line.1279">        public MapEntry next() {</a>
<span class="sourceLineNo">1280</span><a id="line.1280">            return entry = new MapEntry(nextEntry());</a>
<span class="sourceLineNo">1281</span><a id="line.1281">        }</a>
<span class="sourceLineNo">1282</span><a id="line.1282">        public MapEntry previous() {</a>
<span class="sourceLineNo">1283</span><a id="line.1283">            return entry = new MapEntry(previousEntry());</a>
<span class="sourceLineNo">1284</span><a id="line.1284">        }</a>
<span class="sourceLineNo">1285</span><a id="line.1285">        @Override</a>
<span class="sourceLineNo">1286</span><a id="line.1286">        public void remove() {</a>
<span class="sourceLineNo">1287</span><a id="line.1287">            super.remove();</a>
<span class="sourceLineNo">1288</span><a id="line.1288">            entry.index = -1; // You cannot use a deleted entry.</a>
<span class="sourceLineNo">1289</span><a id="line.1289">        }</a>
<span class="sourceLineNo">1290</span><a id="line.1290">        public void set(Entry&lt;K, V&gt; ok) {</a>
<span class="sourceLineNo">1291</span><a id="line.1291">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1292</span><a id="line.1292">        }</a>
<span class="sourceLineNo">1293</span><a id="line.1293">        public void add(Entry&lt;K, V&gt; ok) {</a>
<span class="sourceLineNo">1294</span><a id="line.1294">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1295</span><a id="line.1295">        }</a>
<span class="sourceLineNo">1296</span><a id="line.1296">    }</a>
<span class="sourceLineNo">1297</span><a id="line.1297"></a>
<span class="sourceLineNo">1298</span><a id="line.1298">    public final class MapEntrySet</a>
<span class="sourceLineNo">1299</span><a id="line.1299">            implements Cloneable, SortedSet&lt;Entry&lt;K, V&gt;&gt;, Set&lt;Entry&lt;K, V&gt;&gt;, Collection&lt;Entry&lt;K, V&gt;&gt;, Serializable {</a>
<span class="sourceLineNo">1300</span><a id="line.1300">        private static final long serialVersionUID = 0L;</a>
<span class="sourceLineNo">1301</span><a id="line.1301">        public EntryIterator iterator() {</a>
<span class="sourceLineNo">1302</span><a id="line.1302">            return new EntryIterator();</a>
<span class="sourceLineNo">1303</span><a id="line.1303">        }</a>
<span class="sourceLineNo">1304</span><a id="line.1304">        public Comparator&lt;? super Entry&lt;K, V&gt;&gt; comparator() {</a>
<span class="sourceLineNo">1305</span><a id="line.1305">            return null;</a>
<span class="sourceLineNo">1306</span><a id="line.1306">        }</a>
<span class="sourceLineNo">1307</span><a id="line.1307">        public SortedSet&lt;Entry&lt;K, V&gt;&gt; subSet(</a>
<span class="sourceLineNo">1308</span><a id="line.1308">                Entry&lt;K, V&gt; fromElement,</a>
<span class="sourceLineNo">1309</span><a id="line.1309">                Entry&lt;K, V&gt; toElement) {</a>
<span class="sourceLineNo">1310</span><a id="line.1310">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1311</span><a id="line.1311">        }</a>
<span class="sourceLineNo">1312</span><a id="line.1312">        public SortedSet&lt;Entry&lt;K, V&gt;&gt; headSet(</a>
<span class="sourceLineNo">1313</span><a id="line.1313">                Entry&lt;K, V&gt; toElement) {</a>
<span class="sourceLineNo">1314</span><a id="line.1314">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1315</span><a id="line.1315">        }</a>
<span class="sourceLineNo">1316</span><a id="line.1316">        public SortedSet&lt;Entry&lt;K, V&gt;&gt; tailSet(</a>
<span class="sourceLineNo">1317</span><a id="line.1317">                Entry&lt;K, V&gt; fromElement) {</a>
<span class="sourceLineNo">1318</span><a id="line.1318">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1319</span><a id="line.1319">        }</a>
<span class="sourceLineNo">1320</span><a id="line.1320">        public Entry&lt;K, V&gt; first() {</a>
<span class="sourceLineNo">1321</span><a id="line.1321">            if (size == 0)</a>
<span class="sourceLineNo">1322</span><a id="line.1322">                throw new NoSuchElementException();</a>
<span class="sourceLineNo">1323</span><a id="line.1323">            return new MapEntry(order.items[0]);</a>
<span class="sourceLineNo">1324</span><a id="line.1324">        }</a>
<span class="sourceLineNo">1325</span><a id="line.1325">        public Entry&lt;K, V&gt; last() {</a>
<span class="sourceLineNo">1326</span><a id="line.1326">            if (size == 0)</a>
<span class="sourceLineNo">1327</span><a id="line.1327">                throw new NoSuchElementException();</a>
<span class="sourceLineNo">1328</span><a id="line.1328">            return new MapEntry(order.items[order.size-1]);</a>
<span class="sourceLineNo">1329</span><a id="line.1329">        }</a>
<span class="sourceLineNo">1330</span><a id="line.1330">        @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">1331</span><a id="line.1331">        public boolean contains(final Object o) {</a>
<span class="sourceLineNo">1332</span><a id="line.1332">            if (!(o instanceof Map.Entry))</a>
<span class="sourceLineNo">1333</span><a id="line.1333">                return false;</a>
<span class="sourceLineNo">1334</span><a id="line.1334">            final Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</a>
<span class="sourceLineNo">1335</span><a id="line.1335">            final K k = (K) e.getKey();</a>
<span class="sourceLineNo">1336</span><a id="line.1336">            final V v = (V) e.getValue();</a>
<span class="sourceLineNo">1337</span><a id="line.1337">            if (k == null)</a>
<span class="sourceLineNo">1338</span><a id="line.1338">                return containsNullKey</a>
<span class="sourceLineNo">1339</span><a id="line.1339">                        &amp;&amp; (value[n] == null ? v == null : value[n]</a>
<span class="sourceLineNo">1340</span><a id="line.1340">                        .equals(v));</a>
<span class="sourceLineNo">1341</span><a id="line.1341">            K curr;</a>
<span class="sourceLineNo">1342</span><a id="line.1342">            final K[] key = OrderedMap.this.key;</a>
<span class="sourceLineNo">1343</span><a id="line.1343">            int pos;</a>
<span class="sourceLineNo">1344</span><a id="line.1344">            // The starting point.</a>
<span class="sourceLineNo">1345</span><a id="line.1345">            if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</a>
<span class="sourceLineNo">1346</span><a id="line.1346">                return false;</a>
<span class="sourceLineNo">1347</span><a id="line.1347">            if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">1348</span><a id="line.1348">                return value[pos] == null ? v == null : value[pos]</a>
<span class="sourceLineNo">1349</span><a id="line.1349">                        .equals(v);</a>
<span class="sourceLineNo">1350</span><a id="line.1350">            // There's always an unused entry.</a>
<span class="sourceLineNo">1351</span><a id="line.1351">            while (true) {</a>
<span class="sourceLineNo">1352</span><a id="line.1352">                if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</a>
<span class="sourceLineNo">1353</span><a id="line.1353">                    return false;</a>
<span class="sourceLineNo">1354</span><a id="line.1354">                if (hasher.areEqual(k, curr))</a>
<span class="sourceLineNo">1355</span><a id="line.1355">                    return value[pos] == null ? v == null : value[pos]</a>
<span class="sourceLineNo">1356</span><a id="line.1356">                            .equals(v);</a>
<span class="sourceLineNo">1357</span><a id="line.1357">            }</a>
<span class="sourceLineNo">1358</span><a id="line.1358">        }</a>
<span class="sourceLineNo">1359</span><a id="line.1359">        @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">1360</span><a id="line.1360">        public boolean remove(final Object o) {</a>
<span class="sourceLineNo">1361</span><a id="line.1361">            if (!(o instanceof Map.Entry))</a>
<span class="sourceLineNo">1362</span><a id="line.1362">                return false;</a>
<span class="sourceLineNo">1363</span><a id="line.1363">            final Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</a>
<span class="sourceLineNo">1364</span><a id="line.1364">            final K k = (K) e.getKey();</a>
<span class="sourceLineNo">1365</span><a id="line.1365">            final V v = (V) e.getValue();</a>
<span class="sourceLineNo">1366</span><a id="line.1366">            if (k == null) {</a>
<span class="sourceLineNo">1367</span><a id="line.1367">                if (containsNullKey</a>
<span class="sourceLineNo">1368</span><a id="line.1368">                        &amp;&amp; (value[n] == null ? v == null : value[n]</a>
<span class="sourceLineNo">1369</span><a id="line.1369">                        .equals(v))) {</a>
<span class="sourceLineNo">1370</span><a id="line.1370">                    removeNullEntry();</a>
<span class="sourceLineNo">1371</span><a id="line.1371">                    return true;</a>
<span class="sourceLineNo">1372</span><a id="line.1372">                }</a>
<span class="sourceLineNo">1373</span><a id="line.1373">                return false;</a>
<span class="sourceLineNo">1374</span><a id="line.1374">            }</a>
<span class="sourceLineNo">1375</span><a id="line.1375">            K curr;</a>
<span class="sourceLineNo">1376</span><a id="line.1376">            final K[] key = OrderedMap.this.key;</a>
<span class="sourceLineNo">1377</span><a id="line.1377">            int pos;</a>
<span class="sourceLineNo">1378</span><a id="line.1378">            // The starting point.</a>
<span class="sourceLineNo">1379</span><a id="line.1379">            if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)</a>
<span class="sourceLineNo">1380</span><a id="line.1380">                return false;</a>
<span class="sourceLineNo">1381</span><a id="line.1381">            if (hasher.areEqual(curr, k)) {</a>
<span class="sourceLineNo">1382</span><a id="line.1382">                if (value[pos] == null ? v == null : value[pos]</a>
<span class="sourceLineNo">1383</span><a id="line.1383">                        .equals(v)) {</a>
<span class="sourceLineNo">1384</span><a id="line.1384">                    removeEntry(pos);</a>
<span class="sourceLineNo">1385</span><a id="line.1385">                    return true;</a>
<span class="sourceLineNo">1386</span><a id="line.1386">                }</a>
<span class="sourceLineNo">1387</span><a id="line.1387">                return false;</a>
<span class="sourceLineNo">1388</span><a id="line.1388">            }</a>
<span class="sourceLineNo">1389</span><a id="line.1389">            while (true) {</a>
<span class="sourceLineNo">1390</span><a id="line.1390">                if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</a>
<span class="sourceLineNo">1391</span><a id="line.1391">                    return false;</a>
<span class="sourceLineNo">1392</span><a id="line.1392">                if (hasher.areEqual(curr, k)) {</a>
<span class="sourceLineNo">1393</span><a id="line.1393">                    if (value[pos] == null ? v == null : value[pos]</a>
<span class="sourceLineNo">1394</span><a id="line.1394">                            .equals(v)) {</a>
<span class="sourceLineNo">1395</span><a id="line.1395">                        removeEntry(pos);</a>
<span class="sourceLineNo">1396</span><a id="line.1396">                        return true;</a>
<span class="sourceLineNo">1397</span><a id="line.1397">                    }</a>
<span class="sourceLineNo">1398</span><a id="line.1398">                }</a>
<span class="sourceLineNo">1399</span><a id="line.1399">            }</a>
<span class="sourceLineNo">1400</span><a id="line.1400">        }</a>
<span class="sourceLineNo">1401</span><a id="line.1401">        public int size() {</a>
<span class="sourceLineNo">1402</span><a id="line.1402">            return size;</a>
<span class="sourceLineNo">1403</span><a id="line.1403">        }</a>
<span class="sourceLineNo">1404</span><a id="line.1404">        public void clear() {</a>
<span class="sourceLineNo">1405</span><a id="line.1405">            OrderedMap.this.clear();</a>
<span class="sourceLineNo">1406</span><a id="line.1406">        }</a>
<span class="sourceLineNo">1407</span><a id="line.1407"></a>
<span class="sourceLineNo">1408</span><a id="line.1408">        @Override</a>
<span class="sourceLineNo">1409</span><a id="line.1409">        public boolean equals(final Object o) {</a>
<span class="sourceLineNo">1410</span><a id="line.1410">            if (o == this)</a>
<span class="sourceLineNo">1411</span><a id="line.1411">                return true;</a>
<span class="sourceLineNo">1412</span><a id="line.1412">            if (!(o instanceof Set))</a>
<span class="sourceLineNo">1413</span><a id="line.1413">                return false;</a>
<span class="sourceLineNo">1414</span><a id="line.1414">            Set&lt;?&gt; s = (Set&lt;?&gt;) o;</a>
<span class="sourceLineNo">1415</span><a id="line.1415">            return s.size() == size() &amp;&amp; containsAll(s);</a>
<span class="sourceLineNo">1416</span><a id="line.1416">        }</a>
<span class="sourceLineNo">1417</span><a id="line.1417"></a>
<span class="sourceLineNo">1418</span><a id="line.1418">        public Object[] toArray() {</a>
<span class="sourceLineNo">1419</span><a id="line.1419">            final Object[] a = new Object[size()];</a>
<span class="sourceLineNo">1420</span><a id="line.1420">            objectUnwrap(iterator(), a);</a>
<span class="sourceLineNo">1421</span><a id="line.1421">            return a;</a>
<span class="sourceLineNo">1422</span><a id="line.1422">        }</a>
<span class="sourceLineNo">1423</span><a id="line.1423"></a>
<span class="sourceLineNo">1424</span><a id="line.1424">        @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">1425</span><a id="line.1425">        public &lt;T&gt; T[] toArray(T[] a) {</a>
<span class="sourceLineNo">1426</span><a id="line.1426">            if (a == null || a.length &lt; size()) a = (T[]) new Object[size()];</a>
<span class="sourceLineNo">1427</span><a id="line.1427">            objectUnwrap(iterator(), a);</a>
<span class="sourceLineNo">1428</span><a id="line.1428">            return a;</a>
<span class="sourceLineNo">1429</span><a id="line.1429">        }</a>
<span class="sourceLineNo">1430</span><a id="line.1430"></a>
<span class="sourceLineNo">1431</span><a id="line.1431">        /**</a>
<span class="sourceLineNo">1432</span><a id="line.1432">         * Unsupported.</a>
<span class="sourceLineNo">1433</span><a id="line.1433">         *</a>
<span class="sourceLineNo">1434</span><a id="line.1434">         * @param c ignored</a>
<span class="sourceLineNo">1435</span><a id="line.1435">         * @return nothing, throws UnsupportedOperationException</a>
<span class="sourceLineNo">1436</span><a id="line.1436">         * @throws UnsupportedOperationException always</a>
<span class="sourceLineNo">1437</span><a id="line.1437">         */</a>
<span class="sourceLineNo">1438</span><a id="line.1438">        public boolean addAll(Collection&lt;? extends Entry&lt;K, V&gt;&gt; c) {</a>
<span class="sourceLineNo">1439</span><a id="line.1439">            throw new UnsupportedOperationException("addAll not supported");</a>
<span class="sourceLineNo">1440</span><a id="line.1440">        }</a>
<span class="sourceLineNo">1441</span><a id="line.1441"></a>
<span class="sourceLineNo">1442</span><a id="line.1442">        /**</a>
<span class="sourceLineNo">1443</span><a id="line.1443">         * Unsupported.</a>
<span class="sourceLineNo">1444</span><a id="line.1444">         *</a>
<span class="sourceLineNo">1445</span><a id="line.1445">         * @param k ignored</a>
<span class="sourceLineNo">1446</span><a id="line.1446">         * @return nothing, throws UnsupportedOperationException</a>
<span class="sourceLineNo">1447</span><a id="line.1447">         * @throws UnsupportedOperationException always</a>
<span class="sourceLineNo">1448</span><a id="line.1448">         */</a>
<span class="sourceLineNo">1449</span><a id="line.1449">        public boolean add(Entry&lt;K, V&gt; k) {</a>
<span class="sourceLineNo">1450</span><a id="line.1450">            throw new UnsupportedOperationException("add not supported");</a>
<span class="sourceLineNo">1451</span><a id="line.1451">        }</a>
<span class="sourceLineNo">1452</span><a id="line.1452"></a>
<span class="sourceLineNo">1453</span><a id="line.1453">        /**</a>
<span class="sourceLineNo">1454</span><a id="line.1454">         * Checks whether this collection contains all elements from the given</a>
<span class="sourceLineNo">1455</span><a id="line.1455">         * collection.</a>
<span class="sourceLineNo">1456</span><a id="line.1456">         *</a>
<span class="sourceLineNo">1457</span><a id="line.1457">         * @param c a collection.</a>
<span class="sourceLineNo">1458</span><a id="line.1458">         * @return &lt;code&gt;true&lt;/code&gt; if this collection contains all elements of the</a>
<span class="sourceLineNo">1459</span><a id="line.1459">         * argument.</a>
<span class="sourceLineNo">1460</span><a id="line.1460">         */</a>
<span class="sourceLineNo">1461</span><a id="line.1461">        public boolean containsAll(Collection&lt;?&gt; c) {</a>
<span class="sourceLineNo">1462</span><a id="line.1462">            int n = c.size();</a>
<span class="sourceLineNo">1463</span><a id="line.1463">            final Iterator&lt;?&gt; i = c.iterator();</a>
<span class="sourceLineNo">1464</span><a id="line.1464">            while (n-- != 0)</a>
<span class="sourceLineNo">1465</span><a id="line.1465">                if (!contains(i.next()))</a>
<span class="sourceLineNo">1466</span><a id="line.1466">                    return false;</a>
<span class="sourceLineNo">1467</span><a id="line.1467">            return true;</a>
<span class="sourceLineNo">1468</span><a id="line.1468">        }</a>
<span class="sourceLineNo">1469</span><a id="line.1469"></a>
<span class="sourceLineNo">1470</span><a id="line.1470">        /**</a>
<span class="sourceLineNo">1471</span><a id="line.1471">         * Retains in this collection only elements from the given collection.</a>
<span class="sourceLineNo">1472</span><a id="line.1472">         *</a>
<span class="sourceLineNo">1473</span><a id="line.1473">         * @param c a collection.</a>
<span class="sourceLineNo">1474</span><a id="line.1474">         * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the</a>
<span class="sourceLineNo">1475</span><a id="line.1475">         * call.</a>
<span class="sourceLineNo">1476</span><a id="line.1476">         */</a>
<span class="sourceLineNo">1477</span><a id="line.1477">        public boolean retainAll(Collection&lt;?&gt; c) {</a>
<span class="sourceLineNo">1478</span><a id="line.1478">            boolean retVal = false;</a>
<span class="sourceLineNo">1479</span><a id="line.1479">            int n = size();</a>
<span class="sourceLineNo">1480</span><a id="line.1480">            final Iterator&lt;?&gt; i = iterator();</a>
<span class="sourceLineNo">1481</span><a id="line.1481">            while (n-- != 0) {</a>
<span class="sourceLineNo">1482</span><a id="line.1482">                if (!c.contains(i.next())) {</a>
<span class="sourceLineNo">1483</span><a id="line.1483">                    i.remove();</a>
<span class="sourceLineNo">1484</span><a id="line.1484">                    retVal = true;</a>
<span class="sourceLineNo">1485</span><a id="line.1485">                }</a>
<span class="sourceLineNo">1486</span><a id="line.1486">            }</a>
<span class="sourceLineNo">1487</span><a id="line.1487">            return retVal;</a>
<span class="sourceLineNo">1488</span><a id="line.1488">        }</a>
<span class="sourceLineNo">1489</span><a id="line.1489"></a>
<span class="sourceLineNo">1490</span><a id="line.1490">        /**</a>
<span class="sourceLineNo">1491</span><a id="line.1491">         * Remove from this collection all elements in the given collection. If the</a>
<span class="sourceLineNo">1492</span><a id="line.1492">         * collection is an instance of this class, it uses faster iterators.</a>
<span class="sourceLineNo">1493</span><a id="line.1493">         *</a>
<span class="sourceLineNo">1494</span><a id="line.1494">         * @param c a collection.</a>
<span class="sourceLineNo">1495</span><a id="line.1495">         * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the</a>
<span class="sourceLineNo">1496</span><a id="line.1496">         * call.</a>
<span class="sourceLineNo">1497</span><a id="line.1497">         */</a>
<span class="sourceLineNo">1498</span><a id="line.1498">        public boolean removeAll(Collection&lt;?&gt; c) {</a>
<span class="sourceLineNo">1499</span><a id="line.1499">            boolean retVal = false;</a>
<span class="sourceLineNo">1500</span><a id="line.1500">            int n = c.size();</a>
<span class="sourceLineNo">1501</span><a id="line.1501">            final Iterator&lt;?&gt; i = c.iterator();</a>
<span class="sourceLineNo">1502</span><a id="line.1502">            while (n-- != 0)</a>
<span class="sourceLineNo">1503</span><a id="line.1503">                if (remove(i.next()))</a>
<span class="sourceLineNo">1504</span><a id="line.1504">                    retVal = true;</a>
<span class="sourceLineNo">1505</span><a id="line.1505">            return retVal;</a>
<span class="sourceLineNo">1506</span><a id="line.1506">        }</a>
<span class="sourceLineNo">1507</span><a id="line.1507"></a>
<span class="sourceLineNo">1508</span><a id="line.1508">        public boolean isEmpty() {</a>
<span class="sourceLineNo">1509</span><a id="line.1509">            return size() == 0;</a>
<span class="sourceLineNo">1510</span><a id="line.1510">        }</a>
<span class="sourceLineNo">1511</span><a id="line.1511"></a>
<span class="sourceLineNo">1512</span><a id="line.1512">        @Override</a>
<span class="sourceLineNo">1513</span><a id="line.1513">        public String toString() {</a>
<span class="sourceLineNo">1514</span><a id="line.1514">            final StringBuilder s = new StringBuilder();</a>
<span class="sourceLineNo">1515</span><a id="line.1515">            final EntryIterator i = iterator();</a>
<span class="sourceLineNo">1516</span><a id="line.1516">            int n = size();</a>
<span class="sourceLineNo">1517</span><a id="line.1517">            MapEntry k;</a>
<span class="sourceLineNo">1518</span><a id="line.1518">            boolean first = true;</a>
<span class="sourceLineNo">1519</span><a id="line.1519">            s.append("{");</a>
<span class="sourceLineNo">1520</span><a id="line.1520">            while (n-- != 0) {</a>
<span class="sourceLineNo">1521</span><a id="line.1521">                if (first)</a>
<span class="sourceLineNo">1522</span><a id="line.1522">                    first = false;</a>
<span class="sourceLineNo">1523</span><a id="line.1523">                else</a>
<span class="sourceLineNo">1524</span><a id="line.1524">                    s.append(", ");</a>
<span class="sourceLineNo">1525</span><a id="line.1525">                k = i.next();</a>
<span class="sourceLineNo">1526</span><a id="line.1526">                s.append(key[k.index] == OrderedMap.this ? "(this collection)" : String.valueOf(key[k.index]))</a>
<span class="sourceLineNo">1527</span><a id="line.1527">                        .append("=&gt;")</a>
<span class="sourceLineNo">1528</span><a id="line.1528">                        .append(value[k.index] == OrderedMap.this ? "(this collection)" : String.valueOf(value[k.index]));</a>
<span class="sourceLineNo">1529</span><a id="line.1529">            }</a>
<span class="sourceLineNo">1530</span><a id="line.1530">            s.append("}");</a>
<span class="sourceLineNo">1531</span><a id="line.1531">            return s.toString();</a>
<span class="sourceLineNo">1532</span><a id="line.1532">        }</a>
<span class="sourceLineNo">1533</span><a id="line.1533"></a>
<span class="sourceLineNo">1534</span><a id="line.1534">    }</a>
<span class="sourceLineNo">1535</span><a id="line.1535"></a>
<span class="sourceLineNo">1536</span><a id="line.1536">    @Override</a>
<span class="sourceLineNo">1537</span><a id="line.1537">    public SortedSet&lt;Entry&lt;K,V&gt;&gt; entrySet() {</a>
<span class="sourceLineNo">1538</span><a id="line.1538">        if (entries == null) entries = new MapEntrySet();</a>
<span class="sourceLineNo">1539</span><a id="line.1539">        return entries;</a>
<span class="sourceLineNo">1540</span><a id="line.1540">    }</a>
<span class="sourceLineNo">1541</span><a id="line.1541"></a>
<span class="sourceLineNo">1542</span><a id="line.1542">    /**</a>
<span class="sourceLineNo">1543</span><a id="line.1543">     * An iterator on keys.</a>
<span class="sourceLineNo">1544</span><a id="line.1544">     * &lt;p&gt;</a>
<span class="sourceLineNo">1545</span><a id="line.1545">     * &lt;P&gt;We simply override the {@link ListIterator#next()}/{@link ListIterator#previous()} methods (and possibly their type-specific counterparts) so that they return keys</a>
<span class="sourceLineNo">1546</span><a id="line.1546">     * instead of entries.</a>
<span class="sourceLineNo">1547</span><a id="line.1547">     */</a>
<span class="sourceLineNo">1548</span><a id="line.1548">    public final class KeyIterator extends MapIterator implements Iterator&lt;K&gt;, Serializable {</a>
<span class="sourceLineNo">1549</span><a id="line.1549">        private static final long serialVersionUID = 0L;</a>
<span class="sourceLineNo">1550</span><a id="line.1550">        public K previous() {</a>
<span class="sourceLineNo">1551</span><a id="line.1551">            return key[previousEntry()];</a>
<span class="sourceLineNo">1552</span><a id="line.1552">        }</a>
<span class="sourceLineNo">1553</span><a id="line.1553">        public void set(K k) {</a>
<span class="sourceLineNo">1554</span><a id="line.1554">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1555</span><a id="line.1555">        }</a>
<span class="sourceLineNo">1556</span><a id="line.1556">        public void add(K k) {</a>
<span class="sourceLineNo">1557</span><a id="line.1557">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1558</span><a id="line.1558">        }</a>
<span class="sourceLineNo">1559</span><a id="line.1559">        public KeyIterator() {}</a>
<span class="sourceLineNo">1560</span><a id="line.1560">        public K next() {</a>
<span class="sourceLineNo">1561</span><a id="line.1561">            return key[nextEntry()];</a>
<span class="sourceLineNo">1562</span><a id="line.1562">        }</a>
<span class="sourceLineNo">1563</span><a id="line.1563">        public void remove() { super.remove(); }</a>
<span class="sourceLineNo">1564</span><a id="line.1564">    }</a>
<span class="sourceLineNo">1565</span><a id="line.1565"></a>
<span class="sourceLineNo">1566</span><a id="line.1566">    public final class KeySet implements SortedSet&lt;K&gt;, Serializable {</a>
<span class="sourceLineNo">1567</span><a id="line.1567">        private static final long serialVersionUID = 0L;</a>
<span class="sourceLineNo">1568</span><a id="line.1568"></a>
<span class="sourceLineNo">1569</span><a id="line.1569">        public KeyIterator iterator() {</a>
<span class="sourceLineNo">1570</span><a id="line.1570">            return new KeyIterator();</a>
<span class="sourceLineNo">1571</span><a id="line.1571">        }</a>
<span class="sourceLineNo">1572</span><a id="line.1572"></a>
<span class="sourceLineNo">1573</span><a id="line.1573">        public int size() {</a>
<span class="sourceLineNo">1574</span><a id="line.1574">            return size;</a>
<span class="sourceLineNo">1575</span><a id="line.1575">        }</a>
<span class="sourceLineNo">1576</span><a id="line.1576"></a>
<span class="sourceLineNo">1577</span><a id="line.1577">        public void clear() {</a>
<span class="sourceLineNo">1578</span><a id="line.1578">            OrderedMap.this.clear();</a>
<span class="sourceLineNo">1579</span><a id="line.1579">        }</a>
<span class="sourceLineNo">1580</span><a id="line.1580"></a>
<span class="sourceLineNo">1581</span><a id="line.1581">        public K first() {</a>
<span class="sourceLineNo">1582</span><a id="line.1582">            if (size == 0) throw new NoSuchElementException();</a>
<span class="sourceLineNo">1583</span><a id="line.1583">            return key[order.items[0]];</a>
<span class="sourceLineNo">1584</span><a id="line.1584">        }</a>
<span class="sourceLineNo">1585</span><a id="line.1585"></a>
<span class="sourceLineNo">1586</span><a id="line.1586">        public K last() {</a>
<span class="sourceLineNo">1587</span><a id="line.1587">            if (size == 0) throw new NoSuchElementException();</a>
<span class="sourceLineNo">1588</span><a id="line.1588">            return key[order.items[order.size-1]];</a>
<span class="sourceLineNo">1589</span><a id="line.1589">        }</a>
<span class="sourceLineNo">1590</span><a id="line.1590"></a>
<span class="sourceLineNo">1591</span><a id="line.1591">        public Comparator&lt;K&gt; comparator() {</a>
<span class="sourceLineNo">1592</span><a id="line.1592">            return null;</a>
<span class="sourceLineNo">1593</span><a id="line.1593">        }</a>
<span class="sourceLineNo">1594</span><a id="line.1594"></a>
<span class="sourceLineNo">1595</span><a id="line.1595">        public final SortedSet&lt;K&gt; tailSet(K from) {</a>
<span class="sourceLineNo">1596</span><a id="line.1596">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1597</span><a id="line.1597">        }</a>
<span class="sourceLineNo">1598</span><a id="line.1598"></a>
<span class="sourceLineNo">1599</span><a id="line.1599">        public final SortedSet&lt;K&gt; headSet(K to) {</a>
<span class="sourceLineNo">1600</span><a id="line.1600">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1601</span><a id="line.1601">        }</a>
<span class="sourceLineNo">1602</span><a id="line.1602"></a>
<span class="sourceLineNo">1603</span><a id="line.1603">        public final SortedSet&lt;K&gt; subSet(K from, K to) {</a>
<span class="sourceLineNo">1604</span><a id="line.1604">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1605</span><a id="line.1605">        }</a>
<span class="sourceLineNo">1606</span><a id="line.1606"></a>
<span class="sourceLineNo">1607</span><a id="line.1607">        @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">1608</span><a id="line.1608">        @Override</a>
<span class="sourceLineNo">1609</span><a id="line.1609">        public &lt;T&gt; T[] toArray(T[] a) {</a>
<span class="sourceLineNo">1610</span><a id="line.1610">            if (a == null || a.length &lt; size()) a = (T[]) new Object[size()];</a>
<span class="sourceLineNo">1611</span><a id="line.1611">            unwrap(iterator(), a);</a>
<span class="sourceLineNo">1612</span><a id="line.1612">            return a;</a>
<span class="sourceLineNo">1613</span><a id="line.1613">        }</a>
<span class="sourceLineNo">1614</span><a id="line.1614"></a>
<span class="sourceLineNo">1615</span><a id="line.1615">        /**</a>
<span class="sourceLineNo">1616</span><a id="line.1616">         * Always throws an UnsupportedOperationException</a>
<span class="sourceLineNo">1617</span><a id="line.1617">         */</a>
<span class="sourceLineNo">1618</span><a id="line.1618">        public boolean remove(Object ok) {</a>
<span class="sourceLineNo">1619</span><a id="line.1619">            throw new UnsupportedOperationException("Cannot remove from the key set directly");</a>
<span class="sourceLineNo">1620</span><a id="line.1620">        }</a>
<span class="sourceLineNo">1621</span><a id="line.1621"></a>
<span class="sourceLineNo">1622</span><a id="line.1622">        /**</a>
<span class="sourceLineNo">1623</span><a id="line.1623">         * Always throws an UnsupportedOperationException</a>
<span class="sourceLineNo">1624</span><a id="line.1624">         */</a>
<span class="sourceLineNo">1625</span><a id="line.1625">        public boolean add(final K o) {</a>
<span class="sourceLineNo">1626</span><a id="line.1626">            throw new UnsupportedOperationException("Cannot add to the key set directly");</a>
<span class="sourceLineNo">1627</span><a id="line.1627">        }</a>
<span class="sourceLineNo">1628</span><a id="line.1628"></a>
<span class="sourceLineNo">1629</span><a id="line.1629">        /**</a>
<span class="sourceLineNo">1630</span><a id="line.1630">         * Delegates to the corresponding type-specific method.</a>
<span class="sourceLineNo">1631</span><a id="line.1631">         */</a>
<span class="sourceLineNo">1632</span><a id="line.1632">        public boolean contains(final Object o) {</a>
<span class="sourceLineNo">1633</span><a id="line.1633">            return containsKey(o);</a>
<span class="sourceLineNo">1634</span><a id="line.1634">        }</a>
<span class="sourceLineNo">1635</span><a id="line.1635"></a>
<span class="sourceLineNo">1636</span><a id="line.1636">        /**</a>
<span class="sourceLineNo">1637</span><a id="line.1637">         * Checks whether this collection contains all elements from the given type-specific collection.</a>
<span class="sourceLineNo">1638</span><a id="line.1638">         *</a>
<span class="sourceLineNo">1639</span><a id="line.1639">         * @param c a type-specific collection.</a>
<span class="sourceLineNo">1640</span><a id="line.1640">         * @return &lt;code&gt;true&lt;/code&gt; if this collection contains all elements of the argument.</a>
<span class="sourceLineNo">1641</span><a id="line.1641">         */</a>
<span class="sourceLineNo">1642</span><a id="line.1642">        public boolean containsAll(Collection&lt;?&gt; c) {</a>
<span class="sourceLineNo">1643</span><a id="line.1643">            final Iterator&lt;?&gt; i = c.iterator();</a>
<span class="sourceLineNo">1644</span><a id="line.1644">            int n = c.size();</a>
<span class="sourceLineNo">1645</span><a id="line.1645">            while (n-- != 0)</a>
<span class="sourceLineNo">1646</span><a id="line.1646">                if (!contains(i.next())) return false;</a>
<span class="sourceLineNo">1647</span><a id="line.1647">            return true;</a>
<span class="sourceLineNo">1648</span><a id="line.1648">        }</a>
<span class="sourceLineNo">1649</span><a id="line.1649"></a>
<span class="sourceLineNo">1650</span><a id="line.1650">        /**</a>
<span class="sourceLineNo">1651</span><a id="line.1651">         * Retains in this collection only elements from the given type-specific collection.</a>
<span class="sourceLineNo">1652</span><a id="line.1652">         *</a>
<span class="sourceLineNo">1653</span><a id="line.1653">         * @param c a type-specific collection.</a>
<span class="sourceLineNo">1654</span><a id="line.1654">         * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the call.</a>
<span class="sourceLineNo">1655</span><a id="line.1655">         */</a>
<span class="sourceLineNo">1656</span><a id="line.1656">        public boolean retainAll(Collection&lt;?&gt; c) {</a>
<span class="sourceLineNo">1657</span><a id="line.1657">            boolean retVal = false;</a>
<span class="sourceLineNo">1658</span><a id="line.1658">            int n = size();</a>
<span class="sourceLineNo">1659</span><a id="line.1659">            final Iterator&lt;?&gt; i = iterator();</a>
<span class="sourceLineNo">1660</span><a id="line.1660">            while (n-- != 0) {</a>
<span class="sourceLineNo">1661</span><a id="line.1661">                if (!c.contains(i.next())) {</a>
<span class="sourceLineNo">1662</span><a id="line.1662">                    i.remove();</a>
<span class="sourceLineNo">1663</span><a id="line.1663">                    retVal = true;</a>
<span class="sourceLineNo">1664</span><a id="line.1664">                }</a>
<span class="sourceLineNo">1665</span><a id="line.1665">            }</a>
<span class="sourceLineNo">1666</span><a id="line.1666">            return retVal;</a>
<span class="sourceLineNo">1667</span><a id="line.1667">        }</a>
<span class="sourceLineNo">1668</span><a id="line.1668"></a>
<span class="sourceLineNo">1669</span><a id="line.1669">        /**</a>
<span class="sourceLineNo">1670</span><a id="line.1670">         * Remove from this collection all elements in the given type-specific collection.</a>
<span class="sourceLineNo">1671</span><a id="line.1671">         *</a>
<span class="sourceLineNo">1672</span><a id="line.1672">         * @param c a type-specific collection.</a>
<span class="sourceLineNo">1673</span><a id="line.1673">         * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the call.</a>
<span class="sourceLineNo">1674</span><a id="line.1674">         */</a>
<span class="sourceLineNo">1675</span><a id="line.1675">        public boolean removeAll(Collection&lt;?&gt; c) {</a>
<span class="sourceLineNo">1676</span><a id="line.1676">            boolean retVal = false;</a>
<span class="sourceLineNo">1677</span><a id="line.1677">            int n = c.size();</a>
<span class="sourceLineNo">1678</span><a id="line.1678">            final Iterator&lt;?&gt; i = c.iterator();</a>
<span class="sourceLineNo">1679</span><a id="line.1679">            while (n-- != 0)</a>
<span class="sourceLineNo">1680</span><a id="line.1680">                if (remove(i.next())) retVal = true;</a>
<span class="sourceLineNo">1681</span><a id="line.1681">            return false;</a>
<span class="sourceLineNo">1682</span><a id="line.1682">        }</a>
<span class="sourceLineNo">1683</span><a id="line.1683"></a>
<span class="sourceLineNo">1684</span><a id="line.1684">        public Object[] toArray() {</a>
<span class="sourceLineNo">1685</span><a id="line.1685">            final Object[] a = new Object[size()];</a>
<span class="sourceLineNo">1686</span><a id="line.1686">            objectUnwrap(iterator(), a);</a>
<span class="sourceLineNo">1687</span><a id="line.1687">            return a;</a>
<span class="sourceLineNo">1688</span><a id="line.1688">        }</a>
<span class="sourceLineNo">1689</span><a id="line.1689"></a>
<span class="sourceLineNo">1690</span><a id="line.1690">        /**</a>
<span class="sourceLineNo">1691</span><a id="line.1691">         * Adds all elements of the given collection to this collection.</a>
<span class="sourceLineNo">1692</span><a id="line.1692">         *</a>
<span class="sourceLineNo">1693</span><a id="line.1693">         * @param c a collection.</a>
<span class="sourceLineNo">1694</span><a id="line.1694">         * @return &lt;code&gt;true&lt;/code&gt; if this collection changed as a result of the call.</a>
<span class="sourceLineNo">1695</span><a id="line.1695">         */</a>
<span class="sourceLineNo">1696</span><a id="line.1696">        public boolean addAll(Collection&lt;? extends K&gt; c) {</a>
<span class="sourceLineNo">1697</span><a id="line.1697">            boolean retVal = false;</a>
<span class="sourceLineNo">1698</span><a id="line.1698">            final Iterator&lt;? extends K&gt; i = c.iterator();</a>
<span class="sourceLineNo">1699</span><a id="line.1699">            int n = c.size();</a>
<span class="sourceLineNo">1700</span><a id="line.1700">            while (n-- != 0)</a>
<span class="sourceLineNo">1701</span><a id="line.1701">                if (add(i.next())) retVal = true;</a>
<span class="sourceLineNo">1702</span><a id="line.1702">            return false;</a>
<span class="sourceLineNo">1703</span><a id="line.1703">        }</a>
<span class="sourceLineNo">1704</span><a id="line.1704"></a>
<span class="sourceLineNo">1705</span><a id="line.1705">        @Override</a>
<span class="sourceLineNo">1706</span><a id="line.1706">        public boolean equals(final Object o) {</a>
<span class="sourceLineNo">1707</span><a id="line.1707">            if (o == this)</a>
<span class="sourceLineNo">1708</span><a id="line.1708">                return true;</a>
<span class="sourceLineNo">1709</span><a id="line.1709">            if (!(o instanceof Set))</a>
<span class="sourceLineNo">1710</span><a id="line.1710">                return false;</a>
<span class="sourceLineNo">1711</span><a id="line.1711">            Set&lt;?&gt; s = (Set&lt;?&gt;) o;</a>
<span class="sourceLineNo">1712</span><a id="line.1712">            if (s.size() != size())</a>
<span class="sourceLineNo">1713</span><a id="line.1713">                return false;</a>
<span class="sourceLineNo">1714</span><a id="line.1714">            return containsAll(s);</a>
<span class="sourceLineNo">1715</span><a id="line.1715">        }</a>
<span class="sourceLineNo">1716</span><a id="line.1716">        /**</a>
<span class="sourceLineNo">1717</span><a id="line.1717">         * Unwraps an iterator into an array starting at a given offset for a given number of elements.</a>
<span class="sourceLineNo">1718</span><a id="line.1718">         * &lt;p&gt;</a>
<span class="sourceLineNo">1719</span><a id="line.1719">         * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</a>
<span class="sourceLineNo">1720</span><a id="line.1720">         * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</a>
<span class="sourceLineNo">1721</span><a id="line.1721">         *</a>
<span class="sourceLineNo">1722</span><a id="line.1722">         * @param i      a type-specific iterator.</a>
<span class="sourceLineNo">1723</span><a id="line.1723">         * @param array  an array to contain the output of the iterator.</a>
<span class="sourceLineNo">1724</span><a id="line.1724">         * @param offset the first element of the array to be returned.</a>
<span class="sourceLineNo">1725</span><a id="line.1725">         * @param max    the maximum number of elements to unwrap.</a>
<span class="sourceLineNo">1726</span><a id="line.1726">         * @return the number of elements unwrapped.</a>
<span class="sourceLineNo">1727</span><a id="line.1727">         */</a>
<span class="sourceLineNo">1728</span><a id="line.1728">        public int unwrap(final KeyIterator i, final Object[] array, int offset, final int max) {</a>
<span class="sourceLineNo">1729</span><a id="line.1729">            if (max &lt; 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");</a>
<span class="sourceLineNo">1730</span><a id="line.1730">            if (offset &lt; 0 || offset + max &gt; array.length) throw new IllegalArgumentException();</a>
<span class="sourceLineNo">1731</span><a id="line.1731">            int j = max;</a>
<span class="sourceLineNo">1732</span><a id="line.1732">            while (j-- != 0 &amp;&amp; i.hasNext())</a>
<span class="sourceLineNo">1733</span><a id="line.1733">                array[offset++] = i.next();</a>
<span class="sourceLineNo">1734</span><a id="line.1734">            return max - j - 1;</a>
<span class="sourceLineNo">1735</span><a id="line.1735">        }</a>
<span class="sourceLineNo">1736</span><a id="line.1736"></a>
<span class="sourceLineNo">1737</span><a id="line.1737">        /**</a>
<span class="sourceLineNo">1738</span><a id="line.1738">         * Unwraps an iterator into an array.</a>
<span class="sourceLineNo">1739</span><a id="line.1739">         * &lt;p&gt;</a>
<span class="sourceLineNo">1740</span><a id="line.1740">         * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</a>
<span class="sourceLineNo">1741</span><a id="line.1741">         * of the array has been reached.</a>
<span class="sourceLineNo">1742</span><a id="line.1742">         *</a>
<span class="sourceLineNo">1743</span><a id="line.1743">         * @param i     a type-specific iterator.</a>
<span class="sourceLineNo">1744</span><a id="line.1744">         * @param array an array to contain the output of the iterator.</a>
<span class="sourceLineNo">1745</span><a id="line.1745">         * @return the number of elements unwrapped.</a>
<span class="sourceLineNo">1746</span><a id="line.1746">         */</a>
<span class="sourceLineNo">1747</span><a id="line.1747">        public int unwrap(final KeyIterator i, final Object[] array) {</a>
<span class="sourceLineNo">1748</span><a id="line.1748">            return unwrap(i, array, 0, array.length);</a>
<span class="sourceLineNo">1749</span><a id="line.1749">        }</a>
<span class="sourceLineNo">1750</span><a id="line.1750"></a>
<span class="sourceLineNo">1751</span><a id="line.1751">        public boolean isEmpty() {</a>
<span class="sourceLineNo">1752</span><a id="line.1752">            return size() == 0;</a>
<span class="sourceLineNo">1753</span><a id="line.1753">        }</a>
<span class="sourceLineNo">1754</span><a id="line.1754"></a>
<span class="sourceLineNo">1755</span><a id="line.1755">        @Override</a>
<span class="sourceLineNo">1756</span><a id="line.1756">        public String toString() {</a>
<span class="sourceLineNo">1757</span><a id="line.1757">            final StringBuilder s = new StringBuilder();</a>
<span class="sourceLineNo">1758</span><a id="line.1758">            int n = size();</a>
<span class="sourceLineNo">1759</span><a id="line.1759">            boolean first = true;</a>
<span class="sourceLineNo">1760</span><a id="line.1760">            s.append("{");</a>
<span class="sourceLineNo">1761</span><a id="line.1761">            for (int i = 0; i &lt; n; i++) {</a>
<span class="sourceLineNo">1762</span><a id="line.1762">                if (first) first = false;</a>
<span class="sourceLineNo">1763</span><a id="line.1763">                else s.append(", ");</a>
<span class="sourceLineNo">1764</span><a id="line.1764">                K k = keyAt(i);</a>
<span class="sourceLineNo">1765</span><a id="line.1765">                s.append(k == OrderedMap.this ? "(this collection)" : String.valueOf(k));</a>
<span class="sourceLineNo">1766</span><a id="line.1766">            }</a>
<span class="sourceLineNo">1767</span><a id="line.1767">            s.append("}");</a>
<span class="sourceLineNo">1768</span><a id="line.1768">            return s.toString();</a>
<span class="sourceLineNo">1769</span><a id="line.1769">        }</a>
<span class="sourceLineNo">1770</span><a id="line.1770">    }</a>
<span class="sourceLineNo">1771</span><a id="line.1771"></a>
<span class="sourceLineNo">1772</span><a id="line.1772">    public SortedSet&lt;K&gt; keySet() {</a>
<span class="sourceLineNo">1773</span><a id="line.1773">        if (keys == null) keys = new KeySet();</a>
<span class="sourceLineNo">1774</span><a id="line.1774">        return keys;</a>
<span class="sourceLineNo">1775</span><a id="line.1775">    }</a>
<span class="sourceLineNo">1776</span><a id="line.1776"></a>
<span class="sourceLineNo">1777</span><a id="line.1777">    public OrderedSet&lt;K&gt; keysAsOrderedSet()</a>
<span class="sourceLineNo">1778</span><a id="line.1778">    {</a>
<span class="sourceLineNo">1779</span><a id="line.1779">        OrderedSet&lt;K&gt; os = new OrderedSet&lt;&gt;(size, f, hasher);</a>
<span class="sourceLineNo">1780</span><a id="line.1780">        for (int i = 0; i &lt; size; i++) {</a>
<span class="sourceLineNo">1781</span><a id="line.1781">            os.add(keyAt(i));</a>
<span class="sourceLineNo">1782</span><a id="line.1782">        }</a>
<span class="sourceLineNo">1783</span><a id="line.1783">        return os;</a>
<span class="sourceLineNo">1784</span><a id="line.1784">    }</a>
<span class="sourceLineNo">1785</span><a id="line.1785"></a>
<span class="sourceLineNo">1786</span><a id="line.1786">    /**</a>
<span class="sourceLineNo">1787</span><a id="line.1787">     * An iterator on values.</a>
<span class="sourceLineNo">1788</span><a id="line.1788">     * &lt;p&gt;</a>
<span class="sourceLineNo">1789</span><a id="line.1789">     * &lt;P&gt;We simply override the {@link ListIterator#next()}/{@link ListIterator#previous()} methods (and possibly their type-specific counterparts) so that they return values</a>
<span class="sourceLineNo">1790</span><a id="line.1790">     * instead of entries.</a>
<span class="sourceLineNo">1791</span><a id="line.1791">     */</a>
<span class="sourceLineNo">1792</span><a id="line.1792">    public final class ValueIterator extends MapIterator implements ListIterator&lt;V&gt;, Serializable {</a>
<span class="sourceLineNo">1793</span><a id="line.1793">        private static final long serialVersionUID = 0L;</a>
<span class="sourceLineNo">1794</span><a id="line.1794"></a>
<span class="sourceLineNo">1795</span><a id="line.1795">        public V previous() {</a>
<span class="sourceLineNo">1796</span><a id="line.1796">            return value[previousEntry()];</a>
<span class="sourceLineNo">1797</span><a id="line.1797">        }</a>
<span class="sourceLineNo">1798</span><a id="line.1798">        public void set(V v) {</a>
<span class="sourceLineNo">1799</span><a id="line.1799">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1800</span><a id="line.1800">        }</a>
<span class="sourceLineNo">1801</span><a id="line.1801">        public void add(V v) {</a>
<span class="sourceLineNo">1802</span><a id="line.1802">            throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">1803</span><a id="line.1803">        }</a>
<span class="sourceLineNo">1804</span><a id="line.1804">        public ValueIterator() {}</a>
<span class="sourceLineNo">1805</span><a id="line.1805">        public V next() {</a>
<span class="sourceLineNo">1806</span><a id="line.1806">            return value[nextEntry()];</a>
<span class="sourceLineNo">1807</span><a id="line.1807">        }</a>
<span class="sourceLineNo">1808</span><a id="line.1808">        public void remove() { super.remove(); }</a>
<span class="sourceLineNo">1809</span><a id="line.1809">    }</a>
<span class="sourceLineNo">1810</span><a id="line.1810">    public final class ValueCollection extends AbstractCollection&lt;V&gt; implements Serializable</a>
<span class="sourceLineNo">1811</span><a id="line.1811">    {</a>
<span class="sourceLineNo">1812</span><a id="line.1812">        private static final long serialVersionUID = 0L;</a>
<span class="sourceLineNo">1813</span><a id="line.1813">        public ValueIterator iterator() {</a>
<span class="sourceLineNo">1814</span><a id="line.1814">            return new ValueIterator();</a>
<span class="sourceLineNo">1815</span><a id="line.1815">        }</a>
<span class="sourceLineNo">1816</span><a id="line.1816">        public int size() {</a>
<span class="sourceLineNo">1817</span><a id="line.1817">            return size;</a>
<span class="sourceLineNo">1818</span><a id="line.1818">        }</a>
<span class="sourceLineNo">1819</span><a id="line.1819">        public boolean contains(Object v) {</a>
<span class="sourceLineNo">1820</span><a id="line.1820">            return containsValue(v);</a>
<span class="sourceLineNo">1821</span><a id="line.1821">        }</a>
<span class="sourceLineNo">1822</span><a id="line.1822">        public void clear() {</a>
<span class="sourceLineNo">1823</span><a id="line.1823">            OrderedMap.this.clear();</a>
<span class="sourceLineNo">1824</span><a id="line.1824">        }</a>
<span class="sourceLineNo">1825</span><a id="line.1825">    }</a>
<span class="sourceLineNo">1826</span><a id="line.1826">    public Collection&lt;V&gt; values() {</a>
<span class="sourceLineNo">1827</span><a id="line.1827">        if (values == null) values = new ValueCollection();</a>
<span class="sourceLineNo">1828</span><a id="line.1828">        return values;</a>
<span class="sourceLineNo">1829</span><a id="line.1829">    }</a>
<span class="sourceLineNo">1830</span><a id="line.1830"></a>
<span class="sourceLineNo">1831</span><a id="line.1831">    public ArrayList&lt;V&gt; valuesAsList()</a>
<span class="sourceLineNo">1832</span><a id="line.1832">    {</a>
<span class="sourceLineNo">1833</span><a id="line.1833">        ArrayList&lt;V&gt; ls = new ArrayList&lt;&gt;(size);</a>
<span class="sourceLineNo">1834</span><a id="line.1834">        for (int i = 0; i &lt; size; i++) {</a>
<span class="sourceLineNo">1835</span><a id="line.1835">            ls.add(getAt(i));</a>
<span class="sourceLineNo">1836</span><a id="line.1836">        }</a>
<span class="sourceLineNo">1837</span><a id="line.1837">        return ls;</a>
<span class="sourceLineNo">1838</span><a id="line.1838">    }</a>
<span class="sourceLineNo">1839</span><a id="line.1839"></a>
<span class="sourceLineNo">1840</span><a id="line.1840">    /**</a>
<span class="sourceLineNo">1841</span><a id="line.1841">     * Rehashes the map, making the table as small as possible.</a>
<span class="sourceLineNo">1842</span><a id="line.1842">     * &lt;p&gt;</a>
<span class="sourceLineNo">1843</span><a id="line.1843">     * &lt;P&gt;This method rehashes the table to the smallest size satisfying the load factor. It can be used when the set will not be changed anymore, so to optimize access speed and size.</a>
<span class="sourceLineNo">1844</span><a id="line.1844">     * &lt;p&gt;</a>
<span class="sourceLineNo">1845</span><a id="line.1845">     * &lt;P&gt;If the table size is already the minimum possible, this method does nothing.</a>
<span class="sourceLineNo">1846</span><a id="line.1846">     *</a>
<span class="sourceLineNo">1847</span><a id="line.1847">     * @return true if there was enough memory to trim the map.</a>
<span class="sourceLineNo">1848</span><a id="line.1848">     * @see #trim(int)</a>
<span class="sourceLineNo">1849</span><a id="line.1849">     */</a>
<span class="sourceLineNo">1850</span><a id="line.1850">    public boolean trim() {</a>
<span class="sourceLineNo">1851</span><a id="line.1851">        final int l = arraySize(size, f);</a>
<span class="sourceLineNo">1852</span><a id="line.1852">        if (l &gt;= n || size &gt; maxFill(l, f)) return true;</a>
<span class="sourceLineNo">1853</span><a id="line.1853">        try {</a>
<span class="sourceLineNo">1854</span><a id="line.1854">            rehash(l);</a>
<span class="sourceLineNo">1855</span><a id="line.1855">        } catch (Exception cantDoIt) {</a>
<span class="sourceLineNo">1856</span><a id="line.1856">            return false;</a>
<span class="sourceLineNo">1857</span><a id="line.1857">        }</a>
<span class="sourceLineNo">1858</span><a id="line.1858">        return true;</a>
<span class="sourceLineNo">1859</span><a id="line.1859">    }</a>
<span class="sourceLineNo">1860</span><a id="line.1860"></a>
<span class="sourceLineNo">1861</span><a id="line.1861">    /**</a>
<span class="sourceLineNo">1862</span><a id="line.1862">     * Rehashes this map if the table is too large.</a>
<span class="sourceLineNo">1863</span><a id="line.1863">     * &lt;p&gt;</a>
<span class="sourceLineNo">1864</span><a id="line.1864">     * &lt;P&gt;Let &lt;var&gt;N&lt;/var&gt; be the smallest table size that can hold &lt;code&gt;max(n,{@link #size()})&lt;/code&gt; entries, still satisfying the load factor. If the current table size is smaller than or equal to</a>
<span class="sourceLineNo">1865</span><a id="line.1865">     * &lt;var&gt;N&lt;/var&gt;, this method does nothing. Otherwise, it rehashes this map in a table of size &lt;var&gt;N&lt;/var&gt;.</a>
<span class="sourceLineNo">1866</span><a id="line.1866">     * &lt;p&gt;</a>
<span class="sourceLineNo">1867</span><a id="line.1867">     * &lt;P&gt;This method is useful when reusing maps. {@linkplain #clear() Clearing a map} leaves the table size untouched. If you are reusing a map many times, you can call this method with a typical</a>
<span class="sourceLineNo">1868</span><a id="line.1868">     * size to avoid keeping around a very large table just because of a few large transient maps.</a>
<span class="sourceLineNo">1869</span><a id="line.1869">     *</a>
<span class="sourceLineNo">1870</span><a id="line.1870">     * @param n the threshold for the trimming.</a>
<span class="sourceLineNo">1871</span><a id="line.1871">     * @return true if there was enough memory to trim the map.</a>
<span class="sourceLineNo">1872</span><a id="line.1872">     * @see #trim()</a>
<span class="sourceLineNo">1873</span><a id="line.1873">     */</a>
<span class="sourceLineNo">1874</span><a id="line.1874">    public boolean trim(final int n) {</a>
<span class="sourceLineNo">1875</span><a id="line.1875">        final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / f));</a>
<span class="sourceLineNo">1876</span><a id="line.1876">        if (l &gt;= n || size &gt; maxFill(l, f)) return true;</a>
<span class="sourceLineNo">1877</span><a id="line.1877">        try {</a>
<span class="sourceLineNo">1878</span><a id="line.1878">            rehash(l);</a>
<span class="sourceLineNo">1879</span><a id="line.1879">        } catch (Exception cantDoIt) {</a>
<span class="sourceLineNo">1880</span><a id="line.1880">            return false;</a>
<span class="sourceLineNo">1881</span><a id="line.1881">        }</a>
<span class="sourceLineNo">1882</span><a id="line.1882">        return true;</a>
<span class="sourceLineNo">1883</span><a id="line.1883">    }</a>
<span class="sourceLineNo">1884</span><a id="line.1884"></a>
<span class="sourceLineNo">1885</span><a id="line.1885">    /**</a>
<span class="sourceLineNo">1886</span><a id="line.1886">     * Rehashes the map.</a>
<span class="sourceLineNo">1887</span><a id="line.1887">     *</a>
<span class="sourceLineNo">1888</span><a id="line.1888">     * &lt;P&gt;</a>
<span class="sourceLineNo">1889</span><a id="line.1889">     * This method implements the basic rehashing strategy, and may be overriden</a>
<span class="sourceLineNo">1890</span><a id="line.1890">     * by subclasses implementing different rehashing strategies (e.g.,</a>
<span class="sourceLineNo">1891</span><a id="line.1891">     * disk-based rehashing). However, you should not override this method</a>
<span class="sourceLineNo">1892</span><a id="line.1892">     * unless you understand the internal workings of this class.</a>
<span class="sourceLineNo">1893</span><a id="line.1893">     *</a>
<span class="sourceLineNo">1894</span><a id="line.1894">     * @param newN</a>
<span class="sourceLineNo">1895</span><a id="line.1895">     *            the new size</a>
<span class="sourceLineNo">1896</span><a id="line.1896">     */</a>
<span class="sourceLineNo">1897</span><a id="line.1897"></a>
<span class="sourceLineNo">1898</span><a id="line.1898">    @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">1899</span><a id="line.1899">    protected void rehash(final int newN) {</a>
<span class="sourceLineNo">1900</span><a id="line.1900">        final K[] key = this.key;</a>
<span class="sourceLineNo">1901</span><a id="line.1901">        final V[] value = this.value;</a>
<span class="sourceLineNo">1902</span><a id="line.1902">        final int mask = newN - 1;</a>
<span class="sourceLineNo">1903</span><a id="line.1903">        final K[] newKey = (K[]) new Object[newN + 1];</a>
<span class="sourceLineNo">1904</span><a id="line.1904">        final V[] newValue = (V[]) new Object[newN + 1];</a>
<span class="sourceLineNo">1905</span><a id="line.1905">        final int sz = order.size;</a>
<span class="sourceLineNo">1906</span><a id="line.1906">        K k;</a>
<span class="sourceLineNo">1907</span><a id="line.1907">        int i, pos;</a>
<span class="sourceLineNo">1908</span><a id="line.1908">        final int[] oi = order.items;</a>
<span class="sourceLineNo">1909</span><a id="line.1909">        for (int q = 0; q &lt; sz; q++) {</a>
<span class="sourceLineNo">1910</span><a id="line.1910">            i = oi[q];</a>
<span class="sourceLineNo">1911</span><a id="line.1911">            if ((k = key[i]) == null)</a>
<span class="sourceLineNo">1912</span><a id="line.1912">                pos = newN;</a>
<span class="sourceLineNo">1913</span><a id="line.1913">            else {</a>
<span class="sourceLineNo">1914</span><a id="line.1914">                pos = (hasher.hash(k)) &amp; mask;</a>
<span class="sourceLineNo">1915</span><a id="line.1915">                while (newKey[pos] != null)</a>
<span class="sourceLineNo">1916</span><a id="line.1916">                    pos = (pos + 1) &amp; mask;</a>
<span class="sourceLineNo">1917</span><a id="line.1917">            }</a>
<span class="sourceLineNo">1918</span><a id="line.1918">            newKey[pos] = k;</a>
<span class="sourceLineNo">1919</span><a id="line.1919">            newValue[pos] = value[i];</a>
<span class="sourceLineNo">1920</span><a id="line.1920">            oi[q] = pos;</a>
<span class="sourceLineNo">1921</span><a id="line.1921">        }</a>
<span class="sourceLineNo">1922</span><a id="line.1922">        n = newN;</a>
<span class="sourceLineNo">1923</span><a id="line.1923">        this.mask = mask;</a>
<span class="sourceLineNo">1924</span><a id="line.1924">        maxFill = maxFill(n, f);</a>
<span class="sourceLineNo">1925</span><a id="line.1925">        this.key = newKey;</a>
<span class="sourceLineNo">1926</span><a id="line.1926">        this.value = newValue;</a>
<span class="sourceLineNo">1927</span><a id="line.1927">    }</a>
<span class="sourceLineNo">1928</span><a id="line.1928">    /*</a>
<span class="sourceLineNo">1929</span><a id="line.1929">    @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">1930</span><a id="line.1930">    protected void rehash(final int newN) {</a>
<span class="sourceLineNo">1931</span><a id="line.1931">        final K key[] = this.key;</a>
<span class="sourceLineNo">1932</span><a id="line.1932">        final V value[] = this.value;</a>
<span class="sourceLineNo">1933</span><a id="line.1933">        final int mask = newN - 1; // Note that this is used by the hashing</a>
<span class="sourceLineNo">1934</span><a id="line.1934">        // macro</a>
<span class="sourceLineNo">1935</span><a id="line.1935">        final K newKey[] = (K[]) new Object[newN + 1];</a>
<span class="sourceLineNo">1936</span><a id="line.1936">        final V newValue[] = (V[]) new Object[newN + 1];</a>
<span class="sourceLineNo">1937</span><a id="line.1937">        int i = first, prev = -1, newPrev = -1, t, pos;</a>
<span class="sourceLineNo">1938</span><a id="line.1938">        final long link[] = this.link;</a>
<span class="sourceLineNo">1939</span><a id="line.1939">        final long newLink[] = new long[newN + 1];</a>
<span class="sourceLineNo">1940</span><a id="line.1940">        first = -1;</a>
<span class="sourceLineNo">1941</span><a id="line.1941">        for (int j = size; j-- != 0;) {</a>
<span class="sourceLineNo">1942</span><a id="line.1942">            if (((key[i]) == null))</a>
<span class="sourceLineNo">1943</span><a id="line.1943">                pos = newN;</a>
<span class="sourceLineNo">1944</span><a id="line.1944">            else {</a>
<span class="sourceLineNo">1945</span><a id="line.1945">                pos = (((key[i]).hashCode())) &amp; mask;</a>
<span class="sourceLineNo">1946</span><a id="line.1946">                while (!((newKey[pos]) == null))</a>
<span class="sourceLineNo">1947</span><a id="line.1947">                    pos = (pos + 1) &amp; mask;</a>
<span class="sourceLineNo">1948</span><a id="line.1948">            }</a>
<span class="sourceLineNo">1949</span><a id="line.1949">            newKey[pos] = key[i];</a>
<span class="sourceLineNo">1950</span><a id="line.1950">            newValue[pos] = value[i];</a>
<span class="sourceLineNo">1951</span><a id="line.1951">            if (prev != -1) {</a>
<span class="sourceLineNo">1952</span><a id="line.1952">                newLink[newPrev] ^= ((newLink[newPrev] ^ (pos &amp; 0xFFFFFFFFL)) &amp; 0xFFFFFFFFL);</a>
<span class="sourceLineNo">1953</span><a id="line.1953">                newLink[pos] ^= ((newLink[pos] ^ ((newPrev &amp; 0xFFFFFFFFL) &lt;&lt; 32)) &amp; 0xFFFFFFFF00000000L);</a>
<span class="sourceLineNo">1954</span><a id="line.1954">                newPrev = pos;</a>
<span class="sourceLineNo">1955</span><a id="line.1955">            } else {</a>
<span class="sourceLineNo">1956</span><a id="line.1956">                newPrev = first = pos;</a>
<span class="sourceLineNo">1957</span><a id="line.1957">                // Special case of SET(newLink[ pos ], -1, -1);</a>
<span class="sourceLineNo">1958</span><a id="line.1958">                newLink[pos] = -1L;</a>
<span class="sourceLineNo">1959</span><a id="line.1959">            }</a>
<span class="sourceLineNo">1960</span><a id="line.1960">            t = i;</a>
<span class="sourceLineNo">1961</span><a id="line.1961">            i = (int) link[i];</a>
<span class="sourceLineNo">1962</span><a id="line.1962">            prev = t;</a>
<span class="sourceLineNo">1963</span><a id="line.1963">        }</a>
<span class="sourceLineNo">1964</span><a id="line.1964">        this.link = newLink;</a>
<span class="sourceLineNo">1965</span><a id="line.1965">        this.last = newPrev;</a>
<span class="sourceLineNo">1966</span><a id="line.1966">        if (newPrev != -1)</a>
<span class="sourceLineNo">1967</span><a id="line.1967">            // Special case of SET_NEXT( newLink[ newPrev ], -1 );</a>
<span class="sourceLineNo">1968</span><a id="line.1968">            newLink[newPrev] |= -1 &amp; 0xFFFFFFFFL;</a>
<span class="sourceLineNo">1969</span><a id="line.1969">        n = newN;</a>
<span class="sourceLineNo">1970</span><a id="line.1970">        this.mask = mask;</a>
<span class="sourceLineNo">1971</span><a id="line.1971">        maxFill = maxFill(n, f);</a>
<span class="sourceLineNo">1972</span><a id="line.1972">        this.key = newKey;</a>
<span class="sourceLineNo">1973</span><a id="line.1973">        this.value = newValue;</a>
<span class="sourceLineNo">1974</span><a id="line.1974">    }</a>
<span class="sourceLineNo">1975</span><a id="line.1975">    */</a>
<span class="sourceLineNo">1976</span><a id="line.1976">    /**</a>
<span class="sourceLineNo">1977</span><a id="line.1977">     * Returns a deep copy of this map.</a>
<span class="sourceLineNo">1978</span><a id="line.1978">     *</a>
<span class="sourceLineNo">1979</span><a id="line.1979">     * &lt;P&gt;</a>
<span class="sourceLineNo">1980</span><a id="line.1980">     * This method performs a deep copy of this OrderedMap; the data stored in the</a>
<span class="sourceLineNo">1981</span><a id="line.1981">     * map, however, is not cloned. Note that this makes a difference only for</a>
<span class="sourceLineNo">1982</span><a id="line.1982">     * object keys.</a>
<span class="sourceLineNo">1983</span><a id="line.1983">     *</a>
<span class="sourceLineNo">1984</span><a id="line.1984">     * @return a deep copy of this map.</a>
<span class="sourceLineNo">1985</span><a id="line.1985">     */</a>
<span class="sourceLineNo">1986</span><a id="line.1986">    @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">1987</span><a id="line.1987">    @GwtIncompatible</a>
<span class="sourceLineNo">1988</span><a id="line.1988">    public OrderedMap&lt;K, V&gt; clone() {</a>
<span class="sourceLineNo">1989</span><a id="line.1989">        OrderedMap&lt;K, V&gt; c;</a>
<span class="sourceLineNo">1990</span><a id="line.1990">        try {</a>
<span class="sourceLineNo">1991</span><a id="line.1991">            c = new OrderedMap&lt;&gt;(hasher);</a>
<span class="sourceLineNo">1992</span><a id="line.1992">            c.key = (K[]) new Object[n + 1];</a>
<span class="sourceLineNo">1993</span><a id="line.1993">            System.arraycopy(key, 0, c.key, 0, n + 1);</a>
<span class="sourceLineNo">1994</span><a id="line.1994">            c.value = (V[]) new Object[n + 1];</a>
<span class="sourceLineNo">1995</span><a id="line.1995">            System.arraycopy(value, 0, c.value, 0, n + 1);</a>
<span class="sourceLineNo">1996</span><a id="line.1996">            c.order = (IntVLA) order.clone();</a>
<span class="sourceLineNo">1997</span><a id="line.1997">            return c;</a>
<span class="sourceLineNo">1998</span><a id="line.1998">        } catch (Exception cantHappen) {</a>
<span class="sourceLineNo">1999</span><a id="line.1999">            throw new UnsupportedOperationException(cantHappen + (cantHappen.getMessage() != null ?</a>
<span class="sourceLineNo">2000</span><a id="line.2000">                    "; " + cantHappen.getMessage() : ""));</a>
<span class="sourceLineNo">2001</span><a id="line.2001">        }</a>
<span class="sourceLineNo">2002</span><a id="line.2002">    }</a>
<span class="sourceLineNo">2003</span><a id="line.2003">    /**</a>
<span class="sourceLineNo">2004</span><a id="line.2004">     * Returns a hash code for this map.</a>
<span class="sourceLineNo">2005</span><a id="line.2005">     *</a>
<span class="sourceLineNo">2006</span><a id="line.2006">     * This method overrides the generic method provided by the superclass.</a>
<span class="sourceLineNo">2007</span><a id="line.2007">     * Since &lt;code&gt;equals()&lt;/code&gt; is not overriden, it is important that the</a>
<span class="sourceLineNo">2008</span><a id="line.2008">     * value returned by this method is the same value as the one returned by</a>
<span class="sourceLineNo">2009</span><a id="line.2009">     * the overriden method.</a>
<span class="sourceLineNo">2010</span><a id="line.2010">     *</a>
<span class="sourceLineNo">2011</span><a id="line.2011">     * @return a hash code for this map.</a>
<span class="sourceLineNo">2012</span><a id="line.2012">     */</a>
<span class="sourceLineNo">2013</span><a id="line.2013">    public int hashCode() {</a>
<span class="sourceLineNo">2014</span><a id="line.2014">        int h = 0;</a>
<span class="sourceLineNo">2015</span><a id="line.2015">        for (int j = realSize(), i = 0, t = 0; j-- != 0;) {</a>
<span class="sourceLineNo">2016</span><a id="line.2016">            while (key[i] == null)</a>
<span class="sourceLineNo">2017</span><a id="line.2017">                i++;</a>
<span class="sourceLineNo">2018</span><a id="line.2018">            if (this != key[i])</a>
<span class="sourceLineNo">2019</span><a id="line.2019">                t = hasher.hash(key[i]);</a>
<span class="sourceLineNo">2020</span><a id="line.2020">            if (this != value[i])</a>
<span class="sourceLineNo">2021</span><a id="line.2021">                t ^= value[i] == null ? 0 : value[i].hashCode();</a>
<span class="sourceLineNo">2022</span><a id="line.2022">            h += t;</a>
<span class="sourceLineNo">2023</span><a id="line.2023">            i++;</a>
<span class="sourceLineNo">2024</span><a id="line.2024">        }</a>
<span class="sourceLineNo">2025</span><a id="line.2025">        // Zero / null keys have hash zero.</a>
<span class="sourceLineNo">2026</span><a id="line.2026">        if (containsNullKey)</a>
<span class="sourceLineNo">2027</span><a id="line.2027">            h += value[n] == null ? 0 : value[n].hashCode();</a>
<span class="sourceLineNo">2028</span><a id="line.2028">        return h;</a>
<span class="sourceLineNo">2029</span><a id="line.2029">    }</a>
<span class="sourceLineNo">2030</span><a id="line.2030"></a>
<span class="sourceLineNo">2031</span><a id="line.2031">    public long hash64()</a>
<span class="sourceLineNo">2032</span><a id="line.2032">    {</a>
<span class="sourceLineNo">2033</span><a id="line.2033">        return 31L * (31L * CrossHash.hash64(key) + CrossHash.hash64(value)) + size;</a>
<span class="sourceLineNo">2034</span><a id="line.2034">    }</a>
<span class="sourceLineNo">2035</span><a id="line.2035">    /**</a>
<span class="sourceLineNo">2036</span><a id="line.2036">     * Returns the maximum number of entries that can be filled before rehashing.</a>
<span class="sourceLineNo">2037</span><a id="line.2037">     *</a>
<span class="sourceLineNo">2038</span><a id="line.2038">     * @param n the size of the backing array.</a>
<span class="sourceLineNo">2039</span><a id="line.2039">     * @param f the load factor.</a>
<span class="sourceLineNo">2040</span><a id="line.2040">     * @return the maximum number of entries before rehashing.</a>
<span class="sourceLineNo">2041</span><a id="line.2041">     */</a>
<span class="sourceLineNo">2042</span><a id="line.2042">    public static int maxFill(final int n, final float f) {</a>
<span class="sourceLineNo">2043</span><a id="line.2043">        /* We must guarantee that there is always at least</a>
<span class="sourceLineNo">2044</span><a id="line.2044">         * one free entry (even with pathological load factors). */</a>
<span class="sourceLineNo">2045</span><a id="line.2045">        return Math.min((int)(n * f + 0.99999994f), n - 1);</a>
<span class="sourceLineNo">2046</span><a id="line.2046">    }</a>
<span class="sourceLineNo">2047</span><a id="line.2047"></a>
<span class="sourceLineNo">2048</span><a id="line.2048">    /**</a>
<span class="sourceLineNo">2049</span><a id="line.2049">     * Returns the least power of two smaller than or equal to 2&lt;sup&gt;30&lt;/sup&gt; and larger than or equal to &lt;code&gt;Math.ceil( expected / f )&lt;/code&gt;.</a>
<span class="sourceLineNo">2050</span><a id="line.2050">     *</a>
<span class="sourceLineNo">2051</span><a id="line.2051">     * @param expected the expected number of elements in a hash table.</a>
<span class="sourceLineNo">2052</span><a id="line.2052">     * @param f        the load factor.</a>
<span class="sourceLineNo">2053</span><a id="line.2053">     * @return the minimum possible size for a backing array.</a>
<span class="sourceLineNo">2054</span><a id="line.2054">     * @throws IllegalArgumentException if the necessary size is larger than 2&lt;sup&gt;30&lt;/sup&gt;.</a>
<span class="sourceLineNo">2055</span><a id="line.2055">     */</a>
<span class="sourceLineNo">2056</span><a id="line.2056">    public static int arraySize(final int expected, final float f) {</a>
<span class="sourceLineNo">2057</span><a id="line.2057">        final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));</a>
<span class="sourceLineNo">2058</span><a id="line.2058">        if (s &gt; (1 &lt;&lt; 30))</a>
<span class="sourceLineNo">2059</span><a id="line.2059">            throw new IllegalArgumentException("Too large (" + expected + " expected elements with load factor " + f + ")");</a>
<span class="sourceLineNo">2060</span><a id="line.2060">        return (int) s;</a>
<span class="sourceLineNo">2061</span><a id="line.2061">    }</a>
<span class="sourceLineNo">2062</span><a id="line.2062"></a>
<span class="sourceLineNo">2063</span><a id="line.2063">    /**</a>
<span class="sourceLineNo">2064</span><a id="line.2064">     * Unwraps an iterator into an array starting at a given offset for a given number of elements.</a>
<span class="sourceLineNo">2065</span><a id="line.2065">     * &lt;p&gt;</a>
<span class="sourceLineNo">2066</span><a id="line.2066">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</a>
<span class="sourceLineNo">2067</span><a id="line.2067">     * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</a>
<span class="sourceLineNo">2068</span><a id="line.2068">     *</a>
<span class="sourceLineNo">2069</span><a id="line.2069">     * @param i      a type-specific iterator.</a>
<span class="sourceLineNo">2070</span><a id="line.2070">     * @param array  an array to contain the output of the iterator.</a>
<span class="sourceLineNo">2071</span><a id="line.2071">     * @param offset the first element of the array to be returned.</a>
<span class="sourceLineNo">2072</span><a id="line.2072">     * @param max    the maximum number of elements to unwrap.</a>
<span class="sourceLineNo">2073</span><a id="line.2073">     * @return the number of elements unwrapped.</a>
<span class="sourceLineNo">2074</span><a id="line.2074">     */</a>
<span class="sourceLineNo">2075</span><a id="line.2075">    protected int unwrap(final ValueIterator i, final Object[] array, int offset, final int max) {</a>
<span class="sourceLineNo">2076</span><a id="line.2076">        if (max &lt; 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");</a>
<span class="sourceLineNo">2077</span><a id="line.2077">        if (offset &lt; 0 || offset + max &gt; array.length) throw new IllegalArgumentException();</a>
<span class="sourceLineNo">2078</span><a id="line.2078">        int j = max;</a>
<span class="sourceLineNo">2079</span><a id="line.2079">        while (j-- != 0 &amp;&amp; i.hasNext())</a>
<span class="sourceLineNo">2080</span><a id="line.2080">            array[offset++] = i.next();</a>
<span class="sourceLineNo">2081</span><a id="line.2081">        return max - j - 1;</a>
<span class="sourceLineNo">2082</span><a id="line.2082">    }</a>
<span class="sourceLineNo">2083</span><a id="line.2083"></a>
<span class="sourceLineNo">2084</span><a id="line.2084">    /**</a>
<span class="sourceLineNo">2085</span><a id="line.2085">     * Unwraps an iterator into an array.</a>
<span class="sourceLineNo">2086</span><a id="line.2086">     * &lt;p&gt;</a>
<span class="sourceLineNo">2087</span><a id="line.2087">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</a>
<span class="sourceLineNo">2088</span><a id="line.2088">     * of the array has been reached.</a>
<span class="sourceLineNo">2089</span><a id="line.2089">     *</a>
<span class="sourceLineNo">2090</span><a id="line.2090">     * @param i     a type-specific iterator.</a>
<span class="sourceLineNo">2091</span><a id="line.2091">     * @param array an array to contain the output of the iterator.</a>
<span class="sourceLineNo">2092</span><a id="line.2092">     * @return the number of elements unwrapped.</a>
<span class="sourceLineNo">2093</span><a id="line.2093">     */</a>
<span class="sourceLineNo">2094</span><a id="line.2094">    protected int unwrap(final ValueIterator i, final Object[] array) {</a>
<span class="sourceLineNo">2095</span><a id="line.2095">        return unwrap(i, array, 0, array.length);</a>
<span class="sourceLineNo">2096</span><a id="line.2096">    }</a>
<span class="sourceLineNo">2097</span><a id="line.2097"></a>
<span class="sourceLineNo">2098</span><a id="line.2098"></a>
<span class="sourceLineNo">2099</span><a id="line.2099">    /** Unwraps an iterator into an array starting at a given offset for a given number of elements.</a>
<span class="sourceLineNo">2100</span><a id="line.2100">     *</a>
<span class="sourceLineNo">2101</span><a id="line.2101">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The</a>
<span class="sourceLineNo">2102</span><a id="line.2102">     * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).</a>
<span class="sourceLineNo">2103</span><a id="line.2103">     *</a>
<span class="sourceLineNo">2104</span><a id="line.2104">     * @param i a type-specific iterator.</a>
<span class="sourceLineNo">2105</span><a id="line.2105">     * @param array an array to contain the output of the iterator.</a>
<span class="sourceLineNo">2106</span><a id="line.2106">     * @param offset the first element of the array to be returned.</a>
<span class="sourceLineNo">2107</span><a id="line.2107">     * @param max the maximum number of elements to unwrap.</a>
<span class="sourceLineNo">2108</span><a id="line.2108">     * @return the number of elements unwrapped. */</a>
<span class="sourceLineNo">2109</span><a id="line.2109">    protected static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array, int offset, final int max ) {</a>
<span class="sourceLineNo">2110</span><a id="line.2110">        if ( max &lt; 0 ) throw new IllegalArgumentException( "The maximum number of elements (" + max + ") is negative" );</a>
<span class="sourceLineNo">2111</span><a id="line.2111">        if ( offset &lt; 0 || offset + max &gt; array.length ) throw new IllegalArgumentException();</a>
<span class="sourceLineNo">2112</span><a id="line.2112">        int j = max;</a>
<span class="sourceLineNo">2113</span><a id="line.2113">        while ( j-- != 0 &amp;&amp; i.hasNext() )</a>
<span class="sourceLineNo">2114</span><a id="line.2114">            array[ offset++ ] = i.next();</a>
<span class="sourceLineNo">2115</span><a id="line.2115">        return max - j - 1;</a>
<span class="sourceLineNo">2116</span><a id="line.2116">    }</a>
<span class="sourceLineNo">2117</span><a id="line.2117"></a>
<span class="sourceLineNo">2118</span><a id="line.2118">    /** Unwraps an iterator into an array.</a>
<span class="sourceLineNo">2119</span><a id="line.2119">     *</a>
<span class="sourceLineNo">2120</span><a id="line.2120">     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end</a>
<span class="sourceLineNo">2121</span><a id="line.2121">     * of the array has been reached.</a>
<span class="sourceLineNo">2122</span><a id="line.2122">     *</a>
<span class="sourceLineNo">2123</span><a id="line.2123">     * @param i a type-specific iterator.</a>
<span class="sourceLineNo">2124</span><a id="line.2124">     * @param array an array to contain the output of the iterator.</a>
<span class="sourceLineNo">2125</span><a id="line.2125">     * @return the number of elements unwrapped. */</a>
<span class="sourceLineNo">2126</span><a id="line.2126">    protected static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array) {</a>
<span class="sourceLineNo">2127</span><a id="line.2127">        return objectUnwrap(i, array, 0, array.length );</a>
<span class="sourceLineNo">2128</span><a id="line.2128">    }</a>
<span class="sourceLineNo">2129</span><a id="line.2129"></a>
<span class="sourceLineNo">2130</span><a id="line.2130">    @Override</a>
<span class="sourceLineNo">2131</span><a id="line.2131">    public String toString() {</a>
<span class="sourceLineNo">2132</span><a id="line.2132">        final StringBuilder s = new StringBuilder();</a>
<span class="sourceLineNo">2133</span><a id="line.2133">        int n = size(), i = 0;</a>
<span class="sourceLineNo">2134</span><a id="line.2134">        boolean first = true;</a>
<span class="sourceLineNo">2135</span><a id="line.2135">        K k;</a>
<span class="sourceLineNo">2136</span><a id="line.2136">        V v;</a>
<span class="sourceLineNo">2137</span><a id="line.2137">        s.append("OrderedMap{");</a>
<span class="sourceLineNo">2138</span><a id="line.2138">        while (i &lt; n) {</a>
<span class="sourceLineNo">2139</span><a id="line.2139">            if (first) first = false;</a>
<span class="sourceLineNo">2140</span><a id="line.2140">            else s.append(", ");</a>
<span class="sourceLineNo">2141</span><a id="line.2141">            k = keyAt(i);</a>
<span class="sourceLineNo">2142</span><a id="line.2142">            v = getAt(i++);</a>
<span class="sourceLineNo">2143</span><a id="line.2143">            s.append(k == this ? "(this collection)" : String.valueOf(k))</a>
<span class="sourceLineNo">2144</span><a id="line.2144">                    .append("=&gt;")</a>
<span class="sourceLineNo">2145</span><a id="line.2145">                    .append(v == this ? "(this collection)" : String.valueOf(v));</a>
<span class="sourceLineNo">2146</span><a id="line.2146">        }</a>
<span class="sourceLineNo">2147</span><a id="line.2147">        s.append("}");</a>
<span class="sourceLineNo">2148</span><a id="line.2148">        return s.toString();</a>
<span class="sourceLineNo">2149</span><a id="line.2149">    }</a>
<span class="sourceLineNo">2150</span><a id="line.2150">    @Override</a>
<span class="sourceLineNo">2151</span><a id="line.2151">    public boolean equals(Object o) {</a>
<span class="sourceLineNo">2152</span><a id="line.2152">        if (o == this)</a>
<span class="sourceLineNo">2153</span><a id="line.2153">            return true;</a>
<span class="sourceLineNo">2154</span><a id="line.2154">        if (!(o instanceof Map))</a>
<span class="sourceLineNo">2155</span><a id="line.2155">            return false;</a>
<span class="sourceLineNo">2156</span><a id="line.2156">        Map&lt;?, ?&gt; m = (Map&lt;?, ?&gt;) o;</a>
<span class="sourceLineNo">2157</span><a id="line.2157">        if (m.size() != size())</a>
<span class="sourceLineNo">2158</span><a id="line.2158">            return false;</a>
<span class="sourceLineNo">2159</span><a id="line.2159">        return entrySet().containsAll(m.entrySet());</a>
<span class="sourceLineNo">2160</span><a id="line.2160">    }</a>
<span class="sourceLineNo">2161</span><a id="line.2161"></a>
<span class="sourceLineNo">2162</span><a id="line.2162">    @GwtIncompatible</a>
<span class="sourceLineNo">2163</span><a id="line.2163">    private void writeObject(java.io.ObjectOutputStream s)</a>
<span class="sourceLineNo">2164</span><a id="line.2164">            throws java.io.IOException {</a>
<span class="sourceLineNo">2165</span><a id="line.2165">        final K[] key = this.key;</a>
<span class="sourceLineNo">2166</span><a id="line.2166">        final V[] value = this.value;</a>
<span class="sourceLineNo">2167</span><a id="line.2167">        final MapIterator i = new MapIterator();</a>
<span class="sourceLineNo">2168</span><a id="line.2168">        s.defaultWriteObject();</a>
<span class="sourceLineNo">2169</span><a id="line.2169">        for (int j = size, e; j-- != 0;) {</a>
<span class="sourceLineNo">2170</span><a id="line.2170">            e = i.nextEntry();</a>
<span class="sourceLineNo">2171</span><a id="line.2171">            s.writeObject(key[e]);</a>
<span class="sourceLineNo">2172</span><a id="line.2172">            s.writeObject(value[e]);</a>
<span class="sourceLineNo">2173</span><a id="line.2173">        }</a>
<span class="sourceLineNo">2174</span><a id="line.2174">    }</a>
<span class="sourceLineNo">2175</span><a id="line.2175">    @GwtIncompatible</a>
<span class="sourceLineNo">2176</span><a id="line.2176">    @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">2177</span><a id="line.2177">    private void readObject(java.io.ObjectInputStream s)</a>
<span class="sourceLineNo">2178</span><a id="line.2178">            throws java.io.IOException, ClassNotFoundException {</a>
<span class="sourceLineNo">2179</span><a id="line.2179">        s.defaultReadObject();</a>
<span class="sourceLineNo">2180</span><a id="line.2180">        n = arraySize(size, f);</a>
<span class="sourceLineNo">2181</span><a id="line.2181">        maxFill = maxFill(n, f);</a>
<span class="sourceLineNo">2182</span><a id="line.2182">        mask = n - 1;</a>
<span class="sourceLineNo">2183</span><a id="line.2183">        final K[] key = this.key = (K[]) new Object[n + 1];</a>
<span class="sourceLineNo">2184</span><a id="line.2184">        final V[] value = this.value = (V[]) new Object[n + 1];</a>
<span class="sourceLineNo">2185</span><a id="line.2185">        final IntVLA order = this.order = new IntVLA(n + 1);</a>
<span class="sourceLineNo">2186</span><a id="line.2186">        K k;</a>
<span class="sourceLineNo">2187</span><a id="line.2187">        V v;</a>
<span class="sourceLineNo">2188</span><a id="line.2188">        for (int i = size, pos; i-- != 0;) {</a>
<span class="sourceLineNo">2189</span><a id="line.2189">            k = (K) s.readObject();</a>
<span class="sourceLineNo">2190</span><a id="line.2190">            v = (V) s.readObject();</a>
<span class="sourceLineNo">2191</span><a id="line.2191">            if (k == null) {</a>
<span class="sourceLineNo">2192</span><a id="line.2192">                pos = n;</a>
<span class="sourceLineNo">2193</span><a id="line.2193">                containsNullKey = true;</a>
<span class="sourceLineNo">2194</span><a id="line.2194">            } else {</a>
<span class="sourceLineNo">2195</span><a id="line.2195">                pos = (hasher.hash(k))</a>
<span class="sourceLineNo">2196</span><a id="line.2196">                        &amp; mask;</a>
<span class="sourceLineNo">2197</span><a id="line.2197">                while (!(key[pos] == null))</a>
<span class="sourceLineNo">2198</span><a id="line.2198">                    pos = (pos + 1) &amp; mask;</a>
<span class="sourceLineNo">2199</span><a id="line.2199">            }</a>
<span class="sourceLineNo">2200</span><a id="line.2200"></a>
<span class="sourceLineNo">2201</span><a id="line.2201">            key[pos] = k;</a>
<span class="sourceLineNo">2202</span><a id="line.2202">            value[pos] = v;</a>
<span class="sourceLineNo">2203</span><a id="line.2203">            order.add(pos);</a>
<span class="sourceLineNo">2204</span><a id="line.2204">        }</a>
<span class="sourceLineNo">2205</span><a id="line.2205">    }</a>
<span class="sourceLineNo">2206</span><a id="line.2206"></a>
<span class="sourceLineNo">2207</span><a id="line.2207">    /**</a>
<span class="sourceLineNo">2208</span><a id="line.2208">     * Gets the value at the given index in the iteration order in constant time (random-access).</a>
<span class="sourceLineNo">2209</span><a id="line.2209">     * @param idx the index in the iteration order of the value to fetch</a>
<span class="sourceLineNo">2210</span><a id="line.2210">     * @return the value at the index, if the index is valid, otherwise the default return value</a>
<span class="sourceLineNo">2211</span><a id="line.2211">     */</a>
<span class="sourceLineNo">2212</span><a id="line.2212">    public V getAt(final int idx) {</a>
<span class="sourceLineNo">2213</span><a id="line.2213">        int pos;</a>
<span class="sourceLineNo">2214</span><a id="line.2214">        if (idx &lt; 0 || idx &gt;= order.size)</a>
<span class="sourceLineNo">2215</span><a id="line.2215">            return defRetValue;</a>
<span class="sourceLineNo">2216</span><a id="line.2216">        // The starting point.</a>
<span class="sourceLineNo">2217</span><a id="line.2217">        if (key[pos = order.get(idx)] == null)</a>
<span class="sourceLineNo">2218</span><a id="line.2218">            return containsNullKey ? value[n] : defRetValue;</a>
<span class="sourceLineNo">2219</span><a id="line.2219">        return value[pos];</a>
<span class="sourceLineNo">2220</span><a id="line.2220">    }</a>
<span class="sourceLineNo">2221</span><a id="line.2221">    /**</a>
<span class="sourceLineNo">2222</span><a id="line.2222">     * Gets the key at the given index in the iteration order in constant time (random-access).</a>
<span class="sourceLineNo">2223</span><a id="line.2223">     * @param idx the index in the iteration order of the key to fetch</a>
<span class="sourceLineNo">2224</span><a id="line.2224">     * @return the key at the index, if the index is valid, otherwise null</a>
<span class="sourceLineNo">2225</span><a id="line.2225">     */</a>
<span class="sourceLineNo">2226</span><a id="line.2226">    public K keyAt(final int idx) {</a>
<span class="sourceLineNo">2227</span><a id="line.2227">        if (idx &lt; 0 || idx &gt;= order.size)</a>
<span class="sourceLineNo">2228</span><a id="line.2228">            return null;</a>
<span class="sourceLineNo">2229</span><a id="line.2229">        // The starting point.</a>
<span class="sourceLineNo">2230</span><a id="line.2230">        return key[order.get(idx)];</a>
<span class="sourceLineNo">2231</span><a id="line.2231">    }</a>
<span class="sourceLineNo">2232</span><a id="line.2232"></a>
<span class="sourceLineNo">2233</span><a id="line.2233">    /**</a>
<span class="sourceLineNo">2234</span><a id="line.2234">     * Gets the key-value Map.Entry at the given index in the iteration order in constant time (random-access).</a>
<span class="sourceLineNo">2235</span><a id="line.2235">     * @param idx the index in the iteration order of the entry to fetch</a>
<span class="sourceLineNo">2236</span><a id="line.2236">     * @return the key-value entry at the index, if the index is valid, otherwise null</a>
<span class="sourceLineNo">2237</span><a id="line.2237">     */</a>
<span class="sourceLineNo">2238</span><a id="line.2238">    public Entry&lt;K, V&gt; entryAt(final int idx)</a>
<span class="sourceLineNo">2239</span><a id="line.2239">    {</a>
<span class="sourceLineNo">2240</span><a id="line.2240">        if (idx &lt; 0 || idx &gt;= order.size)</a>
<span class="sourceLineNo">2241</span><a id="line.2241">            return null;</a>
<span class="sourceLineNo">2242</span><a id="line.2242">        return new MapEntry(order.get(idx));</a>
<span class="sourceLineNo">2243</span><a id="line.2243">    }</a>
<span class="sourceLineNo">2244</span><a id="line.2244"></a>
<span class="sourceLineNo">2245</span><a id="line.2245">    /**</a>
<span class="sourceLineNo">2246</span><a id="line.2246">     * Removes the key and value at the given index in the iteration order in not-exactly constant time (though it still</a>
<span class="sourceLineNo">2247</span><a id="line.2247">     * should be efficient).</a>
<span class="sourceLineNo">2248</span><a id="line.2248">     * @param idx the index in the iteration order of the key and value to remove</a>
<span class="sourceLineNo">2249</span><a id="line.2249">     * @return the value removed, if there was anything removed, or the default return value otherwise (often null)</a>
<span class="sourceLineNo">2250</span><a id="line.2250">     */</a>
<span class="sourceLineNo">2251</span><a id="line.2251">    public V removeAt(final int idx) {</a>
<span class="sourceLineNo">2252</span><a id="line.2252"></a>
<span class="sourceLineNo">2253</span><a id="line.2253">        if (idx &lt; 0 || idx &gt;= order.size)</a>
<span class="sourceLineNo">2254</span><a id="line.2254">            return defRetValue;</a>
<span class="sourceLineNo">2255</span><a id="line.2255">        int pos = order.get(idx);</a>
<span class="sourceLineNo">2256</span><a id="line.2256">        if (key[pos] == null) {</a>
<span class="sourceLineNo">2257</span><a id="line.2257">            if (containsNullKey)</a>
<span class="sourceLineNo">2258</span><a id="line.2258">                return removeNullEntry();</a>
<span class="sourceLineNo">2259</span><a id="line.2259">            return defRetValue;</a>
<span class="sourceLineNo">2260</span><a id="line.2260">        }</a>
<span class="sourceLineNo">2261</span><a id="line.2261">        return removeEntry(pos);</a>
<span class="sourceLineNo">2262</span><a id="line.2262">    }</a>
<span class="sourceLineNo">2263</span><a id="line.2263">    /**</a>
<span class="sourceLineNo">2264</span><a id="line.2264">     * Gets a random value from this OrderedMap in constant time, using the given IRNG to generate a random number.</a>
<span class="sourceLineNo">2265</span><a id="line.2265">     * @param rng used to generate a random index for a value</a>
<span class="sourceLineNo">2266</span><a id="line.2266">     * @return a random value from this OrderedMap</a>
<span class="sourceLineNo">2267</span><a id="line.2267">     */</a>
<span class="sourceLineNo">2268</span><a id="line.2268">    public V randomValue(IRNG rng)</a>
<span class="sourceLineNo">2269</span><a id="line.2269">    {</a>
<span class="sourceLineNo">2270</span><a id="line.2270">        return getAt(rng.nextInt(order.size));</a>
<span class="sourceLineNo">2271</span><a id="line.2271">    }</a>
<span class="sourceLineNo">2272</span><a id="line.2272"></a>
<span class="sourceLineNo">2273</span><a id="line.2273">    /**</a>
<span class="sourceLineNo">2274</span><a id="line.2274">     * Gets a random key from this OrderedMap in constant time, using the given IRNG to generate a random number.</a>
<span class="sourceLineNo">2275</span><a id="line.2275">     * @param rng used to generate a random index for a key</a>
<span class="sourceLineNo">2276</span><a id="line.2276">     * @return a random key from this OrderedMap</a>
<span class="sourceLineNo">2277</span><a id="line.2277">     */</a>
<span class="sourceLineNo">2278</span><a id="line.2278">    public K randomKey(IRNG rng)</a>
<span class="sourceLineNo">2279</span><a id="line.2279">    {</a>
<span class="sourceLineNo">2280</span><a id="line.2280">        return keyAt(rng.nextInt(order.size));</a>
<span class="sourceLineNo">2281</span><a id="line.2281">    }</a>
<span class="sourceLineNo">2282</span><a id="line.2282"></a>
<span class="sourceLineNo">2283</span><a id="line.2283">    /**</a>
<span class="sourceLineNo">2284</span><a id="line.2284">     * Gets a random entry from this OrderedMap in constant time, using the given IRNG to generate a random number.</a>
<span class="sourceLineNo">2285</span><a id="line.2285">     * @param rng used to generate a random index for a entry</a>
<span class="sourceLineNo">2286</span><a id="line.2286">     * @return a random key-value entry from this OrderedMap</a>
<span class="sourceLineNo">2287</span><a id="line.2287">     */</a>
<span class="sourceLineNo">2288</span><a id="line.2288">    public Entry&lt;K, V&gt; randomEntry(IRNG rng)</a>
<span class="sourceLineNo">2289</span><a id="line.2289">    {</a>
<span class="sourceLineNo">2290</span><a id="line.2290">        return new MapEntry(order.getRandomElement(rng));</a>
<span class="sourceLineNo">2291</span><a id="line.2291">    }</a>
<span class="sourceLineNo">2292</span><a id="line.2292"></a>
<span class="sourceLineNo">2293</span><a id="line.2293">    /**</a>
<span class="sourceLineNo">2294</span><a id="line.2294">     * Randomly alters the iteration order for this OrderedMap using the given IRNG to shuffle.</a>
<span class="sourceLineNo">2295</span><a id="line.2295">     * @param rng used to generate a random ordering</a>
<span class="sourceLineNo">2296</span><a id="line.2296">     * @return this for chaining</a>
<span class="sourceLineNo">2297</span><a id="line.2297">     */</a>
<span class="sourceLineNo">2298</span><a id="line.2298">    public OrderedMap&lt;K, V&gt; shuffle(IRNG rng)</a>
<span class="sourceLineNo">2299</span><a id="line.2299">    {</a>
<span class="sourceLineNo">2300</span><a id="line.2300">        if(size &lt; 2)</a>
<span class="sourceLineNo">2301</span><a id="line.2301">            return this;</a>
<span class="sourceLineNo">2302</span><a id="line.2302">        order.shuffle(rng);</a>
<span class="sourceLineNo">2303</span><a id="line.2303">        return this;</a>
<span class="sourceLineNo">2304</span><a id="line.2304">    }</a>
<span class="sourceLineNo">2305</span><a id="line.2305"></a>
<span class="sourceLineNo">2306</span><a id="line.2306">    /**</a>
<span class="sourceLineNo">2307</span><a id="line.2307">     * Given an array or varargs of replacement indices for this OrderedMap's iteration order, reorders this so the</a>
<span class="sourceLineNo">2308</span><a id="line.2308">     * first item in the returned version is the same as {@code getAt(ordering[0])} (with some care taken for negative</a>
<span class="sourceLineNo">2309</span><a id="line.2309">     * or too-large indices), the second item in the returned version is the same as {@code getAt(ordering[1])}, etc.</a>
<span class="sourceLineNo">2310</span><a id="line.2310">     * &lt;br&gt;</a>
<span class="sourceLineNo">2311</span><a id="line.2311">     * Negative indices are considered reversed distances from the end of ordering, so -1 refers to the same index as</a>
<span class="sourceLineNo">2312</span><a id="line.2312">     * {@code ordering[ordering.length - 1]}. If ordering is smaller than {@code size()}, only the indices up to the</a>
<span class="sourceLineNo">2313</span><a id="line.2313">     * length of ordering will be modified. If ordering is larger than {@code size()}, only as many indices will be</a>
<span class="sourceLineNo">2314</span><a id="line.2314">     * affected as {@code size()}, and reversed distances are measured from the end of this Map's entries instead of</a>
<span class="sourceLineNo">2315</span><a id="line.2315">     * the end of ordering. Duplicate values in ordering will produce duplicate values in the returned Map.</a>
<span class="sourceLineNo">2316</span><a id="line.2316">     * &lt;br&gt;</a>
<span class="sourceLineNo">2317</span><a id="line.2317">     * This method modifies this OrderedMap in-place and also returns it for chaining.</a>
<span class="sourceLineNo">2318</span><a id="line.2318">     * @param ordering an array or varargs of int indices, where the nth item in ordering changes the nth item in this</a>
<span class="sourceLineNo">2319</span><a id="line.2319">     *                 Map to have the value currently in this Map at the index specified by the value in ordering</a>
<span class="sourceLineNo">2320</span><a id="line.2320">     * @return this for chaining, after modifying it in-place</a>
<span class="sourceLineNo">2321</span><a id="line.2321">     */</a>
<span class="sourceLineNo">2322</span><a id="line.2322">    public OrderedMap&lt;K, V&gt; reorder(int... ordering)</a>
<span class="sourceLineNo">2323</span><a id="line.2323">    {</a>
<span class="sourceLineNo">2324</span><a id="line.2324">        order.reorder(ordering);</a>
<span class="sourceLineNo">2325</span><a id="line.2325">        return this;</a>
<span class="sourceLineNo">2326</span><a id="line.2326">    }</a>
<span class="sourceLineNo">2327</span><a id="line.2327">    private int alterEntry(final int pos) {</a>
<span class="sourceLineNo">2328</span><a id="line.2328">        int idx = fixOrder(pos);</a>
<span class="sourceLineNo">2329</span><a id="line.2329">        value[pos] = null;</a>
<span class="sourceLineNo">2330</span><a id="line.2330">        size--;</a>
<span class="sourceLineNo">2331</span><a id="line.2331">        shiftKeys(pos);</a>
<span class="sourceLineNo">2332</span><a id="line.2332">        return idx;</a>
<span class="sourceLineNo">2333</span><a id="line.2333">    }</a>
<span class="sourceLineNo">2334</span><a id="line.2334">    private int alterNullEntry() {</a>
<span class="sourceLineNo">2335</span><a id="line.2335">        int idx = fixOrder(n);</a>
<span class="sourceLineNo">2336</span><a id="line.2336">        containsNullKey = false;</a>
<span class="sourceLineNo">2337</span><a id="line.2337">        value[n] = null;</a>
<span class="sourceLineNo">2338</span><a id="line.2338">        size--;</a>
<span class="sourceLineNo">2339</span><a id="line.2339">        return idx;</a>
<span class="sourceLineNo">2340</span><a id="line.2340">    }</a>
<span class="sourceLineNo">2341</span><a id="line.2341">    /**</a>
<span class="sourceLineNo">2342</span><a id="line.2342">     * Swaps a key, original, for another key, replacement, while keeping replacement at the same point in the iteration</a>
<span class="sourceLineNo">2343</span><a id="line.2343">     * order as original and keeping it associated with the same value (which also keeps its iteration index). Unlike</a>
<span class="sourceLineNo">2344</span><a id="line.2344">     * the similar method {@link #alter(Object, Object)}, this will not change this OrderedMap if replacement is already</a>
<span class="sourceLineNo">2345</span><a id="line.2345">     * present. To contrast, alter() can reduce the size of the OrderedMap if both original and replacement are already</a>
<span class="sourceLineNo">2346</span><a id="line.2346">     * in the Map. If replacement is found, this returns the default return value, otherwise it switches out original</a>
<span class="sourceLineNo">2347</span><a id="line.2347">     * for replacement and returns whatever was associated with original.</a>
<span class="sourceLineNo">2348</span><a id="line.2348">     * @param original the key to find and swap out</a>
<span class="sourceLineNo">2349</span><a id="line.2349">     * @param replacement the key to replace original with</a>
<span class="sourceLineNo">2350</span><a id="line.2350">     * @return the value associated with original before, and replacement now</a>
<span class="sourceLineNo">2351</span><a id="line.2351">     */</a>
<span class="sourceLineNo">2352</span><a id="line.2352">    public V alterCarefully(final K original, final K replacement) {</a>
<span class="sourceLineNo">2353</span><a id="line.2353">        if(!containsKey(replacement))</a>
<span class="sourceLineNo">2354</span><a id="line.2354">            return alter(original, replacement);</a>
<span class="sourceLineNo">2355</span><a id="line.2355">        else</a>
<span class="sourceLineNo">2356</span><a id="line.2356">            return defRetValue;</a>
<span class="sourceLineNo">2357</span><a id="line.2357">    }</a>
<span class="sourceLineNo">2358</span><a id="line.2358">    /**</a>
<span class="sourceLineNo">2359</span><a id="line.2359">     * Swaps a key, original, for another key, replacement, while keeping replacement at the same point in the iteration</a>
<span class="sourceLineNo">2360</span><a id="line.2360">     * order as original and keeping it associated with the same value (which also keeps its iteration index).</a>
<span class="sourceLineNo">2361</span><a id="line.2361">     * Be aware that if both original and replacement are present in the OrderedMap, this will still replace original</a>
<span class="sourceLineNo">2362</span><a id="line.2362">     * with replacement but will also remove the other occurrence of replacement to avoid duplicate keys. This can throw</a>
<span class="sourceLineNo">2363</span><a id="line.2363">     * off the expected order because the duplicate could be at any point in the ordering when it is removed. You may</a>
<span class="sourceLineNo">2364</span><a id="line.2364">     * want to prefer {@link #alterCarefully(Object, Object)} if you don't feel like checking by hand for whether</a>
<span class="sourceLineNo">2365</span><a id="line.2365">     * replacement is already present, but using this method is perfectly reasonable if you know overlaps won't happen.</a>
<span class="sourceLineNo">2366</span><a id="line.2366">     * @param original the key to find and swap out</a>
<span class="sourceLineNo">2367</span><a id="line.2367">     * @param replacement the key to replace original with</a>
<span class="sourceLineNo">2368</span><a id="line.2368">     * @return the value associated with original before, and replacement now</a>
<span class="sourceLineNo">2369</span><a id="line.2369">     */</a>
<span class="sourceLineNo">2370</span><a id="line.2370">    public V alter(final K original, final K replacement) {</a>
<span class="sourceLineNo">2371</span><a id="line.2371">        V v;</a>
<span class="sourceLineNo">2372</span><a id="line.2372">        int idx;</a>
<span class="sourceLineNo">2373</span><a id="line.2373">        if (original == null) {</a>
<span class="sourceLineNo">2374</span><a id="line.2374">            if (containsNullKey) {</a>
<span class="sourceLineNo">2375</span><a id="line.2375">                v = value[n];</a>
<span class="sourceLineNo">2376</span><a id="line.2376">                idx = alterNullEntry();</a>
<span class="sourceLineNo">2377</span><a id="line.2377">                putAt(replacement, v, idx);</a>
<span class="sourceLineNo">2378</span><a id="line.2378">                return v;</a>
<span class="sourceLineNo">2379</span><a id="line.2379">            }</a>
<span class="sourceLineNo">2380</span><a id="line.2380">            else</a>
<span class="sourceLineNo">2381</span><a id="line.2381">                v = defRetValue;</a>
<span class="sourceLineNo">2382</span><a id="line.2382">            return v;</a>
<span class="sourceLineNo">2383</span><a id="line.2383">        }</a>
<span class="sourceLineNo">2384</span><a id="line.2384">        K curr;</a>
<span class="sourceLineNo">2385</span><a id="line.2385">        final K[] key = this.key;</a>
<span class="sourceLineNo">2386</span><a id="line.2386">        int pos;</a>
<span class="sourceLineNo">2387</span><a id="line.2387">        // The starting point.</a>
<span class="sourceLineNo">2388</span><a id="line.2388">        if ((curr = key[pos = (hasher.hash(original)) &amp; mask]) == null)</a>
<span class="sourceLineNo">2389</span><a id="line.2389">            return defRetValue;</a>
<span class="sourceLineNo">2390</span><a id="line.2390">        if (hasher.areEqual(original, curr))</a>
<span class="sourceLineNo">2391</span><a id="line.2391">        {</a>
<span class="sourceLineNo">2392</span><a id="line.2392">            v = value[pos];</a>
<span class="sourceLineNo">2393</span><a id="line.2393">            idx = alterEntry(pos);</a>
<span class="sourceLineNo">2394</span><a id="line.2394">            putAt(replacement, v, idx);</a>
<span class="sourceLineNo">2395</span><a id="line.2395">            return v;</a>
<span class="sourceLineNo">2396</span><a id="line.2396">        }</a>
<span class="sourceLineNo">2397</span><a id="line.2397">        while (true) {</a>
<span class="sourceLineNo">2398</span><a id="line.2398">            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)</a>
<span class="sourceLineNo">2399</span><a id="line.2399">                return defRetValue;</a>
<span class="sourceLineNo">2400</span><a id="line.2400">            if (hasher.areEqual(original, curr))</a>
<span class="sourceLineNo">2401</span><a id="line.2401">            {</a>
<span class="sourceLineNo">2402</span><a id="line.2402">                v = value[pos];</a>
<span class="sourceLineNo">2403</span><a id="line.2403">                idx = alterEntry(pos);</a>
<span class="sourceLineNo">2404</span><a id="line.2404">                putAt(replacement, v, idx);</a>
<span class="sourceLineNo">2405</span><a id="line.2405">                return v;</a>
<span class="sourceLineNo">2406</span><a id="line.2406">            }</a>
<span class="sourceLineNo">2407</span><a id="line.2407">        }</a>
<span class="sourceLineNo">2408</span><a id="line.2408">    }</a>
<span class="sourceLineNo">2409</span><a id="line.2409"></a>
<span class="sourceLineNo">2410</span><a id="line.2410">    public List&lt;V&gt; getMany(Collection&lt;K&gt; keys)</a>
<span class="sourceLineNo">2411</span><a id="line.2411">    {</a>
<span class="sourceLineNo">2412</span><a id="line.2412">        if(keys == null)</a>
<span class="sourceLineNo">2413</span><a id="line.2413">            return new ArrayList&lt;&gt;(1);</a>
<span class="sourceLineNo">2414</span><a id="line.2414">        ArrayList&lt;V&gt; vals = new ArrayList&lt;&gt;(keys.size());</a>
<span class="sourceLineNo">2415</span><a id="line.2415">        for(K k : keys)</a>
<span class="sourceLineNo">2416</span><a id="line.2416">        {</a>
<span class="sourceLineNo">2417</span><a id="line.2417">            vals.add(get(k));</a>
<span class="sourceLineNo">2418</span><a id="line.2418">        }</a>
<span class="sourceLineNo">2419</span><a id="line.2419">        return vals;</a>
<span class="sourceLineNo">2420</span><a id="line.2420">    }</a>
<span class="sourceLineNo">2421</span><a id="line.2421">    /**</a>
<span class="sourceLineNo">2422</span><a id="line.2422">     * Changes the K at the given index to replacement while keeping replacement at the same point in the ordering.</a>
<span class="sourceLineNo">2423</span><a id="line.2423">     * Be aware that if replacement is present in the OrderedMap, this will still replace the given index</a>
<span class="sourceLineNo">2424</span><a id="line.2424">     * with replacement but will also remove the other occurrence of replacement to avoid duplicate keys. This can throw</a>
<span class="sourceLineNo">2425</span><a id="line.2425">     * off the expected order because the duplicate could be at any point in the ordering when it is removed. You may</a>
<span class="sourceLineNo">2426</span><a id="line.2426">     * want to prefer {@link #alterAtCarefully(int, Object)} if you don't feel like checking by hand for whether</a>
<span class="sourceLineNo">2427</span><a id="line.2427">     * replacement is already present, but using this method is perfectly reasonable if you know overlaps won't happen.</a>
<span class="sourceLineNo">2428</span><a id="line.2428">     * @param index       an index to replace the K key at</a>
<span class="sourceLineNo">2429</span><a id="line.2429">     * @param replacement another K key that will replace the original at the remembered index</a>
<span class="sourceLineNo">2430</span><a id="line.2430">     * @return the value associated with the possibly-altered key</a>
<span class="sourceLineNo">2431</span><a id="line.2431">     */</a>
<span class="sourceLineNo">2432</span><a id="line.2432">    public V alterAt(int index, K replacement)</a>
<span class="sourceLineNo">2433</span><a id="line.2433">    {</a>
<span class="sourceLineNo">2434</span><a id="line.2434">        return alter(keyAt(index), replacement);</a>
<span class="sourceLineNo">2435</span><a id="line.2435">    }</a>
<span class="sourceLineNo">2436</span><a id="line.2436">    /**</a>
<span class="sourceLineNo">2437</span><a id="line.2437">     * Changes the K at the given index to replacement while keeping replacement at the same point in the ordering.</a>
<span class="sourceLineNo">2438</span><a id="line.2438">     * Unlike the similar method {@link #alterAt(int, Object)}, this will not change this OrderedMap if replacement is</a>
<span class="sourceLineNo">2439</span><a id="line.2439">     * already present. To contrast, alterAt() can reduce the size of the OrderedMap if replacement is already</a>
<span class="sourceLineNo">2440</span><a id="line.2440">     * in the Map. If replacement is found, this returns the default return value, otherwise it switches out the index</a>
<span class="sourceLineNo">2441</span><a id="line.2441">     * for replacement and returns whatever value was at the index before.</a>
<span class="sourceLineNo">2442</span><a id="line.2442">     * @param index       an index to replace the K key at</a>
<span class="sourceLineNo">2443</span><a id="line.2443">     * @param replacement another K key that will replace the original at the remembered index</a>
<span class="sourceLineNo">2444</span><a id="line.2444">     * @return the value associated with the key at the altered index before, and replacement now</a>
<span class="sourceLineNo">2445</span><a id="line.2445">     */</a>
<span class="sourceLineNo">2446</span><a id="line.2446">    public V alterAtCarefully(int index, K replacement)</a>
<span class="sourceLineNo">2447</span><a id="line.2447">    {</a>
<span class="sourceLineNo">2448</span><a id="line.2448">        return alterCarefully(keyAt(index), replacement);</a>
<span class="sourceLineNo">2449</span><a id="line.2449">    }</a>
<span class="sourceLineNo">2450</span><a id="line.2450"></a>
<span class="sourceLineNo">2451</span><a id="line.2451">    /**</a>
<span class="sourceLineNo">2452</span><a id="line.2452">     * If the specified key is not already associated with a value (or is mapped</a>
<span class="sourceLineNo">2453</span><a id="line.2453">     * to {@code null}) associates it with the given value and returns</a>
<span class="sourceLineNo">2454</span><a id="line.2454">     * {@code null}, else returns the current value.</a>
<span class="sourceLineNo">2455</span><a id="line.2455">     *</a>
<span class="sourceLineNo">2456</span><a id="line.2456">     * @param key   key with which the specified value is to be associated</a>
<span class="sourceLineNo">2457</span><a id="line.2457">     * @param value value to be associated with the specified key</a>
<span class="sourceLineNo">2458</span><a id="line.2458">     * @return the previous value associated with the specified key, or</a>
<span class="sourceLineNo">2459</span><a id="line.2459">     * {@code null} if there was no mapping for the key.</a>
<span class="sourceLineNo">2460</span><a id="line.2460">     * (A {@code null} return can also indicate that the map</a>
<span class="sourceLineNo">2461</span><a id="line.2461">     * previously associated {@code null} with the key.)</a>
<span class="sourceLineNo">2462</span><a id="line.2462">     */</a>
<span class="sourceLineNo">2463</span><a id="line.2463">    public V putIfAbsent(K key, V value) {</a>
<span class="sourceLineNo">2464</span><a id="line.2464">        V v = get(key);</a>
<span class="sourceLineNo">2465</span><a id="line.2465">        if(v == null)</a>
<span class="sourceLineNo">2466</span><a id="line.2466">            v = put(key, value);</a>
<span class="sourceLineNo">2467</span><a id="line.2467">        return v;</a>
<span class="sourceLineNo">2468</span><a id="line.2468">    }</a>
<span class="sourceLineNo">2469</span><a id="line.2469"></a>
<span class="sourceLineNo">2470</span><a id="line.2470">    /**</a>
<span class="sourceLineNo">2471</span><a id="line.2471">     * Removes the entry for the specified key only if it is currently</a>
<span class="sourceLineNo">2472</span><a id="line.2472">     * mapped to the specified value.</a>
<span class="sourceLineNo">2473</span><a id="line.2473">     *</a>
<span class="sourceLineNo">2474</span><a id="line.2474">     * @param key   key with which the specified value is associated</a>
<span class="sourceLineNo">2475</span><a id="line.2475">     * @param value value expected to be associated with the specified key</a>
<span class="sourceLineNo">2476</span><a id="line.2476">     * @return {@code true} if the value was removed</a>
<span class="sourceLineNo">2477</span><a id="line.2477">     */</a>
<span class="sourceLineNo">2478</span><a id="line.2478">    public boolean remove(Object key, Object value) {</a>
<span class="sourceLineNo">2479</span><a id="line.2479">        if (containsKey(key) &amp;&amp; Objects.equals(get(key), value)) {</a>
<span class="sourceLineNo">2480</span><a id="line.2480">            remove(key);</a>
<span class="sourceLineNo">2481</span><a id="line.2481">            return true;</a>
<span class="sourceLineNo">2482</span><a id="line.2482">        } else</a>
<span class="sourceLineNo">2483</span><a id="line.2483">            return false;</a>
<span class="sourceLineNo">2484</span><a id="line.2484">    }</a>
<span class="sourceLineNo">2485</span><a id="line.2485"></a>
<span class="sourceLineNo">2486</span><a id="line.2486">    /**</a>
<span class="sourceLineNo">2487</span><a id="line.2487">     * Replaces the entry for the specified key only if currently</a>
<span class="sourceLineNo">2488</span><a id="line.2488">     * mapped to the specified value. The position in the iteration</a>
<span class="sourceLineNo">2489</span><a id="line.2489">     * order is retained.</a>
<span class="sourceLineNo">2490</span><a id="line.2490">     *</a>
<span class="sourceLineNo">2491</span><a id="line.2491">     * @param key      key with which the specified value is associated</a>
<span class="sourceLineNo">2492</span><a id="line.2492">     * @param oldValue value expected to be associated with the specified key</a>
<span class="sourceLineNo">2493</span><a id="line.2493">     * @param newValue value to be associated with the specified key</a>
<span class="sourceLineNo">2494</span><a id="line.2494">     * @return {@code true} if the value was replaced</a>
<span class="sourceLineNo">2495</span><a id="line.2495">     */</a>
<span class="sourceLineNo">2496</span><a id="line.2496">    public boolean replace(K key, V oldValue, V newValue) {</a>
<span class="sourceLineNo">2497</span><a id="line.2497">        if (containsKey(key)) {</a>
<span class="sourceLineNo">2498</span><a id="line.2498">            V v = get(key);</a>
<span class="sourceLineNo">2499</span><a id="line.2499">            if (v == oldValue || (oldValue != null &amp;&amp; oldValue.equals(v))) {</a>
<span class="sourceLineNo">2500</span><a id="line.2500">                put(key, newValue);</a>
<span class="sourceLineNo">2501</span><a id="line.2501">                return true;</a>
<span class="sourceLineNo">2502</span><a id="line.2502">            }</a>
<span class="sourceLineNo">2503</span><a id="line.2503">        }</a>
<span class="sourceLineNo">2504</span><a id="line.2504">        return false;</a>
<span class="sourceLineNo">2505</span><a id="line.2505">    }</a>
<span class="sourceLineNo">2506</span><a id="line.2506"></a>
<span class="sourceLineNo">2507</span><a id="line.2507">    /**</a>
<span class="sourceLineNo">2508</span><a id="line.2508">     * Replaces the entry for the specified key only if it is</a>
<span class="sourceLineNo">2509</span><a id="line.2509">     * currently mapped to some value. Preserves the existing key's</a>
<span class="sourceLineNo">2510</span><a id="line.2510">     * position in the iteration order.</a>
<span class="sourceLineNo">2511</span><a id="line.2511">     *</a>
<span class="sourceLineNo">2512</span><a id="line.2512">     * @param key   key with which the specified value is associated</a>
<span class="sourceLineNo">2513</span><a id="line.2513">     * @param value value to be associated with the specified key</a>
<span class="sourceLineNo">2514</span><a id="line.2514">     * @return the previous value associated with the specified key, or</a>
<span class="sourceLineNo">2515</span><a id="line.2515">     * {@code null} if there was no mapping for the key.</a>
<span class="sourceLineNo">2516</span><a id="line.2516">     * (A {@code null} return can also indicate that the map</a>
<span class="sourceLineNo">2517</span><a id="line.2517">     * previously associated {@code null} with the key.)</a>
<span class="sourceLineNo">2518</span><a id="line.2518">     */</a>
<span class="sourceLineNo">2519</span><a id="line.2519">    public V replace(K key, V value) {</a>
<span class="sourceLineNo">2520</span><a id="line.2520">        if (containsKey(key)) {</a>
<span class="sourceLineNo">2521</span><a id="line.2521">            return put(key, value);</a>
<span class="sourceLineNo">2522</span><a id="line.2522">        } else</a>
<span class="sourceLineNo">2523</span><a id="line.2523">            return null;</a>
<span class="sourceLineNo">2524</span><a id="line.2524">    }</a>
<span class="sourceLineNo">2525</span><a id="line.2525">    /**</a>
<span class="sourceLineNo">2526</span><a id="line.2526">     * Given alternating key and value arguments in pairs, puts each key-value pair into this OrderedMap as if by</a>
<span class="sourceLineNo">2527</span><a id="line.2527">     * calling {@link #put(Object, Object)} repeatedly for each pair. This mimics the parameter syntax used for</a>
<span class="sourceLineNo">2528</span><a id="line.2528">     * {@link #makeMap(Object, Object, Object...)}, and can be used to retain that style of insertion after an</a>
<span class="sourceLineNo">2529</span><a id="line.2529">     * OrderedMap has been instantiated.</a>
<span class="sourceLineNo">2530</span><a id="line.2530">     * @param k0 the first key to add</a>
<span class="sourceLineNo">2531</span><a id="line.2531">     * @param v0 the first value to add</a>
<span class="sourceLineNo">2532</span><a id="line.2532">     * @param rest an array or vararg of keys and values in pairs; should contain alternating K, V, K, V... elements</a>
<span class="sourceLineNo">2533</span><a id="line.2533">     * @return this, after adding all viable key-value pairs given</a>
<span class="sourceLineNo">2534</span><a id="line.2534">     */</a>
<span class="sourceLineNo">2535</span><a id="line.2535">    @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">2536</span><a id="line.2536">    public OrderedMap&lt;K, V&gt; putPairs(K k0, V v0, Object... rest)</a>
<span class="sourceLineNo">2537</span><a id="line.2537">    {</a>
<span class="sourceLineNo">2538</span><a id="line.2538">        if(rest == null || rest.length == 0)</a>
<span class="sourceLineNo">2539</span><a id="line.2539">        {</a>
<span class="sourceLineNo">2540</span><a id="line.2540">            put(k0, v0);</a>
<span class="sourceLineNo">2541</span><a id="line.2541">            return this;</a>
<span class="sourceLineNo">2542</span><a id="line.2542">        }</a>
<span class="sourceLineNo">2543</span><a id="line.2543">        put(k0, v0);</a>
<span class="sourceLineNo">2544</span><a id="line.2544"></a>
<span class="sourceLineNo">2545</span><a id="line.2545">        for (int i = 0; i &lt; rest.length - 1; i+=2) {</a>
<span class="sourceLineNo">2546</span><a id="line.2546">            try {</a>
<span class="sourceLineNo">2547</span><a id="line.2547">                put((K) rest[i], (V) rest[i + 1]);</a>
<span class="sourceLineNo">2548</span><a id="line.2548">            }catch (ClassCastException ignored) {</a>
<span class="sourceLineNo">2549</span><a id="line.2549">            }</a>
<span class="sourceLineNo">2550</span><a id="line.2550">        }</a>
<span class="sourceLineNo">2551</span><a id="line.2551">        return this;</a>
<span class="sourceLineNo">2552</span><a id="line.2552">    }</a>
<span class="sourceLineNo">2553</span><a id="line.2553"></a>
<span class="sourceLineNo">2554</span><a id="line.2554">    /**</a>
<span class="sourceLineNo">2555</span><a id="line.2555">     * Makes an OrderedMap (OM) with the given load factor (which should be between 0.1 and 0.9), key and value types</a>
<span class="sourceLineNo">2556</span><a id="line.2556">     * inferred from the types of k0 and v0, and considers all remaining parameters key-value pairs, casting the Objects</a>
<span class="sourceLineNo">2557</span><a id="line.2557">     * at positions 0, 2, 4... etc. to K and the objects at positions 1, 3, 5... etc. to V. If rest has an odd-number</a>
<span class="sourceLineNo">2558</span><a id="line.2558">     * length, then it discards the last item. If any pair of items in rest cannot be cast to the correct type of K or</a>
<span class="sourceLineNo">2559</span><a id="line.2559">     * V, then this inserts nothing for that pair. This is similar to the makeOM method in the Maker class, but does not</a>
<span class="sourceLineNo">2560</span><a id="line.2560">     * allow setting the load factor (since that extra parameter can muddle how javac figures out which generic types</a>
<span class="sourceLineNo">2561</span><a id="line.2561">     * the map should use), nor does it log debug information if a cast fails. The result should be the same otherwise.</a>
<span class="sourceLineNo">2562</span><a id="line.2562">     * &lt;br&gt;</a>
<span class="sourceLineNo">2563</span><a id="line.2563">     * This is named makeMap to indicate that it expects key and value parameters, unlike a Set or List. This convention</a>
<span class="sourceLineNo">2564</span><a id="line.2564">     * may be extended to other data structures that also have static methods for instantiation.</a>
<span class="sourceLineNo">2565</span><a id="line.2565">     * @param k0 the first key; used to infer the types of other keys if generic parameters aren't specified.</a>
<span class="sourceLineNo">2566</span><a id="line.2566">     * @param v0 the first value; used to infer the types of other values if generic parameters aren't specified.</a>
<span class="sourceLineNo">2567</span><a id="line.2567">     * @param rest an array or vararg of keys and values in pairs; should contain alternating K, V, K, V... elements</a>
<span class="sourceLineNo">2568</span><a id="line.2568">     * @param &lt;K&gt; the type of keys in the returned OrderedMap; if not specified, will be inferred from k0</a>
<span class="sourceLineNo">2569</span><a id="line.2569">     * @param &lt;V&gt; the type of values in the returned OrderedMap; if not specified, will be inferred from v0</a>
<span class="sourceLineNo">2570</span><a id="line.2570">     * @return a freshly-made OrderedMap with K keys and V values, using k0, v0, and the contents of rest to fill it</a>
<span class="sourceLineNo">2571</span><a id="line.2571">     */</a>
<span class="sourceLineNo">2572</span><a id="line.2572">    @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">2573</span><a id="line.2573">    public static &lt;K, V&gt; OrderedMap&lt;K, V&gt; makeMap(K k0, V v0, Object... rest)</a>
<span class="sourceLineNo">2574</span><a id="line.2574">    {</a>
<span class="sourceLineNo">2575</span><a id="line.2575">        if(rest == null || rest.length == 0)</a>
<span class="sourceLineNo">2576</span><a id="line.2576">        {</a>
<span class="sourceLineNo">2577</span><a id="line.2577">            OrderedMap&lt;K, V&gt; om = new OrderedMap&lt;&gt;(2);</a>
<span class="sourceLineNo">2578</span><a id="line.2578">            om.put(k0, v0);</a>
<span class="sourceLineNo">2579</span><a id="line.2579">            return om;</a>
<span class="sourceLineNo">2580</span><a id="line.2580">        }</a>
<span class="sourceLineNo">2581</span><a id="line.2581">        OrderedMap&lt;K, V&gt; om = new OrderedMap&lt;&gt;(1 + (rest.length &gt;&gt; 1));</a>
<span class="sourceLineNo">2582</span><a id="line.2582">        om.put(k0, v0);</a>
<span class="sourceLineNo">2583</span><a id="line.2583"></a>
<span class="sourceLineNo">2584</span><a id="line.2584">        for (int i = 0; i &lt; rest.length - 1; i+=2) {</a>
<span class="sourceLineNo">2585</span><a id="line.2585">            try {</a>
<span class="sourceLineNo">2586</span><a id="line.2586">                om.put((K) rest[i], (V) rest[i + 1]);</a>
<span class="sourceLineNo">2587</span><a id="line.2587">            }catch (ClassCastException ignored) {</a>
<span class="sourceLineNo">2588</span><a id="line.2588">            }</a>
<span class="sourceLineNo">2589</span><a id="line.2589">        }</a>
<span class="sourceLineNo">2590</span><a id="line.2590">        return om;</a>
<span class="sourceLineNo">2591</span><a id="line.2591">    }</a>
<span class="sourceLineNo">2592</span><a id="line.2592"></a>
<span class="sourceLineNo">2593</span><a id="line.2593">    /**</a>
<span class="sourceLineNo">2594</span><a id="line.2594">     * Makes an empty OrderedMap (OM); needs key and value types to be specified in order to work. For an empty</a>
<span class="sourceLineNo">2595</span><a id="line.2595">     * OrderedMap with String keys and Coord values, you could use {@code Maker.&lt;String, Coord&gt;makeOM()}. Using</a>
<span class="sourceLineNo">2596</span><a id="line.2596">     * the new keyword is probably just as easy in this case; this method is provided for completeness relative to</a>
<span class="sourceLineNo">2597</span><a id="line.2597">     * makeMap() with 2 or more parameters.</a>
<span class="sourceLineNo">2598</span><a id="line.2598">     * @param &lt;K&gt; the type of keys in the returned OrderedMap; cannot be inferred and must be specified</a>
<span class="sourceLineNo">2599</span><a id="line.2599">     * @param &lt;V&gt; the type of values in the returned OrderedMap; cannot be inferred and must be specified</a>
<span class="sourceLineNo">2600</span><a id="line.2600">     * @return an empty OrderedMap with the given key and value types.</a>
<span class="sourceLineNo">2601</span><a id="line.2601">     */</a>
<span class="sourceLineNo">2602</span><a id="line.2602">    public static &lt;K, V&gt; OrderedMap&lt;K, V&gt; makeMap()</a>
<span class="sourceLineNo">2603</span><a id="line.2603">    {</a>
<span class="sourceLineNo">2604</span><a id="line.2604">        return new OrderedMap&lt;&gt;();</a>
<span class="sourceLineNo">2605</span><a id="line.2605">    }</a>
<span class="sourceLineNo">2606</span><a id="line.2606"></a>
<span class="sourceLineNo">2607</span><a id="line.2607"></a>
<span class="sourceLineNo">2608</span><a id="line.2608">    /**</a>
<span class="sourceLineNo">2609</span><a id="line.2609">     * Sorts this whole OrderedMap on its keys using the supplied Comparator.</a>
<span class="sourceLineNo">2610</span><a id="line.2610">     * @param comparator a Comparator that can be used on the same type this uses for its keys (may need wildcards)</a>
<span class="sourceLineNo">2611</span><a id="line.2611">     */</a>
<span class="sourceLineNo">2612</span><a id="line.2612">    public void sort(Comparator&lt;? super K&gt; comparator)</a>
<span class="sourceLineNo">2613</span><a id="line.2613">    {</a>
<span class="sourceLineNo">2614</span><a id="line.2614">        sort(comparator, 0, size);</a>
<span class="sourceLineNo">2615</span><a id="line.2615">    }</a>
<span class="sourceLineNo">2616</span><a id="line.2616"></a>
<span class="sourceLineNo">2617</span><a id="line.2617">    /**</a>
<span class="sourceLineNo">2618</span><a id="line.2618">     * Sorts a sub-range of this OrderedMap on its keys from what is currently the index {@code start} up to (but not</a>
<span class="sourceLineNo">2619</span><a id="line.2619">     * including) the index {@code end}, using the supplied Comparator.</a>
<span class="sourceLineNo">2620</span><a id="line.2620">     * @param comparator a Comparator that can be used on the same type this uses for its keys (may need wildcards)</a>
<span class="sourceLineNo">2621</span><a id="line.2621">     * @param start the first index of a key to sort (the index can change after this)</a>
<span class="sourceLineNo">2622</span><a id="line.2622">     * @param end the exclusive bound on the indices to sort; often this is just {@link #size()}</a>
<span class="sourceLineNo">2623</span><a id="line.2623">     */</a>
<span class="sourceLineNo">2624</span><a id="line.2624">    public void sort(Comparator&lt;? super K&gt; comparator, int start, int end)</a>
<span class="sourceLineNo">2625</span><a id="line.2625">    {</a>
<span class="sourceLineNo">2626</span><a id="line.2626">        TimSort.sort(key, order, start, end, comparator);</a>
<span class="sourceLineNo">2627</span><a id="line.2627">    }</a>
<span class="sourceLineNo">2628</span><a id="line.2628">    /**</a>
<span class="sourceLineNo">2629</span><a id="line.2629">     * Sorts this whole OrderedMap on its values using the supplied Comparator.</a>
<span class="sourceLineNo">2630</span><a id="line.2630">     * @param comparator a Comparator that can be used on the same type this uses for its values (may need wildcards)</a>
<span class="sourceLineNo">2631</span><a id="line.2631">     */</a>
<span class="sourceLineNo">2632</span><a id="line.2632">    public void sortByValue(Comparator&lt;? super V&gt; comparator)</a>
<span class="sourceLineNo">2633</span><a id="line.2633">    {</a>
<span class="sourceLineNo">2634</span><a id="line.2634">        sortByValue(comparator, 0, size);</a>
<span class="sourceLineNo">2635</span><a id="line.2635">    }</a>
<span class="sourceLineNo">2636</span><a id="line.2636"></a>
<span class="sourceLineNo">2637</span><a id="line.2637">    /**</a>
<span class="sourceLineNo">2638</span><a id="line.2638">     * Sorts a sub-range of this OrderedMap on its values from what is currently the index {@code start} up to (but not</a>
<span class="sourceLineNo">2639</span><a id="line.2639">     * including) the index {@code end}, using the supplied Comparator.</a>
<span class="sourceLineNo">2640</span><a id="line.2640">     * @param comparator a Comparator that can be used on the same type this uses for its values (may need wildcards)</a>
<span class="sourceLineNo">2641</span><a id="line.2641">     * @param start the first index of a value to sort (the index can change after this)</a>
<span class="sourceLineNo">2642</span><a id="line.2642">     * @param end the exclusive bound on the indices to sort; often this is just {@link #size()}</a>
<span class="sourceLineNo">2643</span><a id="line.2643">     */</a>
<span class="sourceLineNo">2644</span><a id="line.2644">    public void sortByValue(Comparator&lt;? super V&gt; comparator, int start, int end)</a>
<span class="sourceLineNo">2645</span><a id="line.2645">    {</a>
<span class="sourceLineNo">2646</span><a id="line.2646">        TimSort.sort(value, order, start, end, comparator);</a>
<span class="sourceLineNo">2647</span><a id="line.2647">    }</a>
<span class="sourceLineNo">2648</span><a id="line.2648"></a>
<span class="sourceLineNo">2649</span><a id="line.2649">    /**</a>
<span class="sourceLineNo">2650</span><a id="line.2650">     * Reverses the iteration order in linear time.</a>
<span class="sourceLineNo">2651</span><a id="line.2651">     */</a>
<span class="sourceLineNo">2652</span><a id="line.2652">    public void reverse()</a>
<span class="sourceLineNo">2653</span><a id="line.2653">    {</a>
<span class="sourceLineNo">2654</span><a id="line.2654">        order.reverse();</a>
<span class="sourceLineNo">2655</span><a id="line.2655">    }</a>
<span class="sourceLineNo">2656</span><a id="line.2656">}</a>




























































</pre>
</div>
</main>
</body>
</html>
