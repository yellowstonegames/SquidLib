<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Source code</title>
<meta name="description" content="source: package: squidpony.squidmath, class: IsaacRNG">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source">
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">/*</a>
<span class="sourceLineNo">002</span><a id="line.2"> ------------------------------------------------------------------------------</a>
<span class="sourceLineNo">003</span><a id="line.3"> Rand.java: By Bob Jenkins.  My random number generator, ISAAC.</a>
<span class="sourceLineNo">004</span><a id="line.4"> rand.init() -- initialize</a>
<span class="sourceLineNo">005</span><a id="line.5"> rand.val()  -- get a random value</a>
<span class="sourceLineNo">006</span><a id="line.6"> MODIFIED:</a>
<span class="sourceLineNo">007</span><a id="line.7"> 960327: Creation (addition of randinit, really)</a>
<span class="sourceLineNo">008</span><a id="line.8"> 970719: use context, not global variables, for internal state</a>
<span class="sourceLineNo">009</span><a id="line.9"> 980224: Translate to Java</a>
<span class="sourceLineNo">010</span><a id="line.10"> ------------------------------------------------------------------------------</a>
<span class="sourceLineNo">011</span><a id="line.11"> */</a>
<span class="sourceLineNo">012</span><a id="line.12"></a>
<span class="sourceLineNo">013</span><a id="line.13">package squidpony.squidmath;</a>
<span class="sourceLineNo">014</span><a id="line.14"></a>
<span class="sourceLineNo">015</span><a id="line.15">import java.util.Arrays;</a>
<span class="sourceLineNo">016</span><a id="line.16">/**</a>
<span class="sourceLineNo">017</span><a id="line.17"> * This is a port of the public domain Isaac64 (cryptographic) random number generator to Java.</a>
<span class="sourceLineNo">018</span><a id="line.18"> * It is a RandomnessSource here, so it should generally be used to make an RNG, which has more</a>
<span class="sourceLineNo">019</span><a id="line.19"> * features. IsaacRNG is slower than the non-cryptographic RNGs in SquidLib, but much faster</a>
<span class="sourceLineNo">020</span><a id="line.20"> * than cryptographic RNGs that need SecureRandom, plus it's compatible with GWT and Android!</a>
<span class="sourceLineNo">021</span><a id="line.21"> * Created by Tommy Ettinger on 8/1/2016.</a>
<span class="sourceLineNo">022</span><a id="line.22"> */</a>
<span class="sourceLineNo">023</span><a id="line.23">public class IsaacRNG implements RandomnessSource {</a>
<span class="sourceLineNo">024</span><a id="line.24">    private int count;                           /* count through the results in results[] */</a>
<span class="sourceLineNo">025</span><a id="line.25">    private long[] results;                                /* the results given to the user */</a>
<span class="sourceLineNo">026</span><a id="line.26">    private long[] mem;                                   /* the internal state */</a>
<span class="sourceLineNo">027</span><a id="line.27">    private long a;                                              /* accumulator */</a>
<span class="sourceLineNo">028</span><a id="line.28">    private long b;                                          /* the last result */</a>
<span class="sourceLineNo">029</span><a id="line.29">    private long c;              /* counter, guarantees cycle is at least 2^^72 */</a>
<span class="sourceLineNo">030</span><a id="line.30"></a>
<span class="sourceLineNo">031</span><a id="line.31"></a>
<span class="sourceLineNo">032</span><a id="line.32">    /**</a>
<span class="sourceLineNo">033</span><a id="line.33">     * Constructs an IsaacRNG with no seed; this will produce one sequence of numbers as if the seed were 0</a>
<span class="sourceLineNo">034</span><a id="line.34">     * (which it essentially is, though passing 0 to the constructor that takes a long will produce a different</a>
<span class="sourceLineNo">035</span><a id="line.35">     * sequence) instead of what the other RandomnessSources do (initialize with a low-quality random number</a>
<span class="sourceLineNo">036</span><a id="line.36">     * from Math.random()).</a>
<span class="sourceLineNo">037</span><a id="line.37">     */</a>
<span class="sourceLineNo">038</span><a id="line.38">    public IsaacRNG() {</a>
<span class="sourceLineNo">039</span><a id="line.39">        mem = new long[256];</a>
<span class="sourceLineNo">040</span><a id="line.40">        results = new long[256];</a>
<span class="sourceLineNo">041</span><a id="line.41">        init(false);</a>
<span class="sourceLineNo">042</span><a id="line.42">    }</a>
<span class="sourceLineNo">043</span><a id="line.43"></a>
<span class="sourceLineNo">044</span><a id="line.44"></a>
<span class="sourceLineNo">045</span><a id="line.45">    /**</a>
<span class="sourceLineNo">046</span><a id="line.46">     * Constructs an IsaacRNG with the given seed, which should be a rather large array of long values.</a>
<span class="sourceLineNo">047</span><a id="line.47">     * You should try to make seed a long[256], but smaller arrays will be tolerated without error.</a>
<span class="sourceLineNo">048</span><a id="line.48">     * Arrays larger than 256 items will only have the first 256 used.</a>
<span class="sourceLineNo">049</span><a id="line.49">     * @param seed an array of longs to use as a seed; ideally it should be 256 individual longs</a>
<span class="sourceLineNo">050</span><a id="line.50">     */</a>
<span class="sourceLineNo">051</span><a id="line.51">    public IsaacRNG(long[] seed) {</a>
<span class="sourceLineNo">052</span><a id="line.52">        mem = new long[256];</a>
<span class="sourceLineNo">053</span><a id="line.53">        results = new long[256];</a>
<span class="sourceLineNo">054</span><a id="line.54">        if(seed == null)</a>
<span class="sourceLineNo">055</span><a id="line.55">            init(false);</a>
<span class="sourceLineNo">056</span><a id="line.56">        else {</a>
<span class="sourceLineNo">057</span><a id="line.57">            System.arraycopy(seed, 0, results, 0, Math.min(256, seed.length));</a>
<span class="sourceLineNo">058</span><a id="line.58">            init(true);</a>
<span class="sourceLineNo">059</span><a id="line.59">        }</a>
<span class="sourceLineNo">060</span><a id="line.60">    }</a>
<span class="sourceLineNo">061</span><a id="line.61"></a>
<span class="sourceLineNo">062</span><a id="line.62">    /**</a>
<span class="sourceLineNo">063</span><a id="line.63">     * Constructs an IsaacRNG with its state filled by the value of seed, run through the LightRNG algorithm.</a>
<span class="sourceLineNo">064</span><a id="line.64">     * @param seed any long; will have equal influence on all bits of state</a>
<span class="sourceLineNo">065</span><a id="line.65">     */</a>
<span class="sourceLineNo">066</span><a id="line.66">    public IsaacRNG(long seed) {</a>
<span class="sourceLineNo">067</span><a id="line.67">        mem = new long[256];</a>
<span class="sourceLineNo">068</span><a id="line.68">        results = new long[256];</a>
<span class="sourceLineNo">069</span><a id="line.69">        long z;</a>
<span class="sourceLineNo">070</span><a id="line.70">        for (int i = 0; i &lt; 256; i++) {</a>
<span class="sourceLineNo">071</span><a id="line.71">            z = ( seed += 0x9E3779B97F4A7C15L );</a>
<span class="sourceLineNo">072</span><a id="line.72">            z = (z ^ (z &gt;&gt;&gt; 30)) * 0xBF58476D1CE4E5B9L;</a>
<span class="sourceLineNo">073</span><a id="line.73">            z = (z ^ (z &gt;&gt;&gt; 27)) * 0x94D049BB133111EBL;</a>
<span class="sourceLineNo">074</span><a id="line.74">            results[i] = z ^ (z &gt;&gt;&gt; 31);</a>
<span class="sourceLineNo">075</span><a id="line.75">        }</a>
<span class="sourceLineNo">076</span><a id="line.76">        init(true);</a>
<span class="sourceLineNo">077</span><a id="line.77">    }</a>
<span class="sourceLineNo">078</span><a id="line.78"></a>
<span class="sourceLineNo">079</span><a id="line.79">    /**</a>
<span class="sourceLineNo">080</span><a id="line.80">     * Constructs an IsaacRNG with its state filled by repeated hashing of seed.</a>
<span class="sourceLineNo">081</span><a id="line.81">     * @param seed a String that should be exceptionally long to get the best results.</a>
<span class="sourceLineNo">082</span><a id="line.82">     */</a>
<span class="sourceLineNo">083</span><a id="line.83">    public IsaacRNG(String seed) {</a>
<span class="sourceLineNo">084</span><a id="line.84">        mem = new long[256];</a>
<span class="sourceLineNo">085</span><a id="line.85">        results = new long[256];</a>
<span class="sourceLineNo">086</span><a id="line.86">        if(seed == null)</a>
<span class="sourceLineNo">087</span><a id="line.87">            init(false);</a>
<span class="sourceLineNo">088</span><a id="line.88">        else {</a>
<span class="sourceLineNo">089</span><a id="line.89">            char[] chars = seed.toCharArray();</a>
<span class="sourceLineNo">090</span><a id="line.90">            int slen = seed.length(), i = 0;</a>
<span class="sourceLineNo">091</span><a id="line.91">            for (; i &lt; 256 &amp;&amp; i &lt; slen; i++) {</a>
<span class="sourceLineNo">092</span><a id="line.92">                results[i] = CrossHash.hash64(chars, i, slen);</a>
<span class="sourceLineNo">093</span><a id="line.93">            }</a>
<span class="sourceLineNo">094</span><a id="line.94">            for (; i &lt; 256; i++) {</a>
<span class="sourceLineNo">095</span><a id="line.95">                results[i] = CrossHash.hash64(results);</a>
<span class="sourceLineNo">096</span><a id="line.96">            }</a>
<span class="sourceLineNo">097</span><a id="line.97">            init(true);</a>
<span class="sourceLineNo">098</span><a id="line.98">        }</a>
<span class="sourceLineNo">099</span><a id="line.99">    }</a>
<span class="sourceLineNo">100</span><a id="line.100"></a>
<span class="sourceLineNo">101</span><a id="line.101">    private IsaacRNG(IsaacRNG other)</a>
<span class="sourceLineNo">102</span><a id="line.102">    {</a>
<span class="sourceLineNo">103</span><a id="line.103">        this(other.results);</a>
<span class="sourceLineNo">104</span><a id="line.104">    }</a>
<span class="sourceLineNo">105</span><a id="line.105"></a>
<span class="sourceLineNo">106</span><a id="line.106">    /**</a>
<span class="sourceLineNo">107</span><a id="line.107">     *  Generates 256 results to be used by later calls to next() or nextLong().</a>
<span class="sourceLineNo">108</span><a id="line.108">     *  This is a fast (not small) implementation.</a>
<span class="sourceLineNo">109</span><a id="line.109">     *  */</a>
<span class="sourceLineNo">110</span><a id="line.110">    public final void regen() {</a>
<span class="sourceLineNo">111</span><a id="line.111">        int i, j;</a>
<span class="sourceLineNo">112</span><a id="line.112">        long x, y;</a>
<span class="sourceLineNo">113</span><a id="line.113"></a>
<span class="sourceLineNo">114</span><a id="line.114">        b += ++c;</a>
<span class="sourceLineNo">115</span><a id="line.115">        for (i=0, j=128; i&lt;128;) {</a>
<span class="sourceLineNo">116</span><a id="line.116">            x = mem[i];</a>
<span class="sourceLineNo">117</span><a id="line.117">            a = ~(a ^ a &lt;&lt; 21) + mem[j++];</a>
<span class="sourceLineNo">118</span><a id="line.118">            mem[i] = y = mem[(int)(x &gt;&gt; 3 &amp; 255)] + a + b;</a>
<span class="sourceLineNo">119</span><a id="line.119">            results[i++] = b = mem[(int)(y &gt;&gt; 11 &amp; 255)] + x;</a>
<span class="sourceLineNo">120</span><a id="line.120"></a>
<span class="sourceLineNo">121</span><a id="line.121">            x = mem[i];</a>
<span class="sourceLineNo">122</span><a id="line.122">            a = (a ^ a &gt;&gt;&gt; 5) + mem[j++];</a>
<span class="sourceLineNo">123</span><a id="line.123">            mem[i] = y = mem[(int)(x &gt;&gt; 3 &amp; 255)] + a + b;</a>
<span class="sourceLineNo">124</span><a id="line.124">            results[i++] = b = mem[(int)(y &gt;&gt; 11 &amp; 255)] + x;</a>
<span class="sourceLineNo">125</span><a id="line.125"></a>
<span class="sourceLineNo">126</span><a id="line.126">            x = mem[i];</a>
<span class="sourceLineNo">127</span><a id="line.127">            a = (a ^ a &lt;&lt; 12) + mem[j++];</a>
<span class="sourceLineNo">128</span><a id="line.128">            mem[i] = y = mem[(int)(x &gt;&gt; 3 &amp; 255)] + a + b;</a>
<span class="sourceLineNo">129</span><a id="line.129">            results[i++] = b = mem[(int)(y &gt;&gt; 11 &amp; 255)] + x;</a>
<span class="sourceLineNo">130</span><a id="line.130"></a>
<span class="sourceLineNo">131</span><a id="line.131">            x = mem[i];</a>
<span class="sourceLineNo">132</span><a id="line.132">            a = (a ^ a &gt;&gt;&gt; 33) + mem[j++];</a>
<span class="sourceLineNo">133</span><a id="line.133">            mem[i] = y = mem[(int)(x &gt;&gt; 3 &amp; 255)] + a + b;</a>
<span class="sourceLineNo">134</span><a id="line.134">            results[i++] = b = mem[(int)(y &gt;&gt; 11 &amp; 255)] + x;</a>
<span class="sourceLineNo">135</span><a id="line.135">        }</a>
<span class="sourceLineNo">136</span><a id="line.136"></a>
<span class="sourceLineNo">137</span><a id="line.137">        for (j=0; j&lt;128;) {</a>
<span class="sourceLineNo">138</span><a id="line.138">            x = mem[i];</a>
<span class="sourceLineNo">139</span><a id="line.139">            a = ~(a ^ a &lt;&lt; 21) + mem[j++];</a>
<span class="sourceLineNo">140</span><a id="line.140">            mem[i] = y = mem[(int)(x &gt;&gt; 3 &amp; 255)] + a + b;</a>
<span class="sourceLineNo">141</span><a id="line.141">            results[i++] = b = mem[(int)(y &gt;&gt; 11 &amp; 255)] + x;</a>
<span class="sourceLineNo">142</span><a id="line.142"></a>
<span class="sourceLineNo">143</span><a id="line.143">            x = mem[i];</a>
<span class="sourceLineNo">144</span><a id="line.144">            a = (a ^ a &gt;&gt;&gt; 5) + mem[j++];</a>
<span class="sourceLineNo">145</span><a id="line.145">            mem[i] = y = mem[(int)(x &gt;&gt; 3 &amp; 255)] + a + b;</a>
<span class="sourceLineNo">146</span><a id="line.146">            results[i++] = b = mem[(int)(y &gt;&gt; 11 &amp; 255)] + x;</a>
<span class="sourceLineNo">147</span><a id="line.147"></a>
<span class="sourceLineNo">148</span><a id="line.148">            x = mem[i];</a>
<span class="sourceLineNo">149</span><a id="line.149">            a = (a ^ a &lt;&lt; 12) + mem[j++];</a>
<span class="sourceLineNo">150</span><a id="line.150">            mem[i] = y = mem[(int)(x &gt;&gt; 3 &amp; 255)] + a + b;</a>
<span class="sourceLineNo">151</span><a id="line.151">            results[i++] = b = mem[(int)(y &gt;&gt; 11 &amp; 255)] + x;</a>
<span class="sourceLineNo">152</span><a id="line.152"></a>
<span class="sourceLineNo">153</span><a id="line.153">            x = mem[i];</a>
<span class="sourceLineNo">154</span><a id="line.154">            a = (a ^ a &gt;&gt;&gt; 33) + mem[j++];</a>
<span class="sourceLineNo">155</span><a id="line.155">            mem[i] = y = mem[(int)(x &gt;&gt; 3 &amp; 255)] + a + b;</a>
<span class="sourceLineNo">156</span><a id="line.156">            results[i++] = b = mem[(int)(y &gt;&gt; 11 &amp; 255)] + x;</a>
<span class="sourceLineNo">157</span><a id="line.157">        }</a>
<span class="sourceLineNo">158</span><a id="line.158">    }</a>
<span class="sourceLineNo">159</span><a id="line.159">    /**</a>
<span class="sourceLineNo">160</span><a id="line.160">     * Can be used to re-initialize this IsaacRNG as if using the long-array constructor.</a>
<span class="sourceLineNo">161</span><a id="line.161">     * The given seed should be a rather large array of long values.</a>
<span class="sourceLineNo">162</span><a id="line.162">     * You should try to make seed a long[256], but smaller arrays will be tolerated without error.</a>
<span class="sourceLineNo">163</span><a id="line.163">     * Arrays larger than 256 items will only have the first 256 used.</a>
<span class="sourceLineNo">164</span><a id="line.164">     * @param seed an array of longs to use as a seed; ideally it should be 256 individual longs</a>
<span class="sourceLineNo">165</span><a id="line.165">     */</a>
<span class="sourceLineNo">166</span><a id="line.166">    public void init(long[] seed) {</a>
<span class="sourceLineNo">167</span><a id="line.167">        if(seed == null)</a>
<span class="sourceLineNo">168</span><a id="line.168">            init(false);</a>
<span class="sourceLineNo">169</span><a id="line.169">        else {</a>
<span class="sourceLineNo">170</span><a id="line.170">            System.arraycopy(seed, 0, results, 0, Math.min(256, seed.length));</a>
<span class="sourceLineNo">171</span><a id="line.171">            init(true);</a>
<span class="sourceLineNo">172</span><a id="line.172">        }</a>
<span class="sourceLineNo">173</span><a id="line.173">    }</a>
<span class="sourceLineNo">174</span><a id="line.174"></a>
<span class="sourceLineNo">175</span><a id="line.175">    /**</a>
<span class="sourceLineNo">176</span><a id="line.176">     * Can be used to re-initialize this IsaacRNG as if using the single-long constructor.</a>
<span class="sourceLineNo">177</span><a id="line.177">     * @param seed any long; will have equal influence on all bits of state</a>
<span class="sourceLineNo">178</span><a id="line.178">     */</a>
<span class="sourceLineNo">179</span><a id="line.179">    public void init(long seed) {</a>
<span class="sourceLineNo">180</span><a id="line.180">        long z;</a>
<span class="sourceLineNo">181</span><a id="line.181">        for (int i = 0; i &lt; 256; i++) {</a>
<span class="sourceLineNo">182</span><a id="line.182">            z = ( seed += 0x9E3779B97F4A7C15L );</a>
<span class="sourceLineNo">183</span><a id="line.183">            z = (z ^ (z &gt;&gt;&gt; 30)) * 0xBF58476D1CE4E5B9L;</a>
<span class="sourceLineNo">184</span><a id="line.184">            z = (z ^ (z &gt;&gt;&gt; 27)) * 0x94D049BB133111EBL;</a>
<span class="sourceLineNo">185</span><a id="line.185">            results[i] = z ^ (z &gt;&gt;&gt; 31);</a>
<span class="sourceLineNo">186</span><a id="line.186">        }</a>
<span class="sourceLineNo">187</span><a id="line.187">        init(true);</a>
<span class="sourceLineNo">188</span><a id="line.188">    }</a>
<span class="sourceLineNo">189</span><a id="line.189"></a>
<span class="sourceLineNo">190</span><a id="line.190">    /**</a>
<span class="sourceLineNo">191</span><a id="line.191">     * Can be used to re-initialize this IsaacRNG as if using the single-String constructor.</a>
<span class="sourceLineNo">192</span><a id="line.192">     * @param seed a String; if non-null, its contents will be used as a seed</a>
<span class="sourceLineNo">193</span><a id="line.193">     */</a>
<span class="sourceLineNo">194</span><a id="line.194">    public final void init(String seed)</a>
<span class="sourceLineNo">195</span><a id="line.195">    {</a>
<span class="sourceLineNo">196</span><a id="line.196">        if(seed == null)</a>
<span class="sourceLineNo">197</span><a id="line.197">            init(false);</a>
<span class="sourceLineNo">198</span><a id="line.198">        else {</a>
<span class="sourceLineNo">199</span><a id="line.199">            char[] chars = seed.toCharArray();</a>
<span class="sourceLineNo">200</span><a id="line.200">            int slen = seed.length(), i = 0;</a>
<span class="sourceLineNo">201</span><a id="line.201">            for (; i &lt; 256 &amp;&amp; i &lt; slen; i++) {</a>
<span class="sourceLineNo">202</span><a id="line.202">                results[i] = CrossHash.hash64(chars, i, slen);</a>
<span class="sourceLineNo">203</span><a id="line.203">            }</a>
<span class="sourceLineNo">204</span><a id="line.204">            for (; i &lt; 256; i++) {</a>
<span class="sourceLineNo">205</span><a id="line.205">                results[i] = CrossHash.hash64(results);</a>
<span class="sourceLineNo">206</span><a id="line.206">            }</a>
<span class="sourceLineNo">207</span><a id="line.207">            init(true);</a>
<span class="sourceLineNo">208</span><a id="line.208">        }</a>
<span class="sourceLineNo">209</span><a id="line.209"></a>
<span class="sourceLineNo">210</span><a id="line.210">    }</a>
<span class="sourceLineNo">211</span><a id="line.211"></a>
<span class="sourceLineNo">212</span><a id="line.212">    /**</a>
<span class="sourceLineNo">213</span><a id="line.213">     * Initializes this IsaacRNG; typically used from the constructor but can be called externally.</a>
<span class="sourceLineNo">214</span><a id="line.214">     * @param flag if true, use data from seed; if false, initializes this to unseeded random state</a>
<span class="sourceLineNo">215</span><a id="line.215">     */</a>
<span class="sourceLineNo">216</span><a id="line.216">    public final void init(boolean flag) {</a>
<span class="sourceLineNo">217</span><a id="line.217">        int i;</a>
<span class="sourceLineNo">218</span><a id="line.218">        long a,b,c,d,e,f,g,h;</a>
<span class="sourceLineNo">219</span><a id="line.219">        a=b=c=d=e=f=g=h=0x9e3779b97f4a7c13L;                        /* the golden ratio */</a>
<span class="sourceLineNo">220</span><a id="line.220"></a>
<span class="sourceLineNo">221</span><a id="line.221">        for (i=0; i&lt;4; ++i) {</a>
<span class="sourceLineNo">222</span><a id="line.222">            a-=e; f^=h&gt;&gt;&gt;9;  h+=a;</a>
<span class="sourceLineNo">223</span><a id="line.223">            b-=f; g^=a&lt;&lt;9;  a+=b;</a>
<span class="sourceLineNo">224</span><a id="line.224">            c-=g; h^=b&gt;&gt;&gt;23; b+=c;</a>
<span class="sourceLineNo">225</span><a id="line.225">            d-=h; a^=c&lt;&lt;15; c+=d;</a>
<span class="sourceLineNo">226</span><a id="line.226">            e-=a; b^=d&gt;&gt;&gt;14; d+=e;</a>
<span class="sourceLineNo">227</span><a id="line.227">            f-=b; c^=e&lt;&lt;20; e+=f;</a>
<span class="sourceLineNo">228</span><a id="line.228">            g-=c; d^=f&gt;&gt;&gt;17; f+=g;</a>
<span class="sourceLineNo">229</span><a id="line.229">            h-=d; e^=g&lt;&lt;14; g+=h;</a>
<span class="sourceLineNo">230</span><a id="line.230">            /*</a>
<span class="sourceLineNo">231</span><a id="line.231">            a^=b&lt;&lt;11;  d+=a; b+=c;</a>
<span class="sourceLineNo">232</span><a id="line.232">            b^=c&gt;&gt;&gt;3;  e+=b; c+=d;</a>
<span class="sourceLineNo">233</span><a id="line.233">            c^=d&lt;&lt;8;   f+=c; d+=e;</a>
<span class="sourceLineNo">234</span><a id="line.234">            d^=e&gt;&gt;&gt;16; g+=d; e+=f;</a>
<span class="sourceLineNo">235</span><a id="line.235">            e^=f&lt;&lt;10;  h+=e; f+=g;</a>
<span class="sourceLineNo">236</span><a id="line.236">            f^=g&gt;&gt;&gt;4;  a+=f; g+=h;</a>
<span class="sourceLineNo">237</span><a id="line.237">            g^=h&lt;&lt;8;   b+=g; h+=a;</a>
<span class="sourceLineNo">238</span><a id="line.238">            h^=a&gt;&gt;&gt;9;  c+=h; a+=b;</a>
<span class="sourceLineNo">239</span><a id="line.239">            */</a>
<span class="sourceLineNo">240</span><a id="line.240">        }</a>
<span class="sourceLineNo">241</span><a id="line.241"></a>
<span class="sourceLineNo">242</span><a id="line.242">        for (i=0; i&lt;256; i+=8) {              /* fill in mem[] with messy stuff */</a>
<span class="sourceLineNo">243</span><a id="line.243">            if (flag) {</a>
<span class="sourceLineNo">244</span><a id="line.244">                a+= results[i  ]; b+= results[i+1]; c+= results[i+2]; d+= results[i+3];</a>
<span class="sourceLineNo">245</span><a id="line.245">                e+= results[i+4]; f+= results[i+5]; g+= results[i+6]; h+= results[i+7];</a>
<span class="sourceLineNo">246</span><a id="line.246">            }</a>
<span class="sourceLineNo">247</span><a id="line.247">            a-=e; f^=h&gt;&gt;&gt;9;  h+=a;</a>
<span class="sourceLineNo">248</span><a id="line.248">            b-=f; g^=a&lt;&lt;9;  a+=b;</a>
<span class="sourceLineNo">249</span><a id="line.249">            c-=g; h^=b&gt;&gt;&gt;23; b+=c;</a>
<span class="sourceLineNo">250</span><a id="line.250">            d-=h; a^=c&lt;&lt;15; c+=d;</a>
<span class="sourceLineNo">251</span><a id="line.251">            e-=a; b^=d&gt;&gt;&gt;14; d+=e;</a>
<span class="sourceLineNo">252</span><a id="line.252">            f-=b; c^=e&lt;&lt;20; e+=f;</a>
<span class="sourceLineNo">253</span><a id="line.253">            g-=c; d^=f&gt;&gt;&gt;17; f+=g;</a>
<span class="sourceLineNo">254</span><a id="line.254">            h-=d; e^=g&lt;&lt;14; g+=h;</a>
<span class="sourceLineNo">255</span><a id="line.255">            mem[i  ]=a; mem[i+1]=b; mem[i+2]=c; mem[i+3]=d;</a>
<span class="sourceLineNo">256</span><a id="line.256">            mem[i+4]=e; mem[i+5]=f; mem[i+6]=g; mem[i+7]=h;</a>
<span class="sourceLineNo">257</span><a id="line.257">        }</a>
<span class="sourceLineNo">258</span><a id="line.258"></a>
<span class="sourceLineNo">259</span><a id="line.259">        if (flag) {           /* second pass makes all of seed affect all of mem */</a>
<span class="sourceLineNo">260</span><a id="line.260">            for (i=0; i&lt;256; i+=8) {</a>
<span class="sourceLineNo">261</span><a id="line.261">                a+=mem[i  ]; b+=mem[i+1]; c+=mem[i+2]; d+=mem[i+3];</a>
<span class="sourceLineNo">262</span><a id="line.262">                e+=mem[i+4]; f+=mem[i+5]; g+=mem[i+6]; h+=mem[i+7];</a>
<span class="sourceLineNo">263</span><a id="line.263">                a-=e; f^=h&gt;&gt;&gt;9;  h+=a;</a>
<span class="sourceLineNo">264</span><a id="line.264">                b-=f; g^=a&lt;&lt;9;  a+=b;</a>
<span class="sourceLineNo">265</span><a id="line.265">                c-=g; h^=b&gt;&gt;&gt;23; b+=c;</a>
<span class="sourceLineNo">266</span><a id="line.266">                d-=h; a^=c&lt;&lt;15; c+=d;</a>
<span class="sourceLineNo">267</span><a id="line.267">                e-=a; b^=d&gt;&gt;&gt;14; d+=e;</a>
<span class="sourceLineNo">268</span><a id="line.268">                f-=b; c^=e&lt;&lt;20; e+=f;</a>
<span class="sourceLineNo">269</span><a id="line.269">                g-=c; d^=f&gt;&gt;&gt;17; f+=g;</a>
<span class="sourceLineNo">270</span><a id="line.270">                h-=d; e^=g&lt;&lt;14; g+=h;</a>
<span class="sourceLineNo">271</span><a id="line.271">                mem[i  ]=a; mem[i+1]=b; mem[i+2]=c; mem[i+3]=d;</a>
<span class="sourceLineNo">272</span><a id="line.272">                mem[i+4]=e; mem[i+5]=f; mem[i+6]=g; mem[i+7]=h;</a>
<span class="sourceLineNo">273</span><a id="line.273">            }</a>
<span class="sourceLineNo">274</span><a id="line.274">        }</a>
<span class="sourceLineNo">275</span><a id="line.275"></a>
<span class="sourceLineNo">276</span><a id="line.276">        regen();</a>
<span class="sourceLineNo">277</span><a id="line.277">        count = 256;</a>
<span class="sourceLineNo">278</span><a id="line.278">    }</a>
<span class="sourceLineNo">279</span><a id="line.279"></a>
<span class="sourceLineNo">280</span><a id="line.280"></a>
<span class="sourceLineNo">281</span><a id="line.281">    @Override</a>
<span class="sourceLineNo">282</span><a id="line.282">    public final long nextLong() {</a>
<span class="sourceLineNo">283</span><a id="line.283">        if (0 == count--) {</a>
<span class="sourceLineNo">284</span><a id="line.284">            regen();</a>
<span class="sourceLineNo">285</span><a id="line.285">            count = 255;</a>
<span class="sourceLineNo">286</span><a id="line.286">        }</a>
<span class="sourceLineNo">287</span><a id="line.287">        return results[count];</a>
<span class="sourceLineNo">288</span><a id="line.288">    }</a>
<span class="sourceLineNo">289</span><a id="line.289"></a>
<span class="sourceLineNo">290</span><a id="line.290">    /**</a>
<span class="sourceLineNo">291</span><a id="line.291">     * Generates and returns a block of 256 pseudo-random long values.</a>
<span class="sourceLineNo">292</span><a id="line.292">     * @return a freshly-allocated array of 256 pseudo-random longs, with all bits possible</a>
<span class="sourceLineNo">293</span><a id="line.293">     */</a>
<span class="sourceLineNo">294</span><a id="line.294">    public final long[] nextBlock()</a>
<span class="sourceLineNo">295</span><a id="line.295">    {</a>
<span class="sourceLineNo">296</span><a id="line.296">        regen();</a>
<span class="sourceLineNo">297</span><a id="line.297">        final long[] block = new long[256];</a>
<span class="sourceLineNo">298</span><a id="line.298">        System.arraycopy(results, 0, block, 0, 256);</a>
<span class="sourceLineNo">299</span><a id="line.299">        count = 0;</a>
<span class="sourceLineNo">300</span><a id="line.300">        return block;</a>
<span class="sourceLineNo">301</span><a id="line.301">    }</a>
<span class="sourceLineNo">302</span><a id="line.302"></a>
<span class="sourceLineNo">303</span><a id="line.303">    /**</a>
<span class="sourceLineNo">304</span><a id="line.304">     * Generates enough pseudo-random long values to fill {@code data} and assigns them to it.</a>
<span class="sourceLineNo">305</span><a id="line.305">     */</a>
<span class="sourceLineNo">306</span><a id="line.306">    public final void fillBlock(final long[] data)</a>
<span class="sourceLineNo">307</span><a id="line.307">    {</a>
<span class="sourceLineNo">308</span><a id="line.308">        int len, i;</a>
<span class="sourceLineNo">309</span><a id="line.309">        if(data == null || (len = data.length) == 0) return;</a>
<span class="sourceLineNo">310</span><a id="line.310">        for (i = 0; len &gt; 256; i += 256, len -= 256) {</a>
<span class="sourceLineNo">311</span><a id="line.311">            regen();</a>
<span class="sourceLineNo">312</span><a id="line.312">            System.arraycopy(results, 0, data, i, 256);</a>
<span class="sourceLineNo">313</span><a id="line.313">        }</a>
<span class="sourceLineNo">314</span><a id="line.314">        regen();</a>
<span class="sourceLineNo">315</span><a id="line.315">        System.arraycopy(results, 0, data, i, len);</a>
<span class="sourceLineNo">316</span><a id="line.316">        count = len &amp; 255;</a>
<span class="sourceLineNo">317</span><a id="line.317">    }</a>
<span class="sourceLineNo">318</span><a id="line.318"></a>
<span class="sourceLineNo">319</span><a id="line.319">    @Override</a>
<span class="sourceLineNo">320</span><a id="line.320">    public final int next( int bits ) {</a>
<span class="sourceLineNo">321</span><a id="line.321">        //return (int)( nextLong() &gt;&gt;&gt; (64 - bits) );</a>
<span class="sourceLineNo">322</span><a id="line.322">        return (int)( nextLong() &amp; ( 1L &lt;&lt; bits ) - 1 );</a>
<span class="sourceLineNo">323</span><a id="line.323">    }</a>
<span class="sourceLineNo">324</span><a id="line.324"></a>
<span class="sourceLineNo">325</span><a id="line.325">    /**</a>
<span class="sourceLineNo">326</span><a id="line.326">     * Produces another RandomnessSource, but the new one will not produce the same data as this one.</a>
<span class="sourceLineNo">327</span><a id="line.327">     * This is meant to be a "more-secure" generator, so this helps reduce the ability to guess future</a>
<span class="sourceLineNo">328</span><a id="line.328">     * results from a given sequence of output.</a>
<span class="sourceLineNo">329</span><a id="line.329">     * @return another RandomnessSource with the same implementation but no guarantees as to generation</a>
<span class="sourceLineNo">330</span><a id="line.330">     */</a>
<span class="sourceLineNo">331</span><a id="line.331">    @Override</a>
<span class="sourceLineNo">332</span><a id="line.332">    public final IsaacRNG copy() {</a>
<span class="sourceLineNo">333</span><a id="line.333">        return new IsaacRNG(results);</a>
<span class="sourceLineNo">334</span><a id="line.334">    }</a>
<span class="sourceLineNo">335</span><a id="line.335"></a>
<span class="sourceLineNo">336</span><a id="line.336">    @Override</a>
<span class="sourceLineNo">337</span><a id="line.337">    public boolean equals(Object o) {</a>
<span class="sourceLineNo">338</span><a id="line.338">        if (this == o) return true;</a>
<span class="sourceLineNo">339</span><a id="line.339">        if (o == null || getClass() != o.getClass()) return false;</a>
<span class="sourceLineNo">340</span><a id="line.340"></a>
<span class="sourceLineNo">341</span><a id="line.341">        IsaacRNG isaacRNG = (IsaacRNG) o;</a>
<span class="sourceLineNo">342</span><a id="line.342"></a>
<span class="sourceLineNo">343</span><a id="line.343">        if (count != isaacRNG.count) return false;</a>
<span class="sourceLineNo">344</span><a id="line.344">        if (a != isaacRNG.a) return false;</a>
<span class="sourceLineNo">345</span><a id="line.345">        if (b != isaacRNG.b) return false;</a>
<span class="sourceLineNo">346</span><a id="line.346">        if (c != isaacRNG.c) return false;</a>
<span class="sourceLineNo">347</span><a id="line.347">        if (!Arrays.equals(results, isaacRNG.results)) return false;</a>
<span class="sourceLineNo">348</span><a id="line.348">        return Arrays.equals(mem, isaacRNG.mem);</a>
<span class="sourceLineNo">349</span><a id="line.349">    }</a>
<span class="sourceLineNo">350</span><a id="line.350"></a>
<span class="sourceLineNo">351</span><a id="line.351">    @Override</a>
<span class="sourceLineNo">352</span><a id="line.352">    public String toString()</a>
<span class="sourceLineNo">353</span><a id="line.353">    {</a>
<span class="sourceLineNo">354</span><a id="line.354">        return "IsaacRNG with a hidden state (id is " + System.identityHashCode(this) + ')';</a>
<span class="sourceLineNo">355</span><a id="line.355">    }</a>
<span class="sourceLineNo">356</span><a id="line.356">}</a>




























































</pre>
</div>
</main>
</body>
</html>
