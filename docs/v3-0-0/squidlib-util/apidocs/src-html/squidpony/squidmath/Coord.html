<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Source code</title>
<meta name="description" content="source: package: squidpony.squidmath, class: Coord">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source">
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">package squidpony.squidmath;</a>
<span class="sourceLineNo">002</span><a id="line.2"></a>
<span class="sourceLineNo">003</span><a id="line.3">import squidpony.squidgrid.Direction;</a>
<span class="sourceLineNo">004</span><a id="line.4"></a>
<span class="sourceLineNo">005</span><a id="line.5">import java.io.Serializable;</a>
<span class="sourceLineNo">006</span><a id="line.6"></a>
<span class="sourceLineNo">007</span><a id="line.7">/**</a>
<span class="sourceLineNo">008</span><a id="line.8"> * A 2D coordinate with (constant) x and y fields. Coord objects are immutable; a single pool of Coord values, with</a>
<span class="sourceLineNo">009</span><a id="line.9"> * x and y each ranging from -3 to 255, is shared by all users of Coord. This pool helps reduce pressure on the</a>
<span class="sourceLineNo">010</span><a id="line.10"> * garbage collector when many Coord values would have been created for some purpose and quickly discarded; instead</a>
<span class="sourceLineNo">011</span><a id="line.11"> * of creating a new Coord with a constructor, you use the static method {@link #get(int, int)}, which retrieves an</a>
<span class="sourceLineNo">012</span><a id="line.12"> * already-existing Coord from the pool if possible, and always returns a usable Coord.</a>
<span class="sourceLineNo">013</span><a id="line.13"> * &lt;br&gt;</a>
<span class="sourceLineNo">014</span><a id="line.14"> * The Coord class is a fundamental part of SquidLib; any class that uses positions on a grid makes use of it here.</a>
<span class="sourceLineNo">015</span><a id="line.15"> * It finds usage naturally in classes throughout {@link squidpony.squidgrid}, with {@link squidpony.squidgrid.zone}</a>
<span class="sourceLineNo">016</span><a id="line.16"> * providing an abstraction around groups of Coord and {@link squidpony.squidgrid.iterator} providing various ways to</a>
<span class="sourceLineNo">017</span><a id="line.17"> * iterate through the Coords that make up a larger shape. In this package, {@link squidpony.squidmath}, a few classes</a>
<span class="sourceLineNo">018</span><a id="line.18"> * should be pointed out. {@link CoordPacker} is a class with all static methods that provides various ways to compress</a>
<span class="sourceLineNo">019</span><a id="line.19"> * the memory usage of regions made of many Coord values (and can be constructed in other ways but still provide Coords</a>
<span class="sourceLineNo">020</span><a id="line.20"> * later), but since Coords don't use much memory anyway, the real use of the class is for manipulating the shapes and</a>
<span class="sourceLineNo">021</span><a id="line.21"> * sizes of the regions those Coords are part of. {@link GreasedRegion} has similar functionality to CoordPacker, but</a>
<span class="sourceLineNo">022</span><a id="line.22"> * where CoordPacker is purely static, taking and returning regions as encoded, usually-low-memory-cost arrays of</a>
<span class="sourceLineNo">023</span><a id="line.23"> * {@code short} that it considers immutable, a GreasedRegion is a mutable object that allows the same region-altering</a>
<span class="sourceLineNo">024</span><a id="line.24"> * techniques to be applied in-place in a way that is relatively (very) low-time-cost. If deciding between the two,</a>
<span class="sourceLineNo">025</span><a id="line.25"> * GreasedRegion should usually be preferred, and CoordPacker cannot actually be used when storing regions in larger</a>
<span class="sourceLineNo">026</span><a id="line.26"> * than a 256x256 space (usually when the Coord pool has been expanded; see below); GreasedRegion can store potentially</a>
<span class="sourceLineNo">027</span><a id="line.27"> * large positions.</a>
<span class="sourceLineNo">028</span><a id="line.28"> * &lt;br&gt;</a>
<span class="sourceLineNo">029</span><a id="line.29"> * More on the Coord pool used by this class:  Coords can't always be retrieved from the pool; Coord.get constructs a</a>
<span class="sourceLineNo">030</span><a id="line.30"> * new Coord if one of x or y is unusually large (greater than 255) or too negative (below -3). The upper limit of 255</a>
<span class="sourceLineNo">031</span><a id="line.31"> * is not a hard rule; you can increase the limit on the pool by calling {@link #expandPoolTo(int, int)} or</a>
<span class="sourceLineNo">032</span><a id="line.32"> * {@link #expandPool(int, int)}, which cause more memory to be spent initially on storing Coords but can save memory</a>
<span class="sourceLineNo">033</span><a id="line.33"> * or ease GC pressure over the long term by preventing duplicate Coords from being created many times. The pool can</a>
<span class="sourceLineNo">034</span><a id="line.34"> * never shrink because allowing that would cause completely unpredictable results if existing Coords were in use, or</a>
<span class="sourceLineNo">035</span><a id="line.35"> * could easily cause crashes on Android after resuming an application that had previously shrunken the pool due to</a>
<span class="sourceLineNo">036</span><a id="line.36"> * platform quirks. Long story short, you should only expand the pool size when your game needs a larger set of 2D</a>
<span class="sourceLineNo">037</span><a id="line.37"> * points it will commonly use, and in most cases you shouldn't need to change it at all.</a>
<span class="sourceLineNo">038</span><a id="line.38"> * </a>
<span class="sourceLineNo">039</span><a id="line.39"> * Created by Tommy Ettinger on 8/12/2015.</a>
<span class="sourceLineNo">040</span><a id="line.40"> */</a>
<span class="sourceLineNo">041</span><a id="line.41">public class Coord implements Serializable {</a>
<span class="sourceLineNo">042</span><a id="line.42">    private static final long serialVersionUID = 300L;</a>
<span class="sourceLineNo">043</span><a id="line.43"></a>
<span class="sourceLineNo">044</span><a id="line.44">        /** The x-coordinate. */</a>
<span class="sourceLineNo">045</span><a id="line.45">        public final int x;</a>
<span class="sourceLineNo">046</span><a id="line.46"></a>
<span class="sourceLineNo">047</span><a id="line.47">        /** The y-coordinate (the ordinate) */</a>
<span class="sourceLineNo">048</span><a id="line.48">        public final int y;</a>
<span class="sourceLineNo">049</span><a id="line.49"></a>
<span class="sourceLineNo">050</span><a id="line.50">    protected Coord()</a>
<span class="sourceLineNo">051</span><a id="line.51">    {</a>
<span class="sourceLineNo">052</span><a id="line.52">        this(0, 0);</a>
<span class="sourceLineNo">053</span><a id="line.53">    }</a>
<span class="sourceLineNo">054</span><a id="line.54">    protected Coord(final int x, final int y)</a>
<span class="sourceLineNo">055</span><a id="line.55">    {</a>
<span class="sourceLineNo">056</span><a id="line.56">        this.x = x;</a>
<span class="sourceLineNo">057</span><a id="line.57">        this.y = y;</a>
<span class="sourceLineNo">058</span><a id="line.58">    }</a>
<span class="sourceLineNo">059</span><a id="line.59">    public static Coord get(final int x, final int y)</a>
<span class="sourceLineNo">060</span><a id="line.60">    {</a>
<span class="sourceLineNo">061</span><a id="line.61">        if(x &gt;= -3 &amp;&amp; y &gt;= -3 &amp;&amp; x &lt; POOL.length - 3 &amp;&amp; y &lt; POOL[x + 3].length - 3)</a>
<span class="sourceLineNo">062</span><a id="line.62">            return POOL[x + 3][y + 3];</a>
<span class="sourceLineNo">063</span><a id="line.63">        else return new Coord(x, y);</a>
<span class="sourceLineNo">064</span><a id="line.64">    }</a>
<span class="sourceLineNo">065</span><a id="line.65"></a>
<span class="sourceLineNo">066</span><a id="line.66">        /**</a>
<span class="sourceLineNo">067</span><a id="line.67">     * Gets the angle in degrees to go between two Coords.</a>
<span class="sourceLineNo">068</span><a id="line.68">     * When only x is different and {@code to.x} is greater than {@code from.x}, this returns 0.</a>
<span class="sourceLineNo">069</span><a id="line.69">     * When only y is different and {@code to.y} is greater than {@code from.y}, this returns 90.</a>
<span class="sourceLineNo">070</span><a id="line.70">     * When only x is different and {@code to.x} is less than {@code from.x}, this returns 180.</a>
<span class="sourceLineNo">071</span><a id="line.71">     * When only y is different and {@code to.y} is less than {@code from.y}, this returns 270.</a>
<span class="sourceLineNo">072</span><a id="line.72">     * In cases between these, the angle is between those values; it cannot be 360 but it can be very close. This never</a>
<span class="sourceLineNo">073</span><a id="line.73">     * returns a negative angle. Keep in mind, "up" depends on how your code orients the y-axis, and SquidLib generally</a>
<span class="sourceLineNo">074</span><a id="line.74">     * defaults to positive y going toward the bottom of the screen, like how later lines in a paragraph are further</a>
<span class="sourceLineNo">075</span><a id="line.75">     * down on the page.</a>
<span class="sourceLineNo">076</span><a id="line.76">     * &lt;br&gt;</a>
<span class="sourceLineNo">077</span><a id="line.77">     * As a compatibility note, before SquidLib 3.0.0 stable, this used an odd rotation of the normal degrees where 0</a>
<span class="sourceLineNo">078</span><a id="line.78">     * degrees were used when {@code to.y} was greater than {@code from.y} and x was equal. Because that typically runs</a>
<span class="sourceLineNo">079</span><a id="line.79">     * counter to expectations from actual math, the behavior was changed. </a>
<span class="sourceLineNo">080</span><a id="line.80">         * @param from the starting Coord to measure from</a>
<span class="sourceLineNo">081</span><a id="line.81">         * @param to the ending Coord to measure to</a>
<span class="sourceLineNo">082</span><a id="line.82">         * @return The degree from {@code from} to {@code to}; 0 is up</a>
<span class="sourceLineNo">083</span><a id="line.83">         */</a>
<span class="sourceLineNo">084</span><a id="line.84">        public static double degrees(final Coord from, final Coord to) {</a>
<span class="sourceLineNo">085</span><a id="line.85">                return NumberTools.atan2_(to.y - from.y, to.x - from.x) * 360.0;</a>
<span class="sourceLineNo">086</span><a id="line.86">        }</a>
<span class="sourceLineNo">087</span><a id="line.87"></a>
<span class="sourceLineNo">088</span><a id="line.88">    /**</a>
<span class="sourceLineNo">089</span><a id="line.89">     * Provided for compatibility with earlier code that used the AWT Point API.</a>
<span class="sourceLineNo">090</span><a id="line.90">     * @return this Coord, without changes</a>
<span class="sourceLineNo">091</span><a id="line.91">     */</a>
<span class="sourceLineNo">092</span><a id="line.92">    public Coord getLocation()</a>
<span class="sourceLineNo">093</span><a id="line.93">    {</a>
<span class="sourceLineNo">094</span><a id="line.94">        return this;</a>
<span class="sourceLineNo">095</span><a id="line.95">    }</a>
<span class="sourceLineNo">096</span><a id="line.96"></a>
<span class="sourceLineNo">097</span><a id="line.97">    /**</a>
<span class="sourceLineNo">098</span><a id="line.98">     * Takes this Coord, adds x to its x and y to its y, and returns the Coord at that position.</a>
<span class="sourceLineNo">099</span><a id="line.99">     * @param x the amount of x distance to move</a>
<span class="sourceLineNo">100</span><a id="line.100">     * @param y the amount of y distance to move</a>
<span class="sourceLineNo">101</span><a id="line.101">     * @return a Coord (usually cached and not a new instance) that has been moved the specified distance</a>
<span class="sourceLineNo">102</span><a id="line.102">     */</a>
<span class="sourceLineNo">103</span><a id="line.103">    public Coord translate(final int x, final int y)</a>
<span class="sourceLineNo">104</span><a id="line.104">    {</a>
<span class="sourceLineNo">105</span><a id="line.105">        return get(this.x + x, this.y + y);</a>
<span class="sourceLineNo">106</span><a id="line.106">    }</a>
<span class="sourceLineNo">107</span><a id="line.107">    /**</a>
<span class="sourceLineNo">108</span><a id="line.108">     * Takes this Coord, adds x to its x and y to its y, limiting x from 0 to width and limiting y from 0 to height,</a>
<span class="sourceLineNo">109</span><a id="line.109">     * and returns the Coord at that position.</a>
<span class="sourceLineNo">110</span><a id="line.110">     * @param x the amount of x distance to move</a>
<span class="sourceLineNo">111</span><a id="line.111">     * @param y the amount of y distance to move</a>
<span class="sourceLineNo">112</span><a id="line.112">     * @param width one higher than the maximum x value this can use; typically the length of an array</a>
<span class="sourceLineNo">113</span><a id="line.113">     * @param height one higher than the maximum y value this can use; typically the length of an array</a>
<span class="sourceLineNo">114</span><a id="line.114">     * @return a Coord (usually cached and not a new instance) that has been moved the specified distance</a>
<span class="sourceLineNo">115</span><a id="line.115">     */</a>
<span class="sourceLineNo">116</span><a id="line.116">    public Coord translateCapped(final int x, final int y, final int width, final int height)</a>
<span class="sourceLineNo">117</span><a id="line.117">    {</a>
<span class="sourceLineNo">118</span><a id="line.118">        return get(Math.min(Math.max(0, this.x + x), width - 1), Math.min(Math.max(0, this.y + y), height - 1));</a>
<span class="sourceLineNo">119</span><a id="line.119">    }</a>
<span class="sourceLineNo">120</span><a id="line.120"></a>
<span class="sourceLineNo">121</span><a id="line.121">    /**</a>
<span class="sourceLineNo">122</span><a id="line.122">     * Separately combines the x and y positions of this Coord and other, producing a different Coord as their "sum."</a>
<span class="sourceLineNo">123</span><a id="line.123">     * @param other another Coord</a>
<span class="sourceLineNo">124</span><a id="line.124">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x + other.x; y = this.y + other.y}</a>
<span class="sourceLineNo">125</span><a id="line.125">     */</a>
<span class="sourceLineNo">126</span><a id="line.126">    public Coord add(final Coord other)</a>
<span class="sourceLineNo">127</span><a id="line.127">    {</a>
<span class="sourceLineNo">128</span><a id="line.128">        return get(x + other.x, y + other.y);</a>
<span class="sourceLineNo">129</span><a id="line.129">    }</a>
<span class="sourceLineNo">130</span><a id="line.130"></a>
<span class="sourceLineNo">131</span><a id="line.131">    /**</a>
<span class="sourceLineNo">132</span><a id="line.132">     * Separately adds the x and y positions of this Coord to operand, producing a different Coord as their</a>
<span class="sourceLineNo">133</span><a id="line.133">     * "sum."</a>
<span class="sourceLineNo">134</span><a id="line.134">     * @param operand a value to add each of x and y to</a>
<span class="sourceLineNo">135</span><a id="line.135">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x + operand; y = this.y + operand}</a>
<span class="sourceLineNo">136</span><a id="line.136">     */</a>
<span class="sourceLineNo">137</span><a id="line.137">    public Coord add(final int operand)</a>
<span class="sourceLineNo">138</span><a id="line.138">    {</a>
<span class="sourceLineNo">139</span><a id="line.139">        return get(x + operand, y + operand);</a>
<span class="sourceLineNo">140</span><a id="line.140">    }</a>
<span class="sourceLineNo">141</span><a id="line.141"></a>
<span class="sourceLineNo">142</span><a id="line.142">    /**</a>
<span class="sourceLineNo">143</span><a id="line.143">     * Separately adds the x and y positions of this Coord to operand, rounding to the nearest int for each of x</a>
<span class="sourceLineNo">144</span><a id="line.144">     * and y and producing a different Coord as their "sum."</a>
<span class="sourceLineNo">145</span><a id="line.145">     * @param operand a value to add each of x and y to</a>
<span class="sourceLineNo">146</span><a id="line.146">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x + operand; y = this.y +</a>
<span class="sourceLineNo">147</span><a id="line.147">     *          operand}, with both x and y rounded accordingly</a>
<span class="sourceLineNo">148</span><a id="line.148">     */</a>
<span class="sourceLineNo">149</span><a id="line.149">    public Coord add(final double operand)</a>
<span class="sourceLineNo">150</span><a id="line.150">    {</a>
<span class="sourceLineNo">151</span><a id="line.151">        return get((int)Math.round(x + operand), (int)Math.round(y + operand));</a>
<span class="sourceLineNo">152</span><a id="line.152">    }</a>
<span class="sourceLineNo">153</span><a id="line.153"></a>
<span class="sourceLineNo">154</span><a id="line.154">    /**</a>
<span class="sourceLineNo">155</span><a id="line.155">     * Separately subtracts the x and y positions of other from this Coord, producing a different Coord as their</a>
<span class="sourceLineNo">156</span><a id="line.156">     * "difference."</a>
<span class="sourceLineNo">157</span><a id="line.157">     * @param other another Coord</a>
<span class="sourceLineNo">158</span><a id="line.158">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x - other.x; y = this.y - other.y}</a>
<span class="sourceLineNo">159</span><a id="line.159">     */</a>
<span class="sourceLineNo">160</span><a id="line.160">    public Coord subtract(final Coord other)</a>
<span class="sourceLineNo">161</span><a id="line.161">    {</a>
<span class="sourceLineNo">162</span><a id="line.162">        return get(x - other.x, y - other.y);</a>
<span class="sourceLineNo">163</span><a id="line.163">    }</a>
<span class="sourceLineNo">164</span><a id="line.164"></a>
<span class="sourceLineNo">165</span><a id="line.165">    /**</a>
<span class="sourceLineNo">166</span><a id="line.166">     * Separately subtracts operand from the x and y positions of this Coord, producing a different Coord as their</a>
<span class="sourceLineNo">167</span><a id="line.167">     * "difference."</a>
<span class="sourceLineNo">168</span><a id="line.168">     * @param operand a value to subtract from each of x and y</a>
<span class="sourceLineNo">169</span><a id="line.169">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x - operand; y = this.y - operand}</a>
<span class="sourceLineNo">170</span><a id="line.170">     */</a>
<span class="sourceLineNo">171</span><a id="line.171">    public Coord subtract(final int operand)</a>
<span class="sourceLineNo">172</span><a id="line.172">    {</a>
<span class="sourceLineNo">173</span><a id="line.173">        return get(x - operand, y - operand);</a>
<span class="sourceLineNo">174</span><a id="line.174">    }</a>
<span class="sourceLineNo">175</span><a id="line.175"></a>
<span class="sourceLineNo">176</span><a id="line.176">    /**</a>
<span class="sourceLineNo">177</span><a id="line.177">     * Separately subtracts operand from the x and y positions of this Coord, rounding to the nearest int for each of x</a>
<span class="sourceLineNo">178</span><a id="line.178">     * and y and producing a different Coord as their "difference."</a>
<span class="sourceLineNo">179</span><a id="line.179">     * @param operand a value to subtract from each of x and y</a>
<span class="sourceLineNo">180</span><a id="line.180">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x - operand; y = this.y -</a>
<span class="sourceLineNo">181</span><a id="line.181">     *          operand}, with both x and y rounded accordingly</a>
<span class="sourceLineNo">182</span><a id="line.182">     */</a>
<span class="sourceLineNo">183</span><a id="line.183">    public Coord subtract(final double operand)</a>
<span class="sourceLineNo">184</span><a id="line.184">    {</a>
<span class="sourceLineNo">185</span><a id="line.185">        return get((int)Math.round(x - operand), (int)Math.round(y - operand));</a>
<span class="sourceLineNo">186</span><a id="line.186">    }</a>
<span class="sourceLineNo">187</span><a id="line.187">    /**</a>
<span class="sourceLineNo">188</span><a id="line.188">     * Separately multiplies the x and y positions of other from this Coord, producing a different Coord as their</a>
<span class="sourceLineNo">189</span><a id="line.189">     * "product."</a>
<span class="sourceLineNo">190</span><a id="line.190">     * @param other another Coord</a>
<span class="sourceLineNo">191</span><a id="line.191">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x * other.x; y = this.y * other.y}</a>
<span class="sourceLineNo">192</span><a id="line.192">     */</a>
<span class="sourceLineNo">193</span><a id="line.193">    public Coord multiply(final Coord other)</a>
<span class="sourceLineNo">194</span><a id="line.194">    {</a>
<span class="sourceLineNo">195</span><a id="line.195">        return get(x * other.x, y * other.y);</a>
<span class="sourceLineNo">196</span><a id="line.196">    }</a>
<span class="sourceLineNo">197</span><a id="line.197">    /**</a>
<span class="sourceLineNo">198</span><a id="line.198">     * Separately multiplies the x and y positions of this Coord by operand, producing a different Coord as their</a>
<span class="sourceLineNo">199</span><a id="line.199">     * "product."</a>
<span class="sourceLineNo">200</span><a id="line.200">     * @param operand a value to multiply each of x and y by</a>
<span class="sourceLineNo">201</span><a id="line.201">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x * operand; y = this.y * operand}</a>
<span class="sourceLineNo">202</span><a id="line.202">     */</a>
<span class="sourceLineNo">203</span><a id="line.203">    public Coord multiply(final int operand)</a>
<span class="sourceLineNo">204</span><a id="line.204">    {</a>
<span class="sourceLineNo">205</span><a id="line.205">        return get(x * operand, y * operand);</a>
<span class="sourceLineNo">206</span><a id="line.206">    }</a>
<span class="sourceLineNo">207</span><a id="line.207"></a>
<span class="sourceLineNo">208</span><a id="line.208">    /**</a>
<span class="sourceLineNo">209</span><a id="line.209">     * Separately multiplies the x and y positions of this Coord by operand, rounding to the nearest int for each of x</a>
<span class="sourceLineNo">210</span><a id="line.210">     * and y and producing a different Coord as their "product."</a>
<span class="sourceLineNo">211</span><a id="line.211">     * @param operand a value to multiply each of x and y by</a>
<span class="sourceLineNo">212</span><a id="line.212">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x * operand; y = this.y *</a>
<span class="sourceLineNo">213</span><a id="line.213">     *          operand}, with both x and y rounded accordingly</a>
<span class="sourceLineNo">214</span><a id="line.214">     */</a>
<span class="sourceLineNo">215</span><a id="line.215">    public Coord multiply(final double operand)</a>
<span class="sourceLineNo">216</span><a id="line.216">    {</a>
<span class="sourceLineNo">217</span><a id="line.217">        return get((int)Math.round(x * operand), (int)Math.round(y * operand));</a>
<span class="sourceLineNo">218</span><a id="line.218">    }</a>
<span class="sourceLineNo">219</span><a id="line.219"></a>
<span class="sourceLineNo">220</span><a id="line.220">    /**</a>
<span class="sourceLineNo">221</span><a id="line.221">     * Separately divides the x and y positions of this Coord by other, producing a different Coord as their</a>
<span class="sourceLineNo">222</span><a id="line.222">     * "quotient." If other has 0 for x or y, this will throw an exception, as dividing by 0 is expected to do.</a>
<span class="sourceLineNo">223</span><a id="line.223">     * @param other another Coord</a>
<span class="sourceLineNo">224</span><a id="line.224">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / other.x; y = this.y / other.y}</a>
<span class="sourceLineNo">225</span><a id="line.225">     */</a>
<span class="sourceLineNo">226</span><a id="line.226">    public Coord divide(final Coord other)</a>
<span class="sourceLineNo">227</span><a id="line.227">    {</a>
<span class="sourceLineNo">228</span><a id="line.228">        return get(x / other.x, y / other.y);</a>
<span class="sourceLineNo">229</span><a id="line.229">    }</a>
<span class="sourceLineNo">230</span><a id="line.230">    /**</a>
<span class="sourceLineNo">231</span><a id="line.231">     * Separately divides the x and y positions of this Coord by operand, producing a different Coord as their</a>
<span class="sourceLineNo">232</span><a id="line.232">     * "quotient." If operand is 0, this will throw an exception, as dividing by 0 is expected to do.</a>
<span class="sourceLineNo">233</span><a id="line.233">     * @param operand a value to divide each of x and y by</a>
<span class="sourceLineNo">234</span><a id="line.234">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / operand; y = this.y / operand}</a>
<span class="sourceLineNo">235</span><a id="line.235">     */</a>
<span class="sourceLineNo">236</span><a id="line.236">    public Coord divide(final int operand)</a>
<span class="sourceLineNo">237</span><a id="line.237">    {</a>
<span class="sourceLineNo">238</span><a id="line.238">        return get(x / operand, y / operand);</a>
<span class="sourceLineNo">239</span><a id="line.239">    }</a>
<span class="sourceLineNo">240</span><a id="line.240"></a>
<span class="sourceLineNo">241</span><a id="line.241">    /**</a>
<span class="sourceLineNo">242</span><a id="line.242">     * Separately divides the x and y positions of this Coord by operand, flooring to a lower int for each of x and</a>
<span class="sourceLineNo">243</span><a id="line.243">     * y and producing a different Coord as their "quotient." If operand is 0.0, expect strange results (infinity and</a>
<span class="sourceLineNo">244</span><a id="line.244">     * NaN are both possibilities).</a>
<span class="sourceLineNo">245</span><a id="line.245">     * @param operand a value to divide each of x and y by</a>
<span class="sourceLineNo">246</span><a id="line.246">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / operand; y = this.y /</a>
<span class="sourceLineNo">247</span><a id="line.247">     *          operand}, with both x and y rounded accordingly</a>
<span class="sourceLineNo">248</span><a id="line.248">     */</a>
<span class="sourceLineNo">249</span><a id="line.249">    public Coord divide(final double operand)</a>
<span class="sourceLineNo">250</span><a id="line.250">    {</a>
<span class="sourceLineNo">251</span><a id="line.251">        return get((int)(x / operand), (int)(y / operand));</a>
<span class="sourceLineNo">252</span><a id="line.252">    }</a>
<span class="sourceLineNo">253</span><a id="line.253"></a>
<span class="sourceLineNo">254</span><a id="line.254">    /**</a>
<span class="sourceLineNo">255</span><a id="line.255">     * Separately divides the x and y positions of this Coord by operand, rounding to the nearest int for each of x and</a>
<span class="sourceLineNo">256</span><a id="line.256">     * y and producing a different Coord as their "quotient." If operand is 0.0, expect strange results (infinity and</a>
<span class="sourceLineNo">257</span><a id="line.257">     * NaN are both possibilities).</a>
<span class="sourceLineNo">258</span><a id="line.258">     * @param operand a value to divide each of x and y by</a>
<span class="sourceLineNo">259</span><a id="line.259">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / operand; y = this.y /</a>
<span class="sourceLineNo">260</span><a id="line.260">     *          operand}, with both x and y rounded accordingly</a>
<span class="sourceLineNo">261</span><a id="line.261">     */</a>
<span class="sourceLineNo">262</span><a id="line.262">    public Coord divideRounding(final double operand)</a>
<span class="sourceLineNo">263</span><a id="line.263">    {</a>
<span class="sourceLineNo">264</span><a id="line.264">        return get((int)Math.round(x / operand), (int)Math.round(y / operand));</a>
<span class="sourceLineNo">265</span><a id="line.265">    }</a>
<span class="sourceLineNo">266</span><a id="line.266"></a>
<span class="sourceLineNo">267</span><a id="line.267">    /**</a>
<span class="sourceLineNo">268</span><a id="line.268">     * Separately averages the x and y positions of this Coord with other, producing a different Coord as their</a>
<span class="sourceLineNo">269</span><a id="line.269">     * "midpoint."</a>
<span class="sourceLineNo">270</span><a id="line.270">     * @param other another Coord</a>
<span class="sourceLineNo">271</span><a id="line.271">     * @return a Coord (usually cached and not a new instance) halfway between this and other, rounded nearest.</a>
<span class="sourceLineNo">272</span><a id="line.272">     */</a>
<span class="sourceLineNo">273</span><a id="line.273">    public Coord average(final Coord other)</a>
<span class="sourceLineNo">274</span><a id="line.274">    {</a>
<span class="sourceLineNo">275</span><a id="line.275">        return get(Math.round((x + other.x) / 2.0f), Math.round((y + other.y) / 2.0f));</a>
<span class="sourceLineNo">276</span><a id="line.276">    }</a>
<span class="sourceLineNo">277</span><a id="line.277">        /**</a>
<span class="sourceLineNo">278</span><a id="line.278">         * @param d</a>
<span class="sourceLineNo">279</span><a id="line.279">         *            A non-{@code null} direction.</a>
<span class="sourceLineNo">280</span><a id="line.280">         * @return The coordinate obtained by applying {@code d} on {@code this}.</a>
<span class="sourceLineNo">281</span><a id="line.281">         */</a>
<span class="sourceLineNo">282</span><a id="line.282">        public Coord translate(final Direction d) {</a>
<span class="sourceLineNo">283</span><a id="line.283">                return Coord.get(x + d.deltaX, y + d.deltaY);</a>
<span class="sourceLineNo">284</span><a id="line.284">        }</a>
<span class="sourceLineNo">285</span><a id="line.285"></a>
<span class="sourceLineNo">286</span><a id="line.286">        /**</a>
<span class="sourceLineNo">287</span><a id="line.287">         * @param i</a>
<span class="sourceLineNo">288</span><a id="line.288">         * @return {@code (x*i,y*i)}.</a>
<span class="sourceLineNo">289</span><a id="line.289">         */</a>
<span class="sourceLineNo">290</span><a id="line.290">        public Coord scale(final int i) {</a>
<span class="sourceLineNo">291</span><a id="line.291">                return Coord.get(x * i, y * i);</a>
<span class="sourceLineNo">292</span><a id="line.292">        }</a>
<span class="sourceLineNo">293</span><a id="line.293"></a>
<span class="sourceLineNo">294</span><a id="line.294">        /**</a>
<span class="sourceLineNo">295</span><a id="line.295">         * @param i</a>
<span class="sourceLineNo">296</span><a id="line.296">         * @return {@code (x*i,y*j)}.</a>
<span class="sourceLineNo">297</span><a id="line.297">         */</a>
<span class="sourceLineNo">298</span><a id="line.298">        public Coord scale(final int i, final int j) {</a>
<span class="sourceLineNo">299</span><a id="line.299">                return Coord.get(x * i, y * j);</a>
<span class="sourceLineNo">300</span><a id="line.300">        }</a>
<span class="sourceLineNo">301</span><a id="line.301"></a>
<span class="sourceLineNo">302</span><a id="line.302">    public double distance(final double x2, final double y2)</a>
<span class="sourceLineNo">303</span><a id="line.303">    {</a>
<span class="sourceLineNo">304</span><a id="line.304">        return Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));</a>
<span class="sourceLineNo">305</span><a id="line.305">    }</a>
<span class="sourceLineNo">306</span><a id="line.306">    public double distance(final Coord co)</a>
<span class="sourceLineNo">307</span><a id="line.307">    {</a>
<span class="sourceLineNo">308</span><a id="line.308">        return Math.sqrt((co.x - x) * (co.x - x) + (co.y - y) * (co.y - y));</a>
<span class="sourceLineNo">309</span><a id="line.309">    }</a>
<span class="sourceLineNo">310</span><a id="line.310">    public double distanceSq(final double x2, final double y2)</a>
<span class="sourceLineNo">311</span><a id="line.311">    {</a>
<span class="sourceLineNo">312</span><a id="line.312">        return (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);</a>
<span class="sourceLineNo">313</span><a id="line.313">    }</a>
<span class="sourceLineNo">314</span><a id="line.314">    public double distanceSq(final Coord co) { return (co.x - x) * (co.x - x) + (co.y - y) * (co.y - y); }</a>
<span class="sourceLineNo">315</span><a id="line.315"></a>
<span class="sourceLineNo">316</span><a id="line.316">    /**</a>
<span class="sourceLineNo">317</span><a id="line.317">     * Gets a Coord based off this instance but with odd values for x and/or y decreased to the nearest even number.</a>
<span class="sourceLineNo">318</span><a id="line.318">     * May be useful for thin-wall maps as produced by {@link squidpony.squidgrid.mapping.ThinDungeonGenerator} and used</a>
<span class="sourceLineNo">319</span><a id="line.319">     * with {@link squidpony.squidgrid.Adjacency.ThinWallAdjacency}.</a>
<span class="sourceLineNo">320</span><a id="line.320">     * @return a Coord (probably from the pool) with even x and even y, changing (decrementing) only if they are odd</a>
<span class="sourceLineNo">321</span><a id="line.321">     */</a>
<span class="sourceLineNo">322</span><a id="line.322">    public Coord makeEven()</a>
<span class="sourceLineNo">323</span><a id="line.323">    {</a>
<span class="sourceLineNo">324</span><a id="line.324">        return get(x &amp; -2, y &amp; -2);</a>
<span class="sourceLineNo">325</span><a id="line.325">    }</a>
<span class="sourceLineNo">326</span><a id="line.326"></a>
<span class="sourceLineNo">327</span><a id="line.327">    /**</a>
<span class="sourceLineNo">328</span><a id="line.328">     * Gets a Coord based off this instance but with even values for x and/or y increased to the nearest odd number.</a>
<span class="sourceLineNo">329</span><a id="line.329">     * May be useful for thin-wall maps as produced by {@link squidpony.squidgrid.mapping.ThinDungeonGenerator} and used</a>
<span class="sourceLineNo">330</span><a id="line.330">     * with {@link squidpony.squidgrid.Adjacency.ThinWallAdjacency}.</a>
<span class="sourceLineNo">331</span><a id="line.331">     * @return a Coord (probably from the pool) with odd x and odd y, changing (incrementing) only if they are even</a>
<span class="sourceLineNo">332</span><a id="line.332">     */</a>
<span class="sourceLineNo">333</span><a id="line.333">    public Coord makeOdd() {</a>
<span class="sourceLineNo">334</span><a id="line.334">        return get(x | 1, y | 1);</a>
<span class="sourceLineNo">335</span><a id="line.335">    }</a>
<span class="sourceLineNo">336</span><a id="line.336"></a>
<span class="sourceLineNo">337</span><a id="line.337">        /**</a>
<span class="sourceLineNo">338</span><a id="line.338">         * @param c</a>
<span class="sourceLineNo">339</span><a id="line.339">         * @return Whether {@code this} is adjacent to {@code c}. Not that a cell is</a>
<span class="sourceLineNo">340</span><a id="line.340">         *         not adjacent to itself with this method.</a>
<span class="sourceLineNo">341</span><a id="line.341">         */</a>
<span class="sourceLineNo">342</span><a id="line.342">        public boolean isAdjacent(final Coord c) {</a>
<span class="sourceLineNo">343</span><a id="line.343">                switch (Math.abs(x - c.x)) {</a>
<span class="sourceLineNo">344</span><a id="line.344">                case 0:</a>
<span class="sourceLineNo">345</span><a id="line.345">                        return Math.abs(y - c.y) == 1;</a>
<span class="sourceLineNo">346</span><a id="line.346">                case 1:</a>
<span class="sourceLineNo">347</span><a id="line.347">                        return y == c.y || Math.abs(y - c.y) == 1;</a>
<span class="sourceLineNo">348</span><a id="line.348">                default:</a>
<span class="sourceLineNo">349</span><a id="line.349">                        return false;</a>
<span class="sourceLineNo">350</span><a id="line.350">                }</a>
<span class="sourceLineNo">351</span><a id="line.351">        }</a>
<span class="sourceLineNo">352</span><a id="line.352"></a>
<span class="sourceLineNo">353</span><a id="line.353">        /**</a>
<span class="sourceLineNo">354</span><a id="line.354">     * Gets the {@link Direction} needed to get to {@code target} from this; typically this is more useful when target</a>
<span class="sourceLineNo">355</span><a id="line.355">     * and this are adjacent (by {@link #isAdjacent(Coord)}) since that should make it possible to go to target.</a>
<span class="sourceLineNo">356</span><a id="line.356">     * &lt;br&gt;</a>
<span class="sourceLineNo">357</span><a id="line.357">     * Internally, this delegates to {@link Direction#toGoTo(Coord, Coord)}, and some code may prefer using the method</a>
<span class="sourceLineNo">358</span><a id="line.358">     * in Direction instead of this one. Earlier versions of this code only worked for adjacent Coords, which seemed</a>
<span class="sourceLineNo">359</span><a id="line.359">     * like an unnecessary limitation since Direction's version worked for any arguments.</a>
<span class="sourceLineNo">360</span><a id="line.360">         * @param target a non-null {@link Coord}</a>
<span class="sourceLineNo">361</span><a id="line.361">         * @return the direction to go from {@code this} to {@code target}</a>
<span class="sourceLineNo">362</span><a id="line.362">         */</a>
<span class="sourceLineNo">363</span><a id="line.363">        public Direction toGoTo(final Coord target) {</a>
<span class="sourceLineNo">364</span><a id="line.364">            return Direction.toGoTo(this, target);</a>
<span class="sourceLineNo">365</span><a id="line.365">        }</a>
<span class="sourceLineNo">366</span><a id="line.366"></a>
<span class="sourceLineNo">367</span><a id="line.367">    /**</a>
<span class="sourceLineNo">368</span><a id="line.368">     * Returns true if x is between 0 (inclusive) and width (exclusive) and y is between 0 (inclusive) and height</a>
<span class="sourceLineNo">369</span><a id="line.369">     * (exclusive), false otherwise.</a>
<span class="sourceLineNo">370</span><a id="line.370">     * @param width the upper limit on x to check, exclusive</a>
<span class="sourceLineNo">371</span><a id="line.371">     * @param height the upper limit on y to check, exclusive</a>
<span class="sourceLineNo">372</span><a id="line.372">     * @return true if this Coord is within the limits of width and height and has non-negative x and y</a>
<span class="sourceLineNo">373</span><a id="line.373">     */</a>
<span class="sourceLineNo">374</span><a id="line.374">    public boolean isWithin(final int width, final int height)</a>
<span class="sourceLineNo">375</span><a id="line.375">    {</a>
<span class="sourceLineNo">376</span><a id="line.376">        return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &lt; height;</a>
<span class="sourceLineNo">377</span><a id="line.377">    }</a>
<span class="sourceLineNo">378</span><a id="line.378">    /**</a>
<span class="sourceLineNo">379</span><a id="line.379">     * Returns true if x is between minX (inclusive) and maxX (exclusive) and y is between minY (inclusive) and maxY</a>
<span class="sourceLineNo">380</span><a id="line.380">     * (exclusive), false otherwise.</a>
<span class="sourceLineNo">381</span><a id="line.381">     * @param minX the lower limit on x to check, inclusive</a>
<span class="sourceLineNo">382</span><a id="line.382">     * @param minY the lower limit on y to check, inclusive</a>
<span class="sourceLineNo">383</span><a id="line.383">     * @param maxX the upper limit on x to check, exclusive</a>
<span class="sourceLineNo">384</span><a id="line.384">     * @param maxY the upper limit on y to check, exclusive</a>
<span class="sourceLineNo">385</span><a id="line.385">     * @return true if this Coord is within the limits of the given parameters</a>
<span class="sourceLineNo">386</span><a id="line.386">     */</a>
<span class="sourceLineNo">387</span><a id="line.387">    public boolean isWithinRectangle(int minX, int minY, int maxX, int maxY)</a>
<span class="sourceLineNo">388</span><a id="line.388">    {</a>
<span class="sourceLineNo">389</span><a id="line.389">        return x &gt;= minX &amp;&amp; y &gt;= minY &amp;&amp; x &lt; maxX &amp;&amp; y &lt; maxY;</a>
<span class="sourceLineNo">390</span><a id="line.390">    }</a>
<span class="sourceLineNo">391</span><a id="line.391">    public int getX() {</a>
<span class="sourceLineNo">392</span><a id="line.392">        return x;</a>
<span class="sourceLineNo">393</span><a id="line.393">    }</a>
<span class="sourceLineNo">394</span><a id="line.394"></a>
<span class="sourceLineNo">395</span><a id="line.395">    public Coord setX(final int x) {</a>
<span class="sourceLineNo">396</span><a id="line.396">        return get(x, y);</a>
<span class="sourceLineNo">397</span><a id="line.397">    }</a>
<span class="sourceLineNo">398</span><a id="line.398"></a>
<span class="sourceLineNo">399</span><a id="line.399">    public int getY() {</a>
<span class="sourceLineNo">400</span><a id="line.400">        return y;</a>
<span class="sourceLineNo">401</span><a id="line.401">    }</a>
<span class="sourceLineNo">402</span><a id="line.402"></a>
<span class="sourceLineNo">403</span><a id="line.403">    public Coord setY(final int y) {</a>
<span class="sourceLineNo">404</span><a id="line.404">        return get(x, y);</a>
<span class="sourceLineNo">405</span><a id="line.405">    }</a>
<span class="sourceLineNo">406</span><a id="line.406"></a>
<span class="sourceLineNo">407</span><a id="line.407">    @Override</a>
<span class="sourceLineNo">408</span><a id="line.408">    public String toString()</a>
<span class="sourceLineNo">409</span><a id="line.409">    {</a>
<span class="sourceLineNo">410</span><a id="line.410">        return "(" + x + "," + y + ")";</a>
<span class="sourceLineNo">411</span><a id="line.411">    }</a>
<span class="sourceLineNo">412</span><a id="line.412"></a>
<span class="sourceLineNo">413</span><a id="line.413">    /**</a>
<span class="sourceLineNo">414</span><a id="line.414">     * Gets the hash code for this Coord; does not use the standard "auto-complete" style of hash that most IDEs will</a>
<span class="sourceLineNo">415</span><a id="line.415">     * generate, but instead uses a highly-specific technique based on the Rosenberg-Strong pairing function, a Gray</a>
<span class="sourceLineNo">416</span><a id="line.416">     * code, and two XLCG steps at the end. It manages to get extremely low collision rates under many circumstances,</a>
<span class="sourceLineNo">417</span><a id="line.417">     * and very frequently manages to avoid colliding on more than 25% of Coords (making the load factor of most</a>
<span class="sourceLineNo">418</span><a id="line.418">     * hash-based collections fine at a default of 0.75) while often having 0 collisions with some data sets.</a>
<span class="sourceLineNo">419</span><a id="line.419">     * It does much better when Coords are in the default pooled range of -3 or greater.</a>
<span class="sourceLineNo">420</span><a id="line.420">     * &lt;br&gt;</a>
<span class="sourceLineNo">421</span><a id="line.421">     * This gets slightly better collision rates than previous versions used by SquidLib, around 4% across a wide</a>
<span class="sourceLineNo">422</span><a id="line.422">     * variety of rectangular areas (most earlier hashes got about-5%-range collision rates, and using</a>
<span class="sourceLineNo">423</span><a id="line.423">     * {@link java.util.Objects#hash(Object...)} gives more than a 75% collision rate). The previous version, which is</a>
<span class="sourceLineNo">424</span><a id="line.424">     * still available as {@link #cantorHashCode(int, int)}, has slightly better results when used for seeding</a>
<span class="sourceLineNo">425</span><a id="line.425">     * procedural generation based on a Coord (a reasonable usage of this method), but both this hash code and the</a>
<span class="sourceLineNo">426</span><a id="line.426">     * Cantor-based one have excellent randomness in the upper bits of the hash (so if you use a hashCode() result as a</a>
<span class="sourceLineNo">427</span><a id="line.427">     * whole int, then it should be pretty good as a seed). The method before the Cantor-based one,</a>
<span class="sourceLineNo">428</span><a id="line.428">     * {@link #xoroHashCode(int, int)} was structured a little like xoroshiro ({@link XoRoRNG} uses the 64-bit version</a>
<span class="sourceLineNo">429</span><a id="line.429">     * of xoroshiro), and while it had pretty low collision rates (low 5% range), its hash codes changed bits in large</a>
<span class="sourceLineNo">430</span><a id="line.430">     * checkerboard patterns, leaving heavy square-shaped biases in generated results.</a>
<span class="sourceLineNo">431</span><a id="line.431">     * &lt;br&gt;</a>
<span class="sourceLineNo">432</span><a id="line.432">     * This changed at least 7 times in SquidLib's history. In general, you shouldn't rely on hashCodes to stay the</a>
<span class="sourceLineNo">433</span><a id="line.433">     * same across platforms and versions, whether for the JDK or this library. SquidLib (tries to) never depend on the</a>
<span class="sourceLineNo">434</span><a id="line.434">     * unpredictable ordering of some hash-based collections like HashSet and HashMap, instead using its own</a>
<span class="sourceLineNo">435</span><a id="line.435">     * {@link OrderedSet} and {@link OrderedMap}; if you use the ordered kinds, then the only things that matter about</a>
<span class="sourceLineNo">436</span><a id="line.436">     * this hash code are that it's fast (it's fast enough), it's cross-platform compatible (this version avoids using</a>
<span class="sourceLineNo">437</span><a id="line.437">     * long values, which are slow on GWT, and is carefully written to behave the same on GWT as desktop) and that it</a>
<span class="sourceLineNo">438</span><a id="line.438">     * doesn't collide often (which is now much more accurate than in earlier versions of this method).</a>
<span class="sourceLineNo">439</span><a id="line.439">     * @see #rosenbergStrongHashCode(int, int) A static method that gets the same result as this method without involving a Coord</a>
<span class="sourceLineNo">440</span><a id="line.440">     * @return an int that should, for most different Coord values, be significantly different from the other hash codes</a>
<span class="sourceLineNo">441</span><a id="line.441">     */</a>
<span class="sourceLineNo">442</span><a id="line.442">    @Override</a>
<span class="sourceLineNo">443</span><a id="line.443">    public int hashCode() {</a>
<span class="sourceLineNo">444</span><a id="line.444">        //// for Coord, since it can be as low as -3, and Rosenberg-Strong works only for positive integers</a>
<span class="sourceLineNo">445</span><a id="line.445">        final int x = this.x + 3;</a>
<span class="sourceLineNo">446</span><a id="line.446">        final int y = this.y + 3;</a>
<span class="sourceLineNo">447</span><a id="line.447">        //// Rosenberg-Strong pairing function; has excellent traits for keeping the hash gap-less while the</a>
<span class="sourceLineNo">448</span><a id="line.448">        //// inputs fit inside a square, and is still good for rectangles.</a>
<span class="sourceLineNo">449</span><a id="line.449">        final int n = (x &gt;= y ? x * (x + 2) - y : y * y + x);</a>
<span class="sourceLineNo">450</span><a id="line.450">        //// Gray code, XLCG, XLCG (ending on a XOR to stay within int range on GWT).</a>
<span class="sourceLineNo">451</span><a id="line.451">        //// The Gray code moves bits around just a little, but keeps the same power-of-two upper bound.</a>
<span class="sourceLineNo">452</span><a id="line.452">        //// the XLCGs together only really randomize the upper bits; they don't change the lower bit at all.</a>
<span class="sourceLineNo">453</span><a id="line.453">        //// (recall from RNG class that an XLCG is a XOR by a constant, then a multiply by a constant, where</a>
<span class="sourceLineNo">454</span><a id="line.454">        //// the XOR constant, mod 8, is 5, while the multiplier, mod 8, is 3; the order can be reversed too.)</a>
<span class="sourceLineNo">455</span><a id="line.455">        //// ending on a XOR helps mostly for GWT.</a>
<span class="sourceLineNo">456</span><a id="line.456">        return ((n ^ n &gt;&gt;&gt; 1) * 0x9E373 ^ 0xD1B54A35) * 0x125493 ^ 0x91E10DA5;</a>
<span class="sourceLineNo">457</span><a id="line.457">    }</a>
<span class="sourceLineNo">458</span><a id="line.458"></a>
<span class="sourceLineNo">459</span><a id="line.459">    /**</a>
<span class="sourceLineNo">460</span><a id="line.460">     * A static version of an earlier {@link #hashCode()} method of this class, taking x and y as parameters instead of</a>
<span class="sourceLineNo">461</span><a id="line.461">     * requiring a Coord object. Like the earlier hashCode() method, this involves the close-to-optimal mathematical</a>
<span class="sourceLineNo">462</span><a id="line.462">     * Cantor pairing function to distribute x and y without overlap until they get very large. Cantor's pairing</a>
<span class="sourceLineNo">463</span><a id="line.463">     * function can be written simply as {@code ((x + y) * (x + y + 1)) / 2 + y}; it produces sequential results for a</a>
<span class="sourceLineNo">464</span><a id="line.464">     * sequence of positive points traveling in diagonal stripes away from the origin. The finalization steps this</a>
<span class="sourceLineNo">465</span><a id="line.465">     * performs improve the randomness of the lower bits, but also worsen collision rates; most cases involving Coords</a>
<span class="sourceLineNo">466</span><a id="line.466">     * will see lower collision rates from {@link #rosenbergStrongHashCode(int, int)}, but more random results from this</a>
<span class="sourceLineNo">467</span><a id="line.467">     * method.</a>
<span class="sourceLineNo">468</span><a id="line.468">     * @param x the x coordinate of the "imaginary Coord" to hash</a>
<span class="sourceLineNo">469</span><a id="line.469">     * @param y the y coordinate of the "imaginary Coord" to hash</a>
<span class="sourceLineNo">470</span><a id="line.470">     * @return the equivalent to the hashCode() of an "imaginary Coord"</a>
<span class="sourceLineNo">471</span><a id="line.471">     */</a>
<span class="sourceLineNo">472</span><a id="line.472">    public static int cantorHashCode(int x, int y) {</a>
<span class="sourceLineNo">473</span><a id="line.473">        x ^= x &gt;&gt; 31;</a>
<span class="sourceLineNo">474</span><a id="line.474">        y ^= y &gt;&gt; 31;</a>
<span class="sourceLineNo">475</span><a id="line.475">        y += ((x + y) * (x + y + 1) &gt;&gt; 1);</a>
<span class="sourceLineNo">476</span><a id="line.476">        y ^= y &gt;&gt;&gt; 1 ^ y &gt;&gt;&gt; 6;</a>
<span class="sourceLineNo">477</span><a id="line.477">        return (y ^ (y &lt;&lt; 15 | y &gt;&gt;&gt; 17) ^ (y &lt;&lt; 23 | y &gt;&gt;&gt; 9)) * 0x125493 ^ 0xD1B54A35;</a>
<span class="sourceLineNo">478</span><a id="line.478">    }</a>
<span class="sourceLineNo">479</span><a id="line.479">    /**</a>
<span class="sourceLineNo">480</span><a id="line.480">     * A static version of the current {@link #hashCode()} method of this class, taking x and y as parameters instead of</a>
<span class="sourceLineNo">481</span><a id="line.481">     * requiring a Coord object. Like the current hashCode() method, this involves the close-to-optimal mathematical</a>
<span class="sourceLineNo">482</span><a id="line.482">     * Rosenberg-Strong pairing function to distribute x and y without overlap until they get very large. The</a>
<span class="sourceLineNo">483</span><a id="line.483">     * Rosenberg-Strong pairing function can be written simply as {@code ((x &gt;= y) ? x * (x + 2) - y : y * y + x)}; it</a>
<span class="sourceLineNo">484</span><a id="line.484">     * produces sequential results for a sequence of positive points traveling in square "shells" away from the origin.</a>
<span class="sourceLineNo">485</span><a id="line.485">     * &lt;a href="https://hbfs.wordpress.com/2018/08/07/moeud-deux/"&gt;the algorithm is discussed more here&lt;/a&gt;; the only</a>
<span class="sourceLineNo">486</span><a id="line.486">     * changes this makes are adding 3 to x and y (to account for the minimum of -3 in most cases for a Coord), and some</a>
<span class="sourceLineNo">487</span><a id="line.487">     * finalizing steps that help randomize the upper bits of the hash code (the lower bits are quite non-random because</a>
<span class="sourceLineNo">488</span><a id="line.488">     * they can't permit any gaps while optimizing collision rates).</a>
<span class="sourceLineNo">489</span><a id="line.489">     * @param x the x coordinate of the "imaginary Coord" to hash</a>
<span class="sourceLineNo">490</span><a id="line.490">     * @param y the y coordinate of the "imaginary Coord" to hash</a>
<span class="sourceLineNo">491</span><a id="line.491">     * @return the equivalent to the hashCode() of an "imaginary Coord"</a>
<span class="sourceLineNo">492</span><a id="line.492">     */</a>
<span class="sourceLineNo">493</span><a id="line.493">    public static int rosenbergStrongHashCode(int x, int y) {</a>
<span class="sourceLineNo">494</span><a id="line.494">        //// for Coord, since it can be as low as -3, and Rosenberg-Strong works only for positive integers</a>
<span class="sourceLineNo">495</span><a id="line.495">        x += 3;</a>
<span class="sourceLineNo">496</span><a id="line.496">        y += 3;</a>
<span class="sourceLineNo">497</span><a id="line.497">        //// Rosenberg-Strong pairing function; has excellent traits for keeping the hash gap-less while the</a>
<span class="sourceLineNo">498</span><a id="line.498">        //// inputs fit inside a square, and is still good for rectangles.</a>
<span class="sourceLineNo">499</span><a id="line.499">        final int n = (x &gt;= y ? x * (x + 2) - y : y * y + x);</a>
<span class="sourceLineNo">500</span><a id="line.500">        //// Gray code, XLCG, XLCG (ending on a XOR to stay within int range on GWT).</a>
<span class="sourceLineNo">501</span><a id="line.501">        //// The Gray code moves bits around just a little, but keeps the same power-of-two upper bound.</a>
<span class="sourceLineNo">502</span><a id="line.502">        //// the XLCGs together only really randomize the upper bits; they don't change the lower bit at all.</a>
<span class="sourceLineNo">503</span><a id="line.503">        //// (recall from RNG class that an XLCG is a XOR by a constant, then a multiply by a constant, where</a>
<span class="sourceLineNo">504</span><a id="line.504">        //// the XOR constant, mod 8, is 5, while the multiplier, mod 8, is 3; the order can be reversed too.)</a>
<span class="sourceLineNo">505</span><a id="line.505">        //// ending on a XOR helps mostly for GWT.</a>
<span class="sourceLineNo">506</span><a id="line.506">        return ((n ^ n &gt;&gt;&gt; 1) * 0x9E373 ^ 0xD1B54A35) * 0x125493 ^ 0x91E10DA5;</a>
<span class="sourceLineNo">507</span><a id="line.507">    }</a>
<span class="sourceLineNo">508</span><a id="line.508">    /**</a>
<span class="sourceLineNo">509</span><a id="line.509">     * An earlier hashCode() implementation used by this class, now standalone in case you want to replicate the results</a>
<span class="sourceLineNo">510</span><a id="line.510">     * of the older code. This uses only bitwise operations, which tend to be fairly fast on all platforms, and when</a>
<span class="sourceLineNo">511</span><a id="line.511">     * used in a collection it has comparable collision rates to the current hashCode() method (very, very low rates),</a>
<span class="sourceLineNo">512</span><a id="line.512">     * but if used for procedural generation it's simply terrible, with large blocks of nearby x,y points having</a>
<span class="sourceLineNo">513</span><a id="line.513">     * identical values for several bits and all changes happening in a repetitive checkerboard pattern. It is</a>
<span class="sourceLineNo">514</span><a id="line.514">     * structured very similarly to {@link XoRoRNG} and {@link Lathe32RNG} in particular, but using only bitwise math.</a>
<span class="sourceLineNo">515</span><a id="line.515">     * @param x the x coordinate of the "imaginary Coord" to hash</a>
<span class="sourceLineNo">516</span><a id="line.516">     * @param y the y coordinate of the "imaginary Coord" to hash</a>
<span class="sourceLineNo">517</span><a id="line.517">     * @return the equivalent to the hashCode() of an "imaginary Coord"</a>
<span class="sourceLineNo">518</span><a id="line.518">     */</a>
<span class="sourceLineNo">519</span><a id="line.519">    public static int xoroHashCode(final int x, final int y) {</a>
<span class="sourceLineNo">520</span><a id="line.520">        int r = x ^ y;</a>
<span class="sourceLineNo">521</span><a id="line.521">        r ^= (x &lt;&lt; 13 | x &gt;&gt;&gt; 19) ^ (r &lt;&lt; 5) ^ (r &lt;&lt; 28 | r &gt;&gt;&gt; 4);</a>
<span class="sourceLineNo">522</span><a id="line.522">        r = x ^ (r &lt;&lt; 11 | r &gt;&gt;&gt; 21);</a>
<span class="sourceLineNo">523</span><a id="line.523">        return r ^ (r &lt;&lt; 25 | r &gt;&gt;&gt; 7);</a>
<span class="sourceLineNo">524</span><a id="line.524">    }</a>
<span class="sourceLineNo">525</span><a id="line.525"></a>
<span class="sourceLineNo">526</span><a id="line.526">    /**</a>
<span class="sourceLineNo">527</span><a id="line.527">     * Something like hashCode(), but reversible with {@code Coord.decode()}. Works for Coords between roughly -256 and</a>
<span class="sourceLineNo">528</span><a id="line.528">     * 32000 in each of x and y, but will probably only decode to pooled Coords if x and y are both between -3 and 255</a>
<span class="sourceLineNo">529</span><a id="line.529">     * (inclusive for both).</a>
<span class="sourceLineNo">530</span><a id="line.530">     * @return an int as a unique code for this Coord</a>
<span class="sourceLineNo">531</span><a id="line.531">     */</a>
<span class="sourceLineNo">532</span><a id="line.532">    public int encode()</a>
<span class="sourceLineNo">533</span><a id="line.533">    {</a>
<span class="sourceLineNo">534</span><a id="line.534">        return ((x + 256) &lt;&lt; 16) ^ (y + 256);</a>
<span class="sourceLineNo">535</span><a id="line.535">    }</a>
<span class="sourceLineNo">536</span><a id="line.536"></a>
<span class="sourceLineNo">537</span><a id="line.537">    /**</a>
<span class="sourceLineNo">538</span><a id="line.538">     * An alternative to getting a Coord with Coord.get() only to encode() it as the next step. This doesn't create a</a>
<span class="sourceLineNo">539</span><a id="line.539">     * Coord in the middle step. Can be decoded with Coord.decode() to get the (x,y) Coord.</a>
<span class="sourceLineNo">540</span><a id="line.540">     * @param x the x position to encode</a>
<span class="sourceLineNo">541</span><a id="line.541">     * @param y the y position to encode</a>
<span class="sourceLineNo">542</span><a id="line.542">     * @return the coded int that a Coord at (x,y) would produce with encode()</a>
<span class="sourceLineNo">543</span><a id="line.543">     */</a>
<span class="sourceLineNo">544</span><a id="line.544">    public static int pureEncode(final int x, final int y)</a>
<span class="sourceLineNo">545</span><a id="line.545">    {</a>
<span class="sourceLineNo">546</span><a id="line.546">        return ((x + 256) &lt;&lt; 16) ^ (y + 256);</a>
<span class="sourceLineNo">547</span><a id="line.547">    }</a>
<span class="sourceLineNo">548</span><a id="line.548">    /**</a>
<span class="sourceLineNo">549</span><a id="line.549">     * This can take an int produced by {@code someCoord.encode()} and get the original Coord back out of it. It</a>
<span class="sourceLineNo">550</span><a id="line.550">     * works for all pooled Coords where the pool hasn't been expanded past about 32,000 in either dimension. It even</a>
<span class="sourceLineNo">551</span><a id="line.551">     * works for Coords with negative x or y as well, if they are no lower than -256 in either dimension. This will</a>
<span class="sourceLineNo">552</span><a id="line.552">     * almost certainly fail (producing a gibberish Coord that probably won't be pooled) on hashes produced by any other</a>
<span class="sourceLineNo">553</span><a id="line.553">     * class, including subclasses of Coord.</a>
<span class="sourceLineNo">554</span><a id="line.554">     * @param code an encoded int from a Coord, but not a subclass of Coord</a>
<span class="sourceLineNo">555</span><a id="line.555">     * @return the Coord that gave hash as its hashCode()</a>
<span class="sourceLineNo">556</span><a id="line.556">     */</a>
<span class="sourceLineNo">557</span><a id="line.557">    public static Coord decode(final int code)</a>
<span class="sourceLineNo">558</span><a id="line.558">    {</a>
<span class="sourceLineNo">559</span><a id="line.559">        return get((code &gt;&gt;&gt; 16) - 256, (code &amp; 0xFFFF) - 256);</a>
<span class="sourceLineNo">560</span><a id="line.560">    }</a>
<span class="sourceLineNo">561</span><a id="line.561"></a>
<span class="sourceLineNo">562</span><a id="line.562">    @Override</a>
<span class="sourceLineNo">563</span><a id="line.563">    public boolean equals(Object o) {</a>
<span class="sourceLineNo">564</span><a id="line.564">        if (o instanceof Coord) {</a>
<span class="sourceLineNo">565</span><a id="line.565">            Coord other = (Coord) o;</a>
<span class="sourceLineNo">566</span><a id="line.566">            return x == other.x &amp;&amp; y == other.y;</a>
<span class="sourceLineNo">567</span><a id="line.567">        } else {</a>
<span class="sourceLineNo">568</span><a id="line.568">            return false;</a>
<span class="sourceLineNo">569</span><a id="line.569">        }</a>
<span class="sourceLineNo">570</span><a id="line.570">    }</a>
<span class="sourceLineNo">571</span><a id="line.571">    private static Coord[][] POOL = new Coord[259][259];</a>
<span class="sourceLineNo">572</span><a id="line.572">    static {</a>
<span class="sourceLineNo">573</span><a id="line.573">        int width = POOL.length, height = POOL[0].length;</a>
<span class="sourceLineNo">574</span><a id="line.574">        for (int i = 0; i &lt; width; i++) {</a>
<span class="sourceLineNo">575</span><a id="line.575">            for (int j = 0; j &lt; height; j++) {</a>
<span class="sourceLineNo">576</span><a id="line.576">                POOL[i][j] = new Coord(i - 3, j - 3);</a>
<span class="sourceLineNo">577</span><a id="line.577">            }</a>
<span class="sourceLineNo">578</span><a id="line.578">        }</a>
<span class="sourceLineNo">579</span><a id="line.579">    }</a>
<span class="sourceLineNo">580</span><a id="line.580"></a>
<span class="sourceLineNo">581</span><a id="line.581">    /**</a>
<span class="sourceLineNo">582</span><a id="line.582">     * Gets the width of the pool used as a cache for Coords, not including negative Coords.</a>
<span class="sourceLineNo">583</span><a id="line.583">     * Unless expandPool() has been called, this should be 256.</a>
<span class="sourceLineNo">584</span><a id="line.584">     * Useful for finding the upper (exclusive) bound for x values that can be used efficiently in Coords.</a>
<span class="sourceLineNo">585</span><a id="line.585">     * Requesting a Coord with a x greater than or equal to this value will result in a new Coord being allocated and</a>
<span class="sourceLineNo">586</span><a id="line.586">     * not cached, which may cause problems with code that expects the normal reference equality of Coords to be upheld</a>
<span class="sourceLineNo">587</span><a id="line.587">     * and in extreme cases may require more time garbage collecting than is normally necessary.</a>
<span class="sourceLineNo">588</span><a id="line.588">     * @return the width of the Coord cache, disregarding negative Coords</a>
<span class="sourceLineNo">589</span><a id="line.589">     */</a>
<span class="sourceLineNo">590</span><a id="line.590">    public static int getCacheWidth()</a>
<span class="sourceLineNo">591</span><a id="line.591">    {</a>
<span class="sourceLineNo">592</span><a id="line.592">        return POOL.length - 3;</a>
<span class="sourceLineNo">593</span><a id="line.593">    }</a>
<span class="sourceLineNo">594</span><a id="line.594"></a>
<span class="sourceLineNo">595</span><a id="line.595">    /**</a>
<span class="sourceLineNo">596</span><a id="line.596">     * Gets the height of the pool used as a cache for Coords, not including negative Coords.</a>
<span class="sourceLineNo">597</span><a id="line.597">     * Unless expandPool() has been called, this should be 256.</a>
<span class="sourceLineNo">598</span><a id="line.598">     * Useful for finding the upper (exclusive) bound for y values that can be used efficiently in Coords.</a>
<span class="sourceLineNo">599</span><a id="line.599">     * Requesting a Coord with a y greater than or equal to this value will result in a new Coord being allocated and</a>
<span class="sourceLineNo">600</span><a id="line.600">     * not cached, which may cause problems with code that expects the normal reference equality of Coords to be upheld</a>
<span class="sourceLineNo">601</span><a id="line.601">     * and in extreme cases may require more time garbage collecting than is normally necessary.</a>
<span class="sourceLineNo">602</span><a id="line.602">     * @return the height of the Coord cache, disregarding negative Coords</a>
<span class="sourceLineNo">603</span><a id="line.603">     */</a>
<span class="sourceLineNo">604</span><a id="line.604">    public static int getCacheHeight()</a>
<span class="sourceLineNo">605</span><a id="line.605">    {</a>
<span class="sourceLineNo">606</span><a id="line.606">        return POOL[0].length - 3;</a>
<span class="sourceLineNo">607</span><a id="line.607">    }</a>
<span class="sourceLineNo">608</span><a id="line.608"></a>
<span class="sourceLineNo">609</span><a id="line.609">    /**</a>
<span class="sourceLineNo">610</span><a id="line.610">     * Enlarges the pool of cached Coords to the given width and height, and doesn't change</a>
<span class="sourceLineNo">611</span><a id="line.611">     * a dimension if it would be reduced in size.</a>
<span class="sourceLineNo">612</span><a id="line.612">     * Cached Coord values will be reused by Coord.get instead of re-allocated each time.</a>
<span class="sourceLineNo">613</span><a id="line.613">     * The default pool allows Coords with x and y each between -3 and 255, inclusive, to</a>
<span class="sourceLineNo">614</span><a id="line.614">     * be cached, and is considered to have width and height of 256 to begin with. Giving a</a>
<span class="sourceLineNo">615</span><a id="line.615">     * width greater than 256 will allow Coords with x greater than 255 to be cached;</a>
<span class="sourceLineNo">616</span><a id="line.616">     * likewise for height. If width or height is smaller than the current cache width or</a>
<span class="sourceLineNo">617</span><a id="line.617">     * height, that dimension will not change, but the other still may if it is valid. You</a>
<span class="sourceLineNo">618</span><a id="line.618">     * cannot shrink the pool size.</a>
<span class="sourceLineNo">619</span><a id="line.619">     * @param width the new width for the pool of cached Coords; will be ignored if smaller than the current width</a>
<span class="sourceLineNo">620</span><a id="line.620">     * @param height the new height for the pool of cached Coords; will be ignored if smaller than the current height</a>
<span class="sourceLineNo">621</span><a id="line.621">     */</a>
<span class="sourceLineNo">622</span><a id="line.622">    public static void expandPoolTo(final int width, final int height)</a>
<span class="sourceLineNo">623</span><a id="line.623">    {</a>
<span class="sourceLineNo">624</span><a id="line.624">        expandPool(Math.max(0, width + 3 - POOL.length), Math.max(0, height + 3 - POOL[0].length));</a>
<span class="sourceLineNo">625</span><a id="line.625">    }</a>
<span class="sourceLineNo">626</span><a id="line.626"></a>
<span class="sourceLineNo">627</span><a id="line.627">    /**</a>
<span class="sourceLineNo">628</span><a id="line.628">     * Enlarges the pool of cached Coords by the given amount of expansion for x and y.</a>
<span class="sourceLineNo">629</span><a id="line.629">     * Cached Coord values will be reused by Coord.get instead of re-allocated each time.</a>
<span class="sourceLineNo">630</span><a id="line.630">     * The default pool allows Coords with x and y each between -3 and 255, inclusive, to</a>
<span class="sourceLineNo">631</span><a id="line.631">     * be cached, and this can increase the size in the positive direction. If either</a>
<span class="sourceLineNo">632</span><a id="line.632">     * xIncrease or yIncrease is negative, this method returns immediately and does nothing</a>
<span class="sourceLineNo">633</span><a id="line.633">     * else; the same is true of both arguments are zero. You cannot shrink the pool size.</a>
<span class="sourceLineNo">634</span><a id="line.634">     * @param xIncrease the amount to increase cache's width by</a>
<span class="sourceLineNo">635</span><a id="line.635">     * @param yIncrease the amount to increase cache's height by</a>
<span class="sourceLineNo">636</span><a id="line.636">     */</a>
<span class="sourceLineNo">637</span><a id="line.637">    public static void expandPool(final int xIncrease, final int yIncrease)</a>
<span class="sourceLineNo">638</span><a id="line.638">    {</a>
<span class="sourceLineNo">639</span><a id="line.639">        if(xIncrease &lt; 0 || yIncrease &lt; 0 || (xIncrease | yIncrease) == 0 )</a>
<span class="sourceLineNo">640</span><a id="line.640">            return;</a>
<span class="sourceLineNo">641</span><a id="line.641">        int width = POOL.length, height = POOL[0].length;</a>
<span class="sourceLineNo">642</span><a id="line.642">        Coord[][] POOL2 = new Coord[width + xIncrease][height + yIncrease];</a>
<span class="sourceLineNo">643</span><a id="line.643">        for (int i = 0; i &lt; width; i++) {</a>
<span class="sourceLineNo">644</span><a id="line.644">            POOL2[i] = new Coord[height + yIncrease];</a>
<span class="sourceLineNo">645</span><a id="line.645">            System.arraycopy(POOL[i], 0, POOL2[i], 0, height);</a>
<span class="sourceLineNo">646</span><a id="line.646">            for (int j = 0; j &lt; height + yIncrease; j++) {</a>
<span class="sourceLineNo">647</span><a id="line.647">                if(POOL2[i][j] == null) POOL2[i][j] = new Coord(i - 3, j - 3);</a>
<span class="sourceLineNo">648</span><a id="line.648">            }</a>
<span class="sourceLineNo">649</span><a id="line.649">        }</a>
<span class="sourceLineNo">650</span><a id="line.650">        for (int i = width; i &lt; width + xIncrease; i++) {</a>
<span class="sourceLineNo">651</span><a id="line.651">            POOL2[i] = new Coord[height + yIncrease];</a>
<span class="sourceLineNo">652</span><a id="line.652">            for (int j = 0; j &lt; height + yIncrease; j++) {</a>
<span class="sourceLineNo">653</span><a id="line.653">                POOL2[i][j] = new Coord(i - 3, j - 3);</a>
<span class="sourceLineNo">654</span><a id="line.654">            }</a>
<span class="sourceLineNo">655</span><a id="line.655">        }</a>
<span class="sourceLineNo">656</span><a id="line.656">        POOL = POOL2;</a>
<span class="sourceLineNo">657</span><a id="line.657">    }</a>
<span class="sourceLineNo">658</span><a id="line.658"></a>
<span class="sourceLineNo">659</span><a id="line.659">    public Coord interpolate(Coord end, float amountTraveled) {</a>
<span class="sourceLineNo">660</span><a id="line.660">        return Coord.get(x + Math.round((end.x - x) * amountTraveled),</a>
<span class="sourceLineNo">661</span><a id="line.661">                y + Math.round((end.y - y) * amountTraveled));</a>
<span class="sourceLineNo">662</span><a id="line.662">    }</a>
<span class="sourceLineNo">663</span><a id="line.663">}</a>




























































</pre>
</div>
</main>
</body>
</html>
