<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>CoordPacker (squidlib-util 3.0.0)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: squidpony.squidmath, class: CoordPacker">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9,"i57":9,"i58":9,"i59":9,"i60":9,"i61":9,"i62":9,"i63":9,"i64":9,"i65":9,"i66":9,"i67":9,"i68":9,"i69":9,"i70":9,"i71":9,"i72":9,"i73":9,"i74":9,"i75":9,"i76":9,"i77":9,"i78":9,"i79":9,"i80":9,"i81":9,"i82":9,"i83":9,"i84":9,"i85":9,"i86":9,"i87":9,"i88":9,"i89":9,"i90":9,"i91":9,"i92":9,"i93":9,"i94":9,"i95":9,"i96":9,"i97":9,"i98":9,"i99":9,"i100":9,"i101":9,"i102":9,"i103":9,"i104":9,"i105":9,"i106":9,"i107":9,"i108":9,"i109":9,"i110":9,"i111":9,"i112":9,"i113":9,"i114":9,"i115":9,"i116":9,"i117":9,"i118":9,"i119":9,"i120":9,"i121":9,"i122":9,"i123":9,"i124":9,"i125":9,"i126":9,"i127":9,"i128":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flexBox">
<header role="banner" class="flexHeader">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/CoordPacker.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="skipNav"><a id="skip.navbar.top">
<!--   -->
</a></div>
</nav>
</header>
<div class="flexContent">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">squidpony.squidmath</a></div>
<h1 title="Class CoordPacker" class="title">Class CoordPacker</h1>
</div>
<div class="contentContainer">
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">java.lang.Object</a>
<div class="inheritance">squidpony.squidmath.CoordPacker</div>
</div>
<section class="description">
<hr>
<pre>public class <a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.196">CoordPacker</a>
extends <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">Object</a></pre>
<div class="block">Provides static methods to encode Coords as single primitive ints in various ways, hence the namesake, but also
 provides advanced methods to encode 2D arrays of various sorts produced by SquidLib in extremely memory-efficient
 representations, and decode those representations to various types of 2D array on-demand. IMPORTANT: you must call
 <a href="#init()"><code>init()</code></a> before using this class if you do not already use a SquidLib class that does so. It is a good habit
 to call init() in your main() method or primary game entry point if you use CoordPacker. Failure to call init() will
 not result in exceptions, but will make results inaccurate.

 There's a detailed introduction
 <a href="https://github.com/SquidPony/SquidLib/wiki/Handling-Map-Regions-with-CoordPacker">on the SquidLib wiki</a>,
 which is probably the best way to learn the techniques possible with this class. Most methods in this aren't useful
 on their own, but can be mixed and matched to get specific regions from a map, such as all floors not adjacent to a
 wall, or all grass within 3 squares of deep or shallow water, with walls blocking the distance measurement. You can
 also use packed data that this class produces as keys for <a href="RegionMap.html" title="class in squidpony.squidmath"><code>RegionMap</code></a> to associate values with regions.
 <br>
 NOTE: Internally, this class is atypically complex and low-level for SquidLib because it is attempting to attain some
 very challenging performance gains. You should not consider it idiomatic SquidLib code or start modifying it unless
 you have a good grasp of bitwise operations and the performance implications, particularly in regard to memory
 consumption, that higher-level and more convenient Java programming techniques have.
 <br>
 NOTE 2: This class fills a role that is very similar to <a href="GreasedRegion.html" title="class in squidpony.squidmath"><code>GreasedRegion</code></a>, and there are times when code will do
 better using CoordPacker than GreasedRegion and vice versa. GreasedRegion uses objects and tries to change them
 in-place whenever possible instead of allocating new data; CoordPacker uses short[] values that it never changes
 in-place and frequently allocates new short[] values to represent data. GreasedRegion stores the full map without any
 compression beyond "one bit per cell" and always needs to store all cells on the map (sometimes slightly more);
 CoordPacker can compress some data to significantly less than one bit per cell, and doesn't care about the maximum
 bounds of the map as long as it fits inside a 256x256 square. GreasedRegion is significantly faster than CoordPacker
 when performing any operations that move, shrink, or expand an area, such as <a href="#expand(short%5B%5D,int,int,int)"><code>expand(short[], int, int, int)</code></a>,
 <a href="#retract(short%5B%5D,int,int,int)"><code>retract(short[], int, int, int)</code></a>, and <a href="#translate(short%5B%5D,int,int,int,int)"><code>translate(short[], int, int, int, int)</code></a>. CoordPacker usually
 (not always) uses somewhat less memory than GreasedRegion, though both use very little unless the maps are very
 large or very numerous. Both can do essentially the same things, except that GreasedRegion has no equivalent to the
 <a href="#packMulti(byte%5B%5D%5B%5D,int)"><code>packMulti(byte[][], int)</code></a> and other Multi kinds of method, no <a href="#radiate(short%5B%5D,short%5B%5D,int)"><code>radiate(short[], short[], int)</code></a>, and no
 <a href="#reachable(short%5B%5D,short%5B%5D,squidpony.squidai.Reach)"><code>reachable(short[], short[], Reach)</code></a>, while CoordPacker has no equivalent to
 <a href="GreasedRegion.html#expandSeriesToLimit()"><code>GreasedRegion.expandSeriesToLimit()</code></a> and other ToLimit kinds of method, no
 <a href="GreasedRegion.html#toggle(int,int)"><code>GreasedRegion.toggle(int, int)</code></a>, no <a href="GreasedRegion.html#deteriorate(squidpony.squidmath.RandomnessSource,int)"><code>GreasedRegion.deteriorate(RandomnessSource, int)</code></a>, no
 <a href="GreasedRegion.html#insert(int,int,squidpony.squidmath.GreasedRegion)"><code>GreasedRegion.insert(int, int, GreasedRegion)</code></a> (though CoordPacker can generally use
 <a href="#unionPacked(short%5B%5D,short%5B%5D)"><code>unionPacked(short[], short[])</code></a> for that), and several other methods don't have equivalents. In general, you
 will probably find GreasedRegion more intuitive because it involves working with objects instead of a short[] that is
 treated like a particular kind of data, and the methods are also somewhat more clearly-named. GreasedRegion also
 implements Collection of Coord, while the short[] data can't implement anything. A way around this for CoordPacker is
 the <a href="../squidgrid/zone/CoordPackerZone.html" title="class in squidpony.squidgrid.zone"><code>CoordPackerZone</code></a> class; both that and GreasedRegion implement the
 <a href="../squidgrid/zone/Zone.html" title="interface in squidpony.squidgrid.zone"><code>Zone</code></a> interface, which ensures a way to get a List of Coord from the Zone.
 <br>
 The pack() methods in this class take a 2D array with a clear division between cells in an "on" state and cells in an
 "off" state, and they produce a very tightly compressed short array that can be losslessly decompressed with the
 unpack() methods to a boolean 2D array that stores equivalent on/off data to the input. The packMulti() method in
 this class takes a double 2D array that has more than two states that may need to be encoded, such as an FOV map that
 stores light level as a value between 0.0 and 1.0 instead of just on or off, and an additional double array that
 defines what states should be distinguished in the result (for example, if the FOV can store values that differ by
 0.1 for a FOV radius of 10, you could pass the array of 10 levels: 0.1, 0.2, 0.3, ... 0.9, 1.0). The value returned
 by packMulti() is a short[][], but with different array lengths for each sub-array (a jagged array); the length of
 the short[][] is the same as the length of the levels array, and each sub-array corresponds to a different level of
 FOV lighting or other gradation as defined in levels. This short[][] can be passed to the unpackMultiByte() method in
 this class to produce a byte 2D array where the original levels correspond to progressively greater bytes, with 0
 used for cells that were less than the smallest value in levels, 1 for values that were only greater than the
 smallest value, and no others, in levels, then 2 for larger values, etc. until it places a byte with a value equal to
 the length of levels in the cells that are the highest. There is also the unpackMultiDouble() method in this class
 that takes the same short[][] unpackMultiByte() can take, but also takes a levels double array that should be the
 same as the one used to compress short[][]. It will return a double 2D array with any cells that were smaller than
 the smallest value in levels assigned 0.0, and any other cells will be assigned a double that corresponds to the
 highest value in levels that does not exceed the original double at that location in the unpacked data. To make this
 more clear, if you have 4 levels: [0.25, 0.5, 0.75, 1.0] and you packMulti() on an FOV with a large radius and
 sample values 0.1, 0.45, 0.8, 1.0, you will get a packed short[][] with 4 sub-arrays to match the 4 levels. If you
 then pass the short[][] and levels to unpackMultiDouble later, much of the same radius will be filled, but because
 the sample value 0.1 was less than the smallest value in levels, its cell will be given 0.0. What was originally 0.45
 will be given the next-lower levels value, 0.25; 0.8 will be given 0.75, and 1.0 will remain 1.0.
 <br>
 This compression is meant to produce a short[] or short[][] that uses as little memory as possible for the specific
 case of compressing maps with these qualities:
 <ul>
     <li>Maps are not especially large for a grid-based game; the maximum size is 256x256 cells.</li>
     <li>The vast majority of that 256x256 space is either unused or filled with cells no greater than 0.</li>
     <li>The cells that are greater than 0 are mostly near each other, though separate areas are possible.</li>
 </ul>
 These properties are all shared by typical roguelike FOV maps, and the specificity of these circumstances mean
 extraordinarily dense compression can be achieved using the right combination of algorithms. In early testing,
 using dungeon maps generated by <a href="../squidgrid/mapping/DungeonGenerator.html" title="class in squidpony.squidgrid.mapping"><code>DungeonGenerator</code></a> that should be typical of
 roguelike maps and a diamond-shaped FOV with radius 8, compression of the short[] returned by pack() vs.
 the original double[][] (which wastefully represents 2 states with 8 bytes) yields average memory usage ratios
 between (with relatively optimal parameters) 0.0001237905030818498 in one of the best cases, and (with some very
 poor parameters for the dungeon, but still using a realistic FOV map) 0.003135985198889917 in one of the worst.
 <br>
 This table shows the results for the average of 100 runs of pack() in a map with a "good size" and 100 runs in a map
 with a "bad size." Both the compression ratio vs. a double[][] that stores only whether a cell is on or off and a
 boolean[][] that stores the same information are provided.
 <table BORDER CELLPADDING=3 CELLSPACING=1>
     <caption>Memory Performance of CoordPacker</caption>
     <tr>
         <th></th>
         <th>Bytes of RAM used, double 2D array</th>
         <th>Bytes of RAM used, boolean 2D array</th>
         <th>Average Bytes of RAM used, short 1D array (packed)</th>
         <th>Compression ratio, packed vs. doubles</th>
         <th>Compression ratio, packed vs. booleans</th>
     </tr>
     <tr>
         <td>240x240 dungeon map (good size)</td>
         <td>464656</td>
         <td>61456</td>
         <td>57.52</td>
         <td>0.0001237905030818498</td>
         <td>0.000935954178599323</td>
     </tr>
     <tr>
         <td>30x70 dungeon map (bad size)</td>
         <td>17296</td>
         <td>2656</td>
         <td>54.24</td>
         <td>0.003135985198889917</td>
         <td>0.020421686746987953</td>
     </tr>
 </table>
 In the best-case scenario of packing a 240x240 double array to a short array encoding two states, the result
 uses less than 1/8000 the memory that the input uses. Writing to disk can store both input and output more
 efficiently, but the method used here should ensure that even encoding the input FOV map as a flat sequence of
 single bits and compressing the file should still be on par with the output of pack() due to optimization to
 ensure nearby cells on a map are compressed together.
 <br>
 The technique used by this class is to walk along a Hilbert Curve, storing whether the walk is traveling through
 "on" or "off" cells, which can be determined by a comparison to a number or a boolean, then encoding alternate shorts
 into the short[] to be returned, with even-number indices (starting at 0) in the array corresponding to the number of
 contiguous cells walked through in the "off" state, and odd-number indices corresponding to the number of
 contiguous cells walked through in the "on" state. A user of this library does not need to understand the details
 and properties of this algorithm unless they want to generate maps that will compress more optimally. In short:
 <ul>
 <li>Smaller maps tend to be processed faster by pack(), since the nature of a Hilbert Curve means a map that
 fits in one half the width and one half the height of the curve only needs to walk one quarter of the Curve to
 get all the needed information.</li>
 <li>Smaller maps also compress less optimally ratio-wise than larger maps with the same area of "on" cells. The
 compression ratio approaches its best when using very large maps, such as 240x240, and encoding just a few
 cells on that map (such as for a small FOV radius or a cramped room). A map that is entirely "off" uses only 16
 bytes of RAM (the minimum for any array on the JVM).</li>
 <li>Unusually shaped maps can cause compression problems by forcing adjacent cells to sometimes require walking
 more cells than needed to get to an adjacent cell. For example, a map greater than 64 cells tall, but less than
 33 cells wide, has properties that require walking through a large empty area to get to sometimes only a few
 cells that are "on" before it walks back through empty space. Similarly, a map that is greater than 128 cells
 tall but is otherwise narrow has the same property of requiring walking through empty space, but also requires
 the entire Curve to be walked even if the map's width is only a tiny fraction of the Curve's 256 cells.</li>
 </ul>
 <b>In shorter-than-short</b>, you'll get particularly good results for compression speed and compressed size with
 maps approximately these sizes: 240x240, 240x120, 120x120, 60x120, 60x60, 60x30, 30x30. The biggest maps have the
 best relative gain on compressed memory usage, and the smallest maps have the best compression speed.
<br>
 The details of the algorithm are not terribly complex once you understand the Hilbert Curve. The simplified
 version of the Hilbert Curve that SquidLib employs is essentially a path through a square grid (it must have side
 lengths that are powers of 2, and SquidLib always uses 256), starting in the corner cell (x=0,y=0), ending in the
 corner cell (x=0,y=255), and traversing every other cell on the grid along its path without ever traveling in a
 loop, crossing the path it walked, or moving in any direction but one cell up, down, left, or right. The shape
 of the path this takes has the useful property of keeping most groups of cells walked through with similar x and
 y at similar distances traveled from the start of the curve, and most groups of cells with very dissimilar x and
 y at very different distances traveled. Since FOV and several other things you might want to encode with CoordPacker
 tends to be clustered in small areas and occupy more complicated shapes than straight lines due to dungeon layout
 blocking sections of FOV, the simplest paths of a wide zigzag from side-to-side, or an outward-going-in spiral, have
 rather poor behavior when determining how much of an area they pass through contiguously. The contiguous area trait
 is important because of the next step: Run-Length Encoding.
<br>
 Run-Length Encoding is much simpler to explain than the Hilbert Curve, especially without visual aids. In the version
 SquidLib uses, only on or off states need to be recorded, so the method used here is smaller and more efficient than
 most methods that need to store repeated characters in strings (and letters, numbers, and punctuation clearly have
 more than 2 states). The technique works like this:
<br>
 Start in the "off" state, walk down the Hilbert Curve counting how many cells you walk through that are still "off,"
 and when you encounter a cell that is "on," you write down how many cells were off, transition to the "on" state. Now
 keep walking the Hilbert Curve, but counting how many cells you walk through that are still "on." When you reach
 an "off" cell, write down how many were "on," then start walking and counting again, with your count starting at 0.
 Repeat until you reach the end of the Hilbert Curve, but if you reach the end while counting "off" cells, you don't
 need to write down that number (a shortcut allows many maps to stop sooner than the 65,536th element of the Curve).
<br>
 There are some additional traits that relate to the edge of the map being treated as "off" even though no
 calculations are done for cells out of map bounds, and some optimizations that ensure that maps that are smaller than
 a half, a quarter, or an eighth of the 256x256 curve in both dimensions (and sometimes just one) only need to walk a
 portion of the Hilbert Curve and simply skip the rest without walking it.
<br>
 The Hilbert Curve has not been definitively proven to be the best possible path to ensure 1D distance and 2D location
 are similar, but it has been extensively used for tasks that require similar locations for similar distances (in
 particular, it has become useful in supercomputing clusters for allocating related work to physically nearby
 machines), and since there hasn't been anything with better spatial properties discovered yet, this technique should
 remain useful for some time.
 <br>
 Created by Tommy Ettinger on 10/1/2015.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Tommy Ettinger</dd>
</dl>
</section>
<section class="summary">
<ul class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<li class="blockList">
<section class="fieldSummary"><a id="field.summary">
<!--   -->
</a>
<h2>Field Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ALL_ON">ALL_ON</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ALL_WALL">ALL_WALL</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DEPTH">DEPTH</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hilbert3Distances">hilbert3Distances</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hilbert3X">hilbert3X</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hilbert3Y">hilbert3Y</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hilbert3Z">hilbert3Z</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hilbertDistances">hilbertDistances</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hilbertX">hilbertX</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hilbertY">hilbertY</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mooreDistances">mooreDistances</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mooreX">mooreX</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mooreY">mooreY</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="tableTab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#allPacked(short%5B%5D)">allPacked</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Gets all positions that are "on" in the given packed array, without unpacking it, and returns them as a Coord[].</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#allPackedHilbert(short%5B%5D)">allPackedHilbert</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Gets all positions that are "on" in the given packed array, without unpacking it, and returns them as an array of
 Hilbert Curve indices.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#apartPacked(short%5B%5D,int)">apartPacked</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;minDistance)</code></th>
<td class="colLast">
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, keeps only positions that are
 at least minDistance apart from other positions this will return, and returns the positions as a Coord[].</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#apartPacked(short%5B%5D,int,boolean)">apartPacked</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;minDistance,
boolean&nbsp;eightWay)</code></th>
<td class="colLast">
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, keeps only positions that are
 at least minDistance apart from other positions this will return, and returns the positions as a Coord[].</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#apartPackedHilbert(short%5B%5D,int)">apartPackedHilbert</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;minDistance)</code></th>
<td class="colLast">
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, keeps only positions that are
 at least minDistance apart from other positions this will return, and returns the positions as an array of
 Hilbert Curve indices.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#apartPackedHilbert(short%5B%5D,int,boolean)">apartPackedHilbert</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;minDistance,
boolean&nbsp;eightWay)</code></th>
<td class="colLast">
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, keeps only positions that are
 at least minDistance apart from other positions this will return, and returns the positions as an array of
 Hilbert Curve indices.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bounds(short%5B%5D)">bounds</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Finds the minimum bounding rectangle for a packed array without unpacking it.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#circle(squidpony.squidmath.Coord,int,int,int)">circle</a></span>&#8203;(<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;center,
int&nbsp;radius,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Given a center and radius for a circle, plus the width and height for the map boundaries, returns the packed data
 that encodes the circle.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#coordToHilbert(squidpony.squidmath.Coord)">coordToHilbert</a></span>&#8203;(<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;pt)</code></th>
<td class="colLast">
<div class="block">Takes a position as a Coord called pt and returns the length to travel along the 256x256 Hilbert curve to reach
 that position.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#coordToMoore(squidpony.squidmath.Coord)">coordToMoore</a></span>&#8203;(<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;pt)</code></th>
<td class="colLast">
<div class="block">Takes a position as a Coord called pt and returns the length to travel along the 16x16 Moore curve to reach
 that position.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#count(short%5B%5D)">count</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Counts the number of "on" cells encoded in a packed array without unpacking it.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#count(short%5B%5D,boolean)">count</a></span>&#8203;(short[]&nbsp;packed,
boolean&nbsp;wanted)</code></th>
<td class="colLast">
<div class="block">Counts the number of cells encoding a boolean equal to wanted in a packed array without unpacking it.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#covered(short%5B%5D)">covered</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Finds how many cells are encoded in a packed array (both on and off) without unpacking it.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#decodeASCII(java.lang.String)">decodeASCII</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;text)</code></th>
<td class="colLast">
<div class="block">Given a String specifically produced by CoordPacker.encodeASCII(), this will produce a packed data array.</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#decodeBraille(java.lang.String)">decodeBraille</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;text)</code></th>
<td class="colLast">
<div class="block">Given a String specifically produced by CoordPacker.encodeBraille(), this will produce a packed data array.</div>
</td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#differencePacked(short%5B%5D,short%5B%5D)">differencePacked</a></span>&#8203;(short[]&nbsp;left,
short[]&nbsp;right)</code></th>
<td class="colLast">
<div class="block">Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
 that was "on" in left but "off" in right, and encodes "off" for cells that were "on" in right or "off" in left.</div>
</td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#encodeASCII(short%5B%5D)">encodeASCII</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Encodes a short array of packed data as a (larger, more memory-hungry) ASCII string, which can be decoded using
 CoordPacker.decodeASCII() .</div>
</td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#encodeBraille(short%5B%5D)">encodeBraille</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Encodes a short array of packed data as a (larger, slightly more memory-hungry) Unicode string using only Braille
 characters, which can be decoded using CoordPacker.decodeBraille().</div>
</td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#expand(short%5B%5D,int,int,int)">expand</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;expansion,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Expand each "on" position in packed to cover a a square with side length equal to 1 + expansion * 2,
 centered on the original "on" position, unless the expansion would take a cell further than 0,
 width - 1 (for xMove) or height - 1 (for yMove), in which case that cell is stopped at the edge.</div>
</td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#expand(short%5B%5D,int,int,int,boolean)">expand</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;expansion,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</code></th>
<td class="colLast">
<div class="block">Expand each "on" position in packed to cover a a square with side length equal to 1 + expansion * 2,
 centered on the original "on" position, unless the expansion would take a cell further than 0,
 width - 1 (for xMove) or height - 1 (for yMove), in which case that cell is stopped at the edge.</div>
</td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>static <a href="OrderedSet.html" title="class in squidpony.squidmath">OrderedSet</a>&lt;short[]&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findManyPacked(int,int,short%5B%5D...)">findManyPacked</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
short[]...&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Quickly determines if an x,y position is true or false in one of the given packed arrays, without unpacking them,
 and returns a List of all packed arrays that contain the position.</div>
</td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>static <a href="OrderedSet.html" title="class in squidpony.squidmath">OrderedSet</a>&lt;short[]&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findManyPacked(int,int,java.util.Collection)">findManyPacked</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;short[]&gt;&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Quickly determines if an x,y position is true or false in one of the given packed arrays, without unpacking them,
 and returns a List of all packed arrays that contain the position.</div>
</td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/ArrayList.html?is-external=true" title="class or interface in java.util" class="externalLink">ArrayList</a>&lt;short[]&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findManyPackedHilbert(short,short%5B%5D...)">findManyPackedHilbert</a></span>&#8203;(short&nbsp;hilbert,
short[]...&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Quickly determines if a Hilbert Curve index corresponds to true or false in one of the given packed arrays,
 without unpacking them, and returns a List of all packed arrays that contain the position.</div>
</td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flood(short%5B%5D,short%5B%5D,int)">flood</a></span>&#8203;(short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;expansion)</code></th>
<td class="colLast">
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and an
 amount of expansion, expands each cell in start by a Manhattan (diamond) radius equal to expansion, limiting any
 expansion to within bounds and returning the final expanded (limited) packed data.</div>
</td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flood(short%5B%5D,short%5B%5D,int,boolean)">flood</a></span>&#8203;(short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;expansion,
boolean&nbsp;eightWay)</code></th>
<td class="colLast">
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and an
 amount of expansion, expands each cell in start by a radius (if eightWay is true, it uses Chebyshev distance; if
 it is false, it uses Manhattan distance) equal to expansion, limiting any expansion to within bounds and
 returning the final expanded (limited) packed data.</div>
</td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fractionPacked(short%5B%5D,int)">fractionPacked</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;fraction)</code></th>
<td class="colLast">
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, repeatedly goes through a
 number of "on" cells equal to fraction and stores one of those cells as a Coord, and returns the accumulated
 portion of positions as a Coord[].</div>
</td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fractionPackedHilbert(short%5B%5D,int)">fractionPackedHilbert</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;fraction)</code></th>
<td class="colLast">
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, repeatedly goes through a
 number of "on" cells equal to fraction and stores one of those cells as a Coord, and returns the accumulated
 portion of positions as an array of Hilbert Curve indices.</div>
</td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fringe(short%5B%5D,int,int,int)">fringe</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;expansion,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Finds the area around the cells encoded in packed, without including those cells.</div>
</td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fringe(short%5B%5D,int,int,int,boolean)">fringe</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;expansion,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</code></th>
<td class="colLast">
<div class="block">Finds the area around the cells encoded in packed, without including those cells.</div>
</td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fringe(short%5B%5D,int,int,int,boolean,boolean)">fringe</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;expansion,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay,
boolean&nbsp;drop)</code></th>
<td class="colLast">
<div class="block">Finds the area around the cells encoded in packed, without including those cells.</div>
</td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>static short[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fringes(short%5B%5D,int,int,int)">fringes</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;expansions,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Finds the concentric areas around the cells encoded in packed, without including those cells.</div>
</td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code>static short[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fringes(short%5B%5D,int,int,int,boolean)">fringes</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;expansions,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</code></th>
<td class="colLast">
<div class="block">Finds the concentric areas around the cells encoded in packed, without including those cells.</div>
</td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateLightLevels(int)">generateLightLevels</a></span>&#8203;(int&nbsp;totalLevels)</code></th>
<td class="colLast">
<div class="block">Given a number of total levels to consider separate in a double[][] such as an FOV result, this produces a levels
 array that can be passed to unpackMultiDouble() to ensure that the minimum double returned for an "on" cell is
 1.0 / totalLevels, and every progressively tighter level in the short[][] being unpacked will be close to a
 multiple of that minimum double value.</div>
</td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generatePackingLevels(int)">generatePackingLevels</a></span>&#8203;(int&nbsp;totalLevels)</code></th>
<td class="colLast">
<div class="block">Given a number of total levels to consider separate in a double[][] such as an FOV result, this produces a levels
 array that can be passed to packMulti() to ensure that you have the requested number of separate levels in the
 multi-packed result.</div>
</td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getXMoore3D(int,int)">getXMoore3D</a></span>&#8203;(int&nbsp;index,
int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Gets the x coordinate for a given index into the 16x16x(8*n) Moore curve.</div>
</td>
</tr>
<tr class="rowColor" id="i35">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getYMoore3D(int,int)">getYMoore3D</a></span>&#8203;(int&nbsp;index,
int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Gets the y coordinate for a given index into the 16x16x(8*n) Moore curve.</div>
</td>
</tr>
<tr class="altColor" id="i36">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getZMoore3D(int,int)">getZMoore3D</a></span>&#8203;(int&nbsp;index,
int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Gets the z coordinate for a given index into the 16x16x(8*n) Moore curve.</div>
</td>
</tr>
<tr class="rowColor" id="i37">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#grayDecode(int)">grayDecode</a></span>&#8203;(int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Decode a number from a Gray code n; Gray codes have a relation to the Hilbert curve and may be useful.</div>
</td>
</tr>
<tr class="altColor" id="i38">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#grayEncode(int)">grayEncode</a></span>&#8203;(int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Encode a number n as a Gray code; Gray codes have a relation to the Hilbert curve and may be useful.</div>
</td>
</tr>
<tr class="rowColor" id="i39">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hilbertToCoord(int)">hilbertToCoord</a></span>&#8203;(int&nbsp;hilbert)</code></th>
<td class="colLast">
<div class="block">Takes a distance to travel along the 256x256 Hilbert curve and returns a Coord representing the position
 in 2D space that corresponds to that point on the Hilbert curve.</div>
</td>
</tr>
<tr class="altColor" id="i40">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hilbertToMorton(int)">hilbertToMorton</a></span>&#8203;(int&nbsp;hilbert)</code></th>
<td class="colLast">
<div class="block">Takes a distance to travel along the 256x256 Hilbert curve and returns a Morton code representing the position
 in 2D space that corresponds to that point on the Hilbert Curve; the Morton code will have interleaved x and y
 bits and x in the least significant bit.</div>
</td>
</tr>
<tr class="rowColor" id="i41">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#init()">init</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor" id="i42">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertPacked(short%5B%5D,int,int)">insertPacked</a></span>&#8203;(short[]&nbsp;original,
int&nbsp;x,
int&nbsp;y)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, original, and a position as x,y numbers, this produces a packed short array
 that encodes "on" for any cell that was "on" in original, always encodes "on" for the position referred
 to by x and y, and encodes "off" for cells that were "off" in original and are not the cell x and y refer to.</div>
</td>
</tr>
<tr class="rowColor" id="i43">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertPacked(short%5B%5D,short)">insertPacked</a></span>&#8203;(short[]&nbsp;original,
short&nbsp;hilbert)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, original, and a Hilbert Curve index, hilbert, this produces a packed short array
 that encodes "on" for any cell that was "on" in original, always encodes "on" for the position referred
 to by hilbert, and encodes "off" for cells that were "off" in original and are not the cell hilbert refers to.</div>
</td>
</tr>
<tr class="altColor" id="i44">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertSeveralPacked(short%5B%5D,int...)">insertSeveralPacked</a></span>&#8203;(short[]&nbsp;original,
int...&nbsp;hilbert)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, original, and a number of Hilbert Curve indices, hilbert, this produces a packed
 short array that encodes "on" for any cell that was "on" in original, always encodes "on" for the position
 referred to by any element of hilbert, and encodes "off" for cells that were "off" in original and are not in any
 cell hilbert refers to.</div>
</td>
</tr>
<tr class="rowColor" id="i45">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertSeveralPacked(short%5B%5D,java.util.Collection)">insertSeveralPacked</a></span>&#8203;(short[]&nbsp;original,
<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&gt;&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, original, and a Collection of Coords, points, this produces a packed
 short array that encodes "on" for any cell that was "on" in original, always encodes "on" for the position
 referred to by any element of points, and encodes "off" for cells that were "off" in original and are not in any
 cell points refers to.</div>
</td>
</tr>
<tr class="altColor" id="i46">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertSeveralPacked(short%5B%5D,squidpony.squidmath.Coord...)">insertSeveralPacked</a></span>&#8203;(short[]&nbsp;original,
<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>...&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, original, and a number of Coords, points, this produces a packed
 short array that encodes "on" for any cell that was "on" in original, always encodes "on" for the position
 referred to by any element of points, and encodes "off" for cells that were "off" in original and are not in any
 cell points refers to.</div>
</td>
</tr>
<tr class="rowColor" id="i47">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectPacked(short%5B%5D,short%5B%5D)">intersectPacked</a></span>&#8203;(short[]&nbsp;left,
short[]&nbsp;right)</code></th>
<td class="colLast">
<div class="block">Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
 that was "on" in both left and in right, and encodes "off" for cells that were off in either array.</div>
</td>
</tr>
<tr class="altColor" id="i48">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersects(short%5B%5D,short%5B%5D)">intersects</a></span>&#8203;(short[]&nbsp;left,
short[]&nbsp;right)</code></th>
<td class="colLast">
<div class="block">Given two packed short arrays, left and right, this returns true if they encode any overlapping area (their areas
 intersect), or false if they do not overlap at all (they don't intersect).</div>
</td>
</tr>
<tr class="rowColor" id="i49">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isEmpty(short%5B%5D)">isEmpty</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Checks if no cells are encoded as "on" in packed.</div>
</td>
</tr>
<tr class="altColor" id="i50">
<td class="colFirst"><code>static char[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mask(char%5B%5D%5B%5D,short%5B%5D,char)">mask</a></span>&#8203;(char[][]&nbsp;map,
short[]&nbsp;packed,
char&nbsp;filler)</code></th>
<td class="colLast">
<div class="block">Given a 2D char array for a map, a piece of packed data defining a region to use from that map, and a filler
 char, produces a 2D char array where all positions that are "off" in packed are filled with filler, and the rest
 are the same as in map.</div>
</td>
</tr>
<tr class="rowColor" id="i51">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mooreToCoord(int)">mooreToCoord</a></span>&#8203;(int&nbsp;moore)</code></th>
<td class="colLast">
<div class="block">Takes a distance to travel along the 16x16 Hilbert curve and returns a Coord representing the position
 in 2D space that corresponds to that point on the Hilbert curve.</div>
</td>
</tr>
<tr class="altColor" id="i52">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mortonBitDecode3D(int)">mortonBitDecode3D</a></span>&#8203;(int&nbsp;morton)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i53">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mortonDecode(int)">mortonDecode</a></span>&#8203;(int&nbsp;morton)</code></th>
<td class="colLast">
<div class="block">Takes a Morton code, with interleaved x and y bits and x in the least significant bit, and returns the Coord
 representing the same x, y position.</div>
</td>
</tr>
<tr class="altColor" id="i54">
<td class="colFirst"><code>static <a href="Coord3D.html" title="class in squidpony.squidmath">Coord3D</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mortonDecode3D(int)">mortonDecode3D</a></span>&#8203;(int&nbsp;morton)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i55">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mortonEncode(int,int)">mortonEncode</a></span>&#8203;(int&nbsp;index1,
int&nbsp;index2)</code></th>
<td class="colLast">
<div class="block">Takes two 8-bit unsigned integers index1 and index2, and returns a Morton code, with interleaved index1 and
 index2 bits and index1 in the least significant bit.</div>
</td>
</tr>
<tr class="altColor" id="i56">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mortonEncode3D(int,int,int)">mortonEncode3D</a></span>&#8203;(int&nbsp;index1,
int&nbsp;index2,
int&nbsp;index3)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i57">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mortonToHilbert(int)">mortonToHilbert</a></span>&#8203;(int&nbsp;morton)</code></th>
<td class="colLast">
<div class="block">Takes a position as a Morton code, with interleaved x and y bits and x in the least significant bit, and returns
 the length to travel along the 256x256 Hilbert Curve to reach that position.</div>
</td>
</tr>
<tr class="altColor" id="i58">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#negatePacked(short%5B%5D)">negatePacked</a></span>&#8203;(short[]&nbsp;original)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, this produces a packed short array that is the exact opposite of the one passed in,
 that is, every "on" cell becomes "off" and every "off" cell becomes "on", including cells that were "off" because
 they were beyond the boundaries of the original 2D array passed to pack() or a similar method.</div>
</td>
</tr>
<tr class="rowColor" id="i59">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nth(short%5B%5D,int)">nth</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Gets the nth position that is "on" in the given packed array, without unpacking it, and returns it as a Coord.</div>
</td>
</tr>
<tr class="altColor" id="i60">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pack(boolean%5B%5D%5B%5D)">pack</a></span>&#8203;(boolean[][]&nbsp;map)</code></th>
<td class="colLast">
<div class="block">Compresses a boolean[][], returning a short[] as described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="rowColor" id="i61">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pack(byte%5B%5D%5B%5D)">pack</a></span>&#8203;(byte[][]&nbsp;map)</code></th>
<td class="colLast">
<div class="block">Compresses a byte[][] (typically one generated by an FOV-like method) that only stores two
 relevant states (one of which should be 0 or less, the other greater than 0), returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="altColor" id="i62">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pack(char%5B%5D%5B%5D,char)">pack</a></span>&#8203;(char[][]&nbsp;map,
char&nbsp;yes)</code></th>
<td class="colLast">
<div class="block">Compresses a char[][] (typically one generated by a map generating method) so only the cells that equal the yes
 parameter will be encoded as "on", returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="rowColor" id="i63">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pack(char%5B%5D%5B%5D,char...)">pack</a></span>&#8203;(char[][]&nbsp;map,
char...&nbsp;yes)</code></th>
<td class="colLast">
<div class="block">Compresses a char[][] (typically one generated by a map generating method) so only the cells that are contained
 in the yes parameter will be encoded as "on", returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="altColor" id="i64">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pack(double%5B%5D%5B%5D)">pack</a></span>&#8203;(double[][]&nbsp;map)</code></th>
<td class="colLast">
<div class="block">Compresses a double[][] (typically one generated by <a href="../squidgrid/FOV.html" title="class in squidpony.squidgrid"><code>FOV</code></a>) that only stores two
 relevant states (one of which should be 0 or less, the other greater than 0), returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="rowColor" id="i65">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pack(double%5B%5D%5B%5D,double)">pack</a></span>&#8203;(double[][]&nbsp;map,
double&nbsp;threshold)</code></th>
<td class="colLast">
<div class="block">Compresses a double[][] (typically one generated by <a href="../squidai/DijkstraMap.html" title="class in squidpony.squidai"><code>DijkstraMap</code></a>) that only stores two
 relevant states (one of which should be equal to or less than threshold, the other greater than threshold),
 returning a short[] as described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="altColor" id="i66">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pack(double%5B%5D%5B%5D,double,double)">pack</a></span>&#8203;(double[][]&nbsp;map,
double&nbsp;lowerBound,
double&nbsp;upperBound)</code></th>
<td class="colLast">
<div class="block">Compresses a double[][] (typically one generated by <a href="../squidai/DijkstraMap.html" title="class in squidpony.squidai"><code>DijkstraMap</code></a>) that only stores two
 relevant states (a state for values between lowerBound (inclusive) and upperBound (exclusive), and another state
 for anything else), returning a short[] as described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="rowColor" id="i67">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pack(int%5B%5D%5B%5D,int)">pack</a></span>&#8203;(int[][]&nbsp;map,
int&nbsp;yes)</code></th>
<td class="colLast">
<div class="block">Compresses a int[][] (typically one generated by MixedGenerator.getEnvironment()) so only the cells that equal
 the yes parameter will be encoded as "on", returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="altColor" id="i68">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pack(int%5B%5D%5B%5D,int...)">pack</a></span>&#8203;(int[][]&nbsp;map,
int...&nbsp;yes)</code></th>
<td class="colLast">
<div class="block">Compresses a int[][] (typically one generated by MixedGenerator.getEnvironment()) so only the cells that are
 contained in the yes parameter will be encoded as "on", returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="rowColor" id="i69">
<td class="colFirst"><code>static short[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#packMulti(byte%5B%5D%5B%5D,int)">packMulti</a></span>&#8203;(byte[][]&nbsp;map,
int&nbsp;levelCount)</code></th>
<td class="colLast">
<div class="block">Compresses a byte[][] that stores any number of states, and an int no more than 63, returning a short[][] as
 described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="altColor" id="i70">
<td class="colFirst"><code>static short[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#packMulti(double%5B%5D%5B%5D,double%5B%5D)">packMulti</a></span>&#8203;(double[][]&nbsp;map,
double[]&nbsp;levels)</code></th>
<td class="colLast">
<div class="block">Compresses a double[][] (typically one generated by <a href="../squidgrid/FOV.html" title="class in squidpony.squidgrid"><code>FOV</code></a>) that stores any number of
 states and a double[] storing up to 63 states, ordered from lowest to highest, returning a short[][] as described
 in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="rowColor" id="i71">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#packOne(int)">packOne</a></span>&#8203;(int&nbsp;hilbert)</code></th>
<td class="colLast">
<div class="block">Returns a new packed short[] containing the Hilbert distance hilbert as "on", and all other cells "off".</div>
</td>
</tr>
<tr class="altColor" id="i72">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#packOne(int,int)">packOne</a></span>&#8203;(int&nbsp;x,
int&nbsp;y)</code></th>
<td class="colLast">
<div class="block">Returns a new packed short[] containing the given x,y cell as "on", and all other cells "off".</div>
</td>
</tr>
<tr class="rowColor" id="i73">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#packOne(squidpony.squidmath.Coord)">packOne</a></span>&#8203;(<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Returns a new packed short[] containing the Coord point as "on", and all other cells "off".</div>
</td>
</tr>
<tr class="altColor" id="i74">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#packSeveral(int...)">packSeveral</a></span>&#8203;(int...&nbsp;hilbert)</code></th>
<td class="colLast">
<div class="block">Returns a new packed short[] containing the Hilbert distances in hilbert as "on" cells, and all other cells "off"</div>
</td>
</tr>
<tr class="rowColor" id="i75">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#packSeveral(java.util.Collection)">packSeveral</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&gt;&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Returns a new packed short[] containing the Coords in points as "on" cells, and all other cells "off"</div>
</td>
</tr>
<tr class="altColor" id="i76">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#packSeveral(squidpony.squidmath.Coord...)">packSeveral</a></span>&#8203;(<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>...&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Returns a new packed short[] containing the Coords in points as "on" cells, and all other cells "off"</div>
</td>
</tr>
<tr class="rowColor" id="i77">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#posToHilbert(int,int)">posToHilbert</a></span>&#8203;(int&nbsp;x,
int&nbsp;y)</code></th>
<td class="colLast">
<div class="block">Takes an x, y position and returns the length to travel along the 256x256 Hilbert curve to reach that position.</div>
</td>
</tr>
<tr class="altColor" id="i78">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#posToHilbert3D(int,int,int)">posToHilbert3D</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;z)</code></th>
<td class="colLast">
<div class="block">Takes an x, y, z position and returns the length to travel along the 8x8x8 Hilbert curve to reach that
 position.</div>
</td>
</tr>
<tr class="rowColor" id="i79">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#posToMoore(int,int)">posToMoore</a></span>&#8203;(int&nbsp;x,
int&nbsp;y)</code></th>
<td class="colLast">
<div class="block">Takes an x, y position and returns the length to travel along the 16x16 Moore curve to reach that position.</div>
</td>
</tr>
<tr class="altColor" id="i80">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#printCompressedData(short%5B%5D)">printCompressedData</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i81">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#printPacked(short%5B%5D,int,int)">printPacked</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Quick utility method for printing packed data as a grid of 1 (on) and/or 0 (off).</div>
</td>
</tr>
<tr class="altColor" id="i82">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryPacked(short%5B%5D,int,int)">queryPacked</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;x,
int&nbsp;y)</code></th>
<td class="colLast">
<div class="block">Quickly determines if an x,y position is true or false in the given packed array, without unpacking it.</div>
</td>
</tr>
<tr class="rowColor" id="i83">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryPackedHilbert(short%5B%5D,short)">queryPackedHilbert</a></span>&#8203;(short[]&nbsp;packed,
short&nbsp;hilbert)</code></th>
<td class="colLast">
<div class="block">Quickly determines if a Hilbert Curve index corresponds to true or false in the given packed array, without
 unpacking it.</div>
</td>
</tr>
<tr class="altColor" id="i84">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#radiate(short%5B%5D,short%5B%5D,int)">radiate</a></span>&#8203;(short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;expansion)</code></th>
<td class="colLast">
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and an
 amount of expansion, expands each cell in start by a Manhattan (diamond) radius equal to expansion, limiting any
 expansion to within bounds and returning the final expanded (limited) packed data.</div>
</td>
</tr>
<tr class="rowColor" id="i85">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#radiate(short%5B%5D,short%5B%5D,int,boolean)">radiate</a></span>&#8203;(short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;expansion,
boolean&nbsp;eightWay)</code></th>
<td class="colLast">
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and an
 amount of expansion, expands each cell in start by a radius, with a square shape if eightWay is true or a diamond
 otherwise, equal to expansion, limiting any expansion to within bounds and returning the final expanded (limited)
 packed data.</div>
</td>
</tr>
<tr class="altColor" id="i86">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#radiate(short%5B%5D,short%5B%5D,int,squidpony.squidgrid.Radius)">radiate</a></span>&#8203;(short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;expansion,
<a href="../squidgrid/Radius.html" title="enum in squidpony.squidgrid">Radius</a>&nbsp;metric)</code></th>
<td class="colLast">
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and an
 amount of expansion, expands each cell in start by a radius, with a shape determined by metric, equal to
 expansion, limiting any expansion to within bounds and returning the final expanded (limited) packed data.</div>
</td>
</tr>
<tr class="rowColor" id="i87">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/ArrayList.html?is-external=true" title="class or interface in java.util" class="externalLink">ArrayList</a>&lt;<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#randomPortion(short%5B%5D,int,squidpony.squidmath.IRNG)">randomPortion</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;size,
<a href="IRNG.html" title="interface in squidpony.squidmath">IRNG</a>&nbsp;rng)</code></th>
<td class="colLast">
<div class="block">Gets a fixed number of randomly chosen positions that are "on" in the given packed array, without unpacking it,
 and returns a List of Coord with a count equal to size (or less if there aren't enough "on" cells).</div>
</td>
</tr>
<tr class="altColor" id="i88">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#randomSample(short%5B%5D,double,squidpony.squidmath.IRNG)">randomSample</a></span>&#8203;(short[]&nbsp;packed,
double&nbsp;fraction,
<a href="IRNG.html" title="interface in squidpony.squidmath">IRNG</a>&nbsp;rng)</code></th>
<td class="colLast">
<div class="block">Gets a random subset of positions that are "on" in the given packed array, without unpacking it, and returns
 them as a Coord[].</div>
</td>
</tr>
<tr class="rowColor" id="i89">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#randomSeparated(short%5B%5D,int,squidpony.squidmath.IRNG)">randomSeparated</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;separation,
<a href="IRNG.html" title="interface in squidpony.squidmath">IRNG</a>&nbsp;rng)</code></th>
<td class="colLast">
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, repeatedly goes through a
 number of "on" cells equal to fraction and stores a random one of those cells as a Coord, and returns the
 accumulated random portion of positions as a Coord[].</div>
</td>
</tr>
<tr class="altColor" id="i90">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reachable(short%5B%5D,short%5B%5D,squidpony.squidai.Reach)">reachable</a></span>&#8203;(short[]&nbsp;bounds,
short[]&nbsp;start,
<a href="../squidai/Reach.html" title="class in squidpony.squidai">Reach</a>&nbsp;reach)</code></th>
<td class="colLast">
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and a
 Reach object that determines targeting constraints, gets all cells contained within bounds that can be targeted
 from a cell in start using the rules defined by reach.</div>
</td>
</tr>
<tr class="rowColor" id="i91">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rectangle(int,int)">rectangle</a></span>&#8203;(int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Given a width and height, returns a packed array that encodes "on" for the rectangle from (0,0) to
 (width - 1, height - 1).</div>
</td>
</tr>
<tr class="altColor" id="i92">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rectangle(int,int,int,int)">rectangle</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Given x, y, width and height, returns a packed array that encodes "on" for the rectangle from (x,y) to
 (width + x - 1, height + y - 1).</div>
</td>
</tr>
<tr class="rowColor" id="i93">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rectangleHilbert(int,int,int,int)">rectangleHilbert</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Given x, y, width and height, returns an array of all Hilbert distance within the rectangle from (x,y) to
 (width + x - 1, height + y - 1).</div>
</td>
</tr>
<tr class="altColor" id="i94">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#regionsContain(short%5B%5D,short%5B%5D...)">regionsContain</a></span>&#8203;(short[]&nbsp;checking,
short[]...&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Quickly determines if a region is contained in one of the given packed arrays, without unpacking them, and
 returns true if the region checking has some overlap with any of the packed arrays, or false otherwise.</div>
</td>
</tr>
<tr class="rowColor" id="i95">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#regionsContain(short%5B%5D,java.util.Collection)">regionsContain</a></span>&#8203;(short[]&nbsp;checking,
<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;short[]&gt;&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Quickly determines if a region is contained in one of the given packed arrays, without unpacking them, and
 returns true if the region checking has some overlap with any of the packed arrays, or false otherwise.</div>
</td>
</tr>
<tr class="altColor" id="i96">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeIsolated(short%5B%5D)">removeIsolated</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i97">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removePacked(short%5B%5D,int,int)">removePacked</a></span>&#8203;(short[]&nbsp;original,
int&nbsp;x,
int&nbsp;y)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, original, and a position as x,y numbers, this produces a packed short array that
 encodes "on" for any cell that was "on" in original, unless it was the position referred to by x and y, and
 encodes "off" for cells that were "off" in original or are the cell x and y refer to.</div>
</td>
</tr>
<tr class="altColor" id="i98">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removePacked(short%5B%5D,short)">removePacked</a></span>&#8203;(short[]&nbsp;original,
short&nbsp;hilbert)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, original, and a Hilbert Curve index, hilbert, this produces a packed short array
 that encodes "on" for any cell that was "on" in original, unless it was the position referred to by hilbert, and
 encodes "off" for cells that were "off" in original or are the cell hilbert refers to.</div>
</td>
</tr>
<tr class="rowColor" id="i99">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeSeveralPacked(short%5B%5D,int...)">removeSeveralPacked</a></span>&#8203;(short[]&nbsp;original,
int...&nbsp;hilbert)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, original, and a number of Hilbert Curve indices, hilbert, this produces a packed
 short array that encodes "on" for any cell that was "on" in original, unless it was a position referred to by
 hilbert, and encodes "off" for cells that were "off" in original and are a cell hilbert refers to.</div>
</td>
</tr>
<tr class="altColor" id="i100">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeSeveralPacked(short%5B%5D,java.util.Collection)">removeSeveralPacked</a></span>&#8203;(short[]&nbsp;original,
<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&gt;&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, original, and a number of Coords, points, this produces a packed short
 array that encodes "on" for any cell that was "on" in original, unless it was a position referred to by an element
 in points, and encodes "off" for cells that were "off" in original and are a cell points refers to.</div>
</td>
</tr>
<tr class="rowColor" id="i101">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeSeveralPacked(short%5B%5D,squidpony.squidmath.Coord...)">removeSeveralPacked</a></span>&#8203;(short[]&nbsp;original,
<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>...&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Given one packed short array, original, and a number of Coords, points, this produces a packed short
 array that encodes "on" for any cell that was "on" in original, unless it was a position referred to by an element
 in points, and encodes "off" for cells that were "off" in original and are a cell points refers to.</div>
</td>
</tr>
<tr class="altColor" id="i102">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retract(short%5B%5D,int,int,int)">retract</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;retraction,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Finds the area made by removing the "on" positions in packed that are within the specified retraction distance of
 an "off" position or the edge of the map.</div>
</td>
</tr>
<tr class="rowColor" id="i103">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retract(short%5B%5D,int,int,int,boolean)">retract</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;retraction,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</code></th>
<td class="colLast">
<div class="block">Finds the area made by removing the "on" positions in packed that are within the specified retraction distance of
 an "off" position or the edge of the map.</div>
</td>
</tr>
<tr class="altColor" id="i104">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#singleRandom(short%5B%5D,squidpony.squidmath.IRNG)">singleRandom</a></span>&#8203;(short[]&nbsp;packed,
<a href="IRNG.html" title="interface in squidpony.squidmath">IRNG</a>&nbsp;rng)</code></th>
<td class="colLast">
<div class="block">Gets a single randomly chosen position that is "on" in the given packed array, without unpacking it, and returns
 it as a Coord or returns null of the array is empty.</div>
</td>
</tr>
<tr class="rowColor" id="i105">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#spill(short%5B%5D,short%5B%5D,int,squidpony.squidmath.IRNG)">spill</a></span>&#8203;(short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;volume,
<a href="IRNG.html" title="interface in squidpony.squidmath">IRNG</a>&nbsp;rng)</code></th>
<td class="colLast">
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, an IRNG,
 and a volume in cells, expands a random cell in start in a random Manhattan (diamond) direction equal, then
 continues to expand from random cells in start or the expanded area until it has filled volume cells, limiting
 any expansion to within bounds and returning the final expanded (limited) packed data.</div>
</td>
</tr>
<tr class="altColor" id="i106">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/ArrayList.html?is-external=true" title="class or interface in java.util" class="externalLink">ArrayList</a>&lt;short[]&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#split(short%5B%5D)">split</a></span>&#8203;(short[]&nbsp;packed)</code></th>
<td class="colLast">
<div class="block">Given a packed data array that encodes multiple unconnected "on" areas, this finds each isolated area (areas that
 are only adjacent diagonally are considered separate from each other) and returns it as an element in an
 ArrayList of short[], with one short[] array per isolated area.</div>
</td>
</tr>
<tr class="rowColor" id="i107">
<td class="colFirst"><code>static int[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sumMany(int,int,short%5B%5D...)">sumMany</a></span>&#8203;(int&nbsp;width,
int&nbsp;height,
short[]...&nbsp;many)</code></th>
<td class="colLast">
<div class="block">Takes multiple pieces of packed data as short[], encoded by pack() or another similar method of this class, and
 generates a 2D int array with the specified width and height and a starting value of 0 for all elements, then
 where every occurrence of a cell as "on" in a piece of packed data increments the cell's value in the returned
 array.</div>
</td>
</tr>
<tr class="altColor" id="i108">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#surface(short%5B%5D,int,int,int)">surface</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;depth,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Finds the area consisting of the "on" positions in packed that are within the specified depth distance of an
 "off" position or the edge of the map.</div>
</td>
</tr>
<tr class="rowColor" id="i109">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#surface(short%5B%5D,int,int,int,boolean)">surface</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;depth,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</code></th>
<td class="colLast">
<div class="block">Finds the area consisting of the "on" positions in packed that are within the specified depth distance of an
 "off" position or the edge of the map.</div>
</td>
</tr>
<tr class="altColor" id="i110">
<td class="colFirst"><code>static short[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#surfaces(short%5B%5D,int,int,int)">surfaces</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;depth,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Finds the concentric, progressively-smaller surfaces of packed as if packed was shrinking with each iteration.</div>
</td>
</tr>
<tr class="rowColor" id="i111">
<td class="colFirst"><code>static short[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#surfaces(short%5B%5D,int,int,int,boolean)">surfaces</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;depth,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</code></th>
<td class="colLast">
<div class="block">Finds the concentric, progressively-smaller surfaces of packed as if packed was shrinking with each iteration.</div>
</td>
</tr>
<tr class="altColor" id="i112">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#translate(short%5B%5D,int,int,int,int)">translate</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;xMove,
int&nbsp;yMove,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Move all "on" positions in packed by the number of cells given in xMove and yMove, unless the move
 would take them further than 0, width - 1 (for xMove) or height - 1 (for yMove), in which case that
 cell is stopped at the edge (moving any shape by an xMove greater than width or yMove greater than
 height will move all "on" cells to that edge, in a 1-cell thick line).</div>
</td>
</tr>
<tr class="rowColor" id="i113">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unionPacked(short%5B%5D,short%5B%5D)">unionPacked</a></span>&#8203;(short[]&nbsp;left,
short[]&nbsp;right)</code></th>
<td class="colLast">
<div class="block">Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
 that was "on" in either left or in right, and only encodes "off" for cells that were off in both.</div>
</td>
</tr>
<tr class="altColor" id="i114">
<td class="colFirst"><code>static boolean[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpack(short%5B%5D,int,int)">unpack</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="rowColor" id="i115">
<td class="colFirst"><code>static char[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackChar(short%5B%5D,char,char)">unpackChar</a></span>&#8203;(short[]&nbsp;packed,
char&nbsp;t,
char&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Given a piece of packed data defining a region to use from that map, a char to use for "on" cells and a char to use
 for "off" cells, produces a 2D char array where all positions that are "off" in packed are filled with the char
 passed as f, and the cells that are "on" are filled with the char passed as t.</div>
</td>
</tr>
<tr class="altColor" id="i116">
<td class="colFirst"><code>static char[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackChar(short%5B%5D,int,int,char,char)">unpackChar</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height,
char&nbsp;t,
char&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Given a piece of packed data defining a region to use from that map, a desired width and height, a char to use for
 "on" cells and a char to use for "off" cells, produces a 2D char array where all positions that are "off" in packed
 are filled with the char passed as f, and the cells that are "on" are filled with the char passed as t.</div>
</td>
</tr>
<tr class="rowColor" id="i117">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackDouble(short%5B%5D,int,int)">unpackDouble</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="altColor" id="i118">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackDoubleConical(short%5B%5D,int,int,int,int,double,double)">unpackDoubleConical</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height,
int&nbsp;centerX,
int&nbsp;centerY,
double&nbsp;angle,
double&nbsp;span)</code></th>
<td class="colLast">
<div class="block">Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="rowColor" id="i119">
<td class="colFirst"><code>static <a href="GreasedRegion.html" title="class in squidpony.squidmath">GreasedRegion</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackGreasedRegion(short%5B%5D,int,int)">unpackGreasedRegion</a></span>&#8203;(short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Utility method that constructs a GreasedRegion (a faster but more-memory-hungry way to encode regions)
 from a short array of packed data.</div>
</td>
</tr>
<tr class="altColor" id="i120">
<td class="colFirst"><code>static <a href="GreasedRegion.html" title="class in squidpony.squidmath">GreasedRegion</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackIntoGreasedRegion(short%5B%5D,squidpony.squidmath.GreasedRegion)">unpackIntoGreasedRegion</a></span>&#8203;(short[]&nbsp;packed,
<a href="GreasedRegion.html" title="class in squidpony.squidmath">GreasedRegion</a>&nbsp;target)</code></th>
<td class="colLast">
<div class="block">Utility method that fills an existing GreasedRegion <code>target</code> with any "on" cells in the packed short array
 <code>packed</code>.</div>
</td>
</tr>
<tr class="rowColor" id="i121">
<td class="colFirst"><code>static <a href="GreasedRegion.html" title="class in squidpony.squidmath">GreasedRegion</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackIntoGreasedRegion(short%5B%5D,squidpony.squidmath.GreasedRegion,int,int)">unpackIntoGreasedRegion</a></span>&#8203;(short[]&nbsp;packed,
<a href="GreasedRegion.html" title="class in squidpony.squidmath">GreasedRegion</a>&nbsp;target,
int&nbsp;offsetX,
int&nbsp;offsetY)</code></th>
<td class="colLast">
<div class="block">Utility method that fills an existing GreasedRegion <code>target</code> with any "on" cells in the packed short array
 <code>packed</code>, inserting cells from packed at an offset when they go into target.</div>
</td>
</tr>
<tr class="altColor" id="i122">
<td class="colFirst"><code>static byte[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackMultiByte(short%5B%5D%5B%5D,int,int)">unpackMultiByte</a></span>&#8203;(short[][]&nbsp;packed,
int&nbsp;width,
int&nbsp;height)</code></th>
<td class="colLast">
<div class="block">Decompresses a short[][] returned by packMulti() and produces a simple 2D array where the values are bytes
 corresponding to 1 + the highest index into levels (that is, the original levels parameter passed to packMulti)
 matched by a cell, or 0 if the cell didn't match any levels during compression, as described in the
 <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="rowColor" id="i123">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackMultiDouble(short%5B%5D%5B%5D,int,int,double%5B%5D)">unpackMultiDouble</a></span>&#8203;(short[][]&nbsp;packed,
int&nbsp;width,
int&nbsp;height,
double[]&nbsp;levels)</code></th>
<td class="colLast">
<div class="block">Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
 using the given levels double[] as the values to assign, as described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class
 documentation.</div>
</td>
</tr>
<tr class="altColor" id="i124">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackMultiDoublePartial(short%5B%5D%5B%5D,int,int,double%5B%5D,int)">unpackMultiDoublePartial</a></span>&#8203;(short[][]&nbsp;packed,
int&nbsp;width,
int&nbsp;height,
double[]&nbsp;levels,
int&nbsp;limit)</code></th>
<td class="colLast">
<div class="block">Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
 using the given levels double[] as the values to assign, but only using the innermost indices up to limit, as
 described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="rowColor" id="i125">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unpackMultiDoublePartialConical(short%5B%5D%5B%5D,int,int,double%5B%5D,int,int,int,double,double)">unpackMultiDoublePartialConical</a></span>&#8203;(short[][]&nbsp;packed,
int&nbsp;width,
int&nbsp;height,
double[]&nbsp;levels,
int&nbsp;limit,
int&nbsp;centerX,
int&nbsp;centerY,
double&nbsp;angle,
double&nbsp;span)</code></th>
<td class="colLast">
<div class="block">Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
 using the given levels double[] as the values to assign, but only using the innermost indices up to limit, as
 described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation.</div>
</td>
</tr>
<tr class="altColor" id="i126">
<td class="colFirst"><code>static short[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#xorPacked(short%5B%5D,short%5B%5D)">xorPacked</a></span>&#8203;(short[]&nbsp;left,
short[]&nbsp;right)</code></th>
<td class="colLast">
<div class="block">Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
 that was "on" only in left or only in right, but not a cell that was "off" in both or "on" in both.</div>
</td>
</tr>
<tr class="rowColor" id="i127">
<td class="colFirst"><code>static <a href="Coord.html" title="class in squidpony.squidmath">Coord</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zDecode(short)">zDecode</a></span>&#8203;(short&nbsp;morton)</code></th>
<td class="colLast">
<div class="block">Takes a Morton code, with interleaved x and y bits and x in the least significant bit, and returns the Coord
 representing the same x, y position.</div>
</td>
</tr>
<tr class="altColor" id="i128">
<td class="colFirst"><code>static short</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zEncode(short,short)">zEncode</a></span>&#8203;(short&nbsp;index1,
short&nbsp;index2)</code></th>
<td class="colLast">
<div class="block">Takes two 8-bit unsigned integers index1 and index2, and returns a Morton code, with interleaved index1 and
 index2 bits and index1 in the least significant bit.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">Object</a></h3>
<a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a><code><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang" class="externalLink">clone</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang" class="externalLink">equals</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang" class="externalLink">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang" class="externalLink">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang" class="externalLink">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang" class="externalLink">notify</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang" class="externalLink">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang" class="externalLink">toString</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang" class="externalLink">wait</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang" class="externalLink">wait</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#wait(long,int)" title="class or interface in java.lang" class="externalLink">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<li class="blockList">
<section class="fieldDetails"><a id="field.detail">
<!--   -->
</a>
<h2>Field Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="DEPTH">DEPTH</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.197">DEPTH</a></span></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#squidpony.squidmath.CoordPacker.DEPTH">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hilbertX">hilbertX</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">hilbertX</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hilbertY">hilbertY</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">hilbertY</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hilbertDistances">hilbertDistances</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">hilbertDistances</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mooreX">mooreX</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">mooreX</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mooreY">mooreY</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">mooreY</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mooreDistances">mooreDistances</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">mooreDistances</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hilbert3X">hilbert3X</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">hilbert3X</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hilbert3Y">hilbert3Y</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">hilbert3Y</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hilbert3Z">hilbert3Z</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">hilbert3Z</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hilbert3Distances">hilbert3Distances</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">hilbert3Distances</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="ALL_WALL">ALL_WALL</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">ALL_WALL</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="ALL_ON">ALL_ON</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.200">ALL_ON</a></span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="init()">init</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.206">init</a></span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pack(double[][])">pack</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.268">pack</a></span>&#8203;(<span class="arguments">double[][]&nbsp;map)</span></div>
<div class="block">Compresses a double[][] (typically one generated by <a href="../squidgrid/FOV.html" title="class in squidpony.squidgrid"><code>FOV</code></a>) that only stores two
 relevant states (one of which should be 0 or less, the other greater than 0), returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This short[] can be passed to CoordPacker.unpack() to restore the
 relevant states and their positions as a boolean[][] (with false meaning 0 or less and true being any double
 greater than 0). As stated in the class documentation, the compressed result is intended to use as little memory
 as possible for most roguelike FOV maps. To avoid floating-point number comparison issues, this actually needs
 doubles to be greater than 0.0001, which should never cause incorrect behavior with FOV's double[][] maps.
 <br>
 <b>To store more than two states</b>, you should use packMulti().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a double[][] that probably was returned by FOV. If you obtained a double[][] from DijkstraMap, it
            will not meaningfully compress with this method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pack(double[][],double)">pack</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.340">pack</a></span>&#8203;(<span class="arguments">double[][]&nbsp;map,
double&nbsp;threshold)</span></div>
<div class="block">Compresses a double[][] (typically one generated by <a href="../squidai/DijkstraMap.html" title="class in squidpony.squidai"><code>DijkstraMap</code></a>) that only stores two
 relevant states (one of which should be equal to or less than threshold, the other greater than threshold),
 returning a short[] as described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This short[] can be passed to
 CoordPacker.unpack() to restore the relevant states and their positions as a boolean[][] (with true meaning
 threshold or less and false being any double greater than threshold). As stated in the class documentation, the
 compressed result is intended to use as little memory as possible for most roguelike FOV maps, but here is also
 useful for compressing physical maps and gradient maps from DijkstraMap.
 <br>
 <b>To store more than two states</b>, you should use packMulti().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a double[][] that probably relates in some way to DijkstraMap.</dd>
<dd><code>threshold</code> - upper inclusive; any double greater than this will be off, any equal or less will be on</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pack(double[][],double,double)">pack</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.416">pack</a></span>&#8203;(<span class="arguments">double[][]&nbsp;map,
double&nbsp;lowerBound,
double&nbsp;upperBound)</span></div>
<div class="block">Compresses a double[][] (typically one generated by <a href="../squidai/DijkstraMap.html" title="class in squidpony.squidai"><code>DijkstraMap</code></a>) that only stores two
 relevant states (a state for values between lowerBound (inclusive) and upperBound (exclusive), and another state
 for anything else), returning a short[] as described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This short[]
 can be passed to CoordPacker.unpack() to restore the relevant states and their positions as a boolean[][] (with
 true meaning between the bounds and false being anything outside them). As stated in the class documentation, the
 compressed result is intended to use as little memory as possible for most roguelike FOV maps, but here is also
 useful for compressing physical maps and gradient maps from DijkstraMap.
 <br>
 <b>To store more than two states</b>, you should use packMulti().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a double[][] that probably relates in some way to DijkstraMap.</dd>
<dd><code>lowerBound</code> - lower inclusive; any double lower than this will be off, any equal to or greater than this,
                   but less than upper, will be on</dd>
<dd><code>upperBound</code> - upper exclusive; any double greater than this will be off, any doubles both less than this
                   and equal to or greater than lower will be on</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pack(byte[][])">pack</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.486">pack</a></span>&#8203;(<span class="arguments">byte[][]&nbsp;map)</span></div>
<div class="block">Compresses a byte[][] (typically one generated by an FOV-like method) that only stores two
 relevant states (one of which should be 0 or less, the other greater than 0), returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This short[] can be passed to CoordPacker.unpack() to restore the
 relevant states and their positions as a boolean[][] (with false meaning 0 or less and true being any byte
 greater than 0). As stated in the class documentation, the compressed result is intended to use as little memory
 as possible for most roguelike FOV maps.
<br>
 <b>To store more than two states</b>, you should use packMulti().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a byte[][] that probably was returned by an FOV-like method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pack(boolean[][])">pack</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.552">pack</a></span>&#8203;(<span class="arguments">boolean[][]&nbsp;map)</span></div>
<div class="block">Compresses a boolean[][], returning a short[] as described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This
 short[] can be passed to CoordPacker.unpack() to restore the relevant states and their positions as a boolean[][]
 As stated in the class documentation, the compressed result is intended to use as little memory as possible for
 most roguelike FOV maps.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a boolean[][] that should ideally be mostly false.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pack(char[][],char)">pack</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.625">pack</a></span>&#8203;(<span class="arguments">char[][]&nbsp;map,
char&nbsp;yes)</span></div>
<div class="block">Compresses a char[][] (typically one generated by a map generating method) so only the cells that equal the yes
 parameter will be encoded as "on", returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This short[] can be passed to CoordPacker.unpack() to restore the
 positions of chars that equal the parameter yes as a boolean[][] (with false meaning not equal and true equal to
 yes). As stated in the class documentation, the compressed result is intended to use as little memory
 as possible for most roguelike FOV maps, but this will typically not be used for FOV (more typical uses are for
 walls, floors, and so on). This can still be useful for certain kinds of processing that can be done more
 efficiently on packed data than on 2D arrays, like unions, intersections, and random elements or subsets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a char[][] that may contain some area of cells that you want stored as packed data</dd>
<dd><code>yes</code> - the char to encode as "on" in the result; all others are encoded as "off"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pack(char[][],char...)">pack</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.696">pack</a></span>&#8203;(<span class="arguments">char[][]&nbsp;map,
char...&nbsp;yes)</span></div>
<div class="block">Compresses a char[][] (typically one generated by a map generating method) so only the cells that are contained
 in the yes parameter will be encoded as "on", returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This short[] can be passed to CoordPacker.unpack() to restore the
 positions of chars that equal the parameter yes as a boolean[][] (with false meaning not equal and true equal to
 yes). As stated in the class documentation, the compressed result is intended to use as little memory
 as possible for most roguelike FOV maps, but this will typically not be used for FOV (more typical uses are for
 walls, floors, and so on). This can still be useful for certain kinds of processing that can be done more
 efficiently on packed data than on 2D arrays, like unions, intersections, and random elements or subsets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a char[][] that may contain some area of cells that you want stored as packed data</dd>
<dd><code>yes</code> - the vararg or array of chars to encode as "on" in the result; all others are encoded as "off"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pack(int[][],int)">pack</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.778">pack</a></span>&#8203;(<span class="arguments">int[][]&nbsp;map,
int&nbsp;yes)</span></div>
<div class="block">Compresses a int[][] (typically one generated by MixedGenerator.getEnvironment()) so only the cells that equal
 the yes parameter will be encoded as "on", returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This short[] can be passed to CoordPacker.unpack() to restore the
 positions of ints that equal the parameter yes as a boolean[][] (with false meaning not equal and true equal to
 yes). As stated in the class documentation, the compressed result is intended to use as little memory
 as possible for most roguelike FOV maps, but this will typically not be used for FOV (more typical uses are for
 walls, floors, and so on). This can still be useful for certain kinds of processing that can be done more
 efficiently on packed data than on 2D arrays, like unions, intersections, and random elements or subsets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a int[][] that may contain some area of cells that you want stored as packed data</dd>
<dd><code>yes</code> - the int to encode as "on" in the result; all others are encoded as "off"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pack(int[][],int...)">pack</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.849">pack</a></span>&#8203;(<span class="arguments">int[][]&nbsp;map,
int...&nbsp;yes)</span></div>
<div class="block">Compresses a int[][] (typically one generated by MixedGenerator.getEnvironment()) so only the cells that are
 contained in the yes parameter will be encoded as "on", returning a short[] as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This short[] can be passed to CoordPacker.unpack() to restore the
 positions of ints that equal the parameter yes as a boolean[][] (with false meaning not equal and true equal to
 yes). As stated in the class documentation, the compressed result is intended to use as little memory
 as possible for most roguelike FOV maps, but this will typically not be used for FOV (more typical uses are for
 walls, floors, and so on). This can still be useful for certain kinds of processing that can be done more
 efficiently on packed data than on 2D arrays, like unions, intersections, and random elements or subsets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a int[][] that may contain some area of cells that you want stored as packed data</dd>
<dd><code>yes</code> - the vararg or array of ints to encode as "on" in the result; all others are encoded as "off"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="generatePackingLevels(int)">generatePackingLevels</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.930">generatePackingLevels</a></span>&#8203;(<span class="arguments">int&nbsp;totalLevels)</span></div>
<div class="block">Given a number of total levels to consider separate in a double[][] such as an FOV result, this produces a levels
 array that can be passed to packMulti() to ensure that you have the requested number of separate levels in the
 multi-packed result. For example, if you pass 6 to this method, it will return a length-6 double array, and if
 you pass that as the levels parameter to packMulti(), then that method will return a length-6 array of short
 arrays that each encode a region that met a different minimum value in the originally packed double[][].
 The behavior of this method causes any doubles that are closer to 1.0 / totalLevels than they are to 0.0 to be
 packed as "on" in at least one of packMulti()'s resultant sub-arrays. This allows Radius.CIRCLE or similar FOV
 that produces cells with values that aren't evenly distributed between 0.0 and 1.0 to be used without causing an
 explosion in the number of required levels.
 <br>
 <b>This method should not be used to generate levels for unpacking; it is only intended for packing.</b> Use the
 similar method generateLightLevels() to generate a levels array that is suitable for unpacking FOV.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>totalLevels</code> - the number of separate levels to group doubles into</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a double[] suitable as a levels parameter for packMulti()</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="generateLightLevels(int)">generateLightLevels</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.960">generateLightLevels</a></span>&#8203;(<span class="arguments">int&nbsp;totalLevels)</span></div>
<div class="block">Given a number of total levels to consider separate in a double[][] such as an FOV result, this produces a levels
 array that can be passed to unpackMultiDouble() to ensure that the minimum double returned for an "on" cell is
 1.0 / totalLevels, and every progressively tighter level in the short[][] being unpacked will be close to a
 multiple of that minimum double value. This only applies to "on" cells; any cells that did not meet a minimum
 value when packed will still be 0.0. For example, if you pass 6 to this method, it will return a length-6 double
 array, and if you pass that as the levels parameter to unpackMultiDouble(), then that method will return a
 double[][] with no more than totalLevels + 1 used values, ranging from 0.0 to 1.0 with evenly spaced values, all
 multiples of 1.0 / totalLevels, in between.
 <br>
 <b>This method should not be used to generate levels for packing; it is only intended for unpacking.</b> Use the
 similar method generatePackingLevels() to generate a levels array that is suitable for packing double[][] values.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>totalLevels</code> - the number of separate levels to assign doubles; this MUST match the size of the levels
                    parameter used to pack a double[][] with packMulti() if this is used to unpack that data</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a double[] suitable as a levels parameter for unpackMultiDouble()</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="packMulti(double[][],double[])">packMulti</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1006">packMulti</a></span>&#8203;(<span class="arguments">double[][]&nbsp;map,
double[]&nbsp;levels)</span></div>
<div class="block">Compresses a double[][] (typically one generated by <a href="../squidgrid/FOV.html" title="class in squidpony.squidgrid"><code>FOV</code></a>) that stores any number of
 states and a double[] storing up to 63 states, ordered from lowest to highest, returning a short[][] as described
 in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This short[][] can be passed to CoordPacker.unpackMultiDouble()
 to restore the state at a position to the nearest state in levels, rounded down, and return a double[][] that
 should preserve the states as closely as intended for most purposes. <b>For compressing FOV, you should generate
 levels with CoordPacker.generatePackingLevels()</b> instead of manually creating the array, because some
 imprecision is inherent in floating point math and comparisons are often incorrect between FOV with multiple
 levels and exact levels generated as simply as possible. generatePackingLevels() adds a small correction to the
 levels to compensate for floating-point math issues, which shouldn't affect the correctness of the results for
 FOV radii under 100.
<br>
 As stated in the class documentation, the compressed result is intended to use as little memory as possible for
 most roguelike FOV maps.
<br>
 <b>To store only two states</b>, you should use pack(), unless the double[][] divides data into on and off based
 on a relationship to some number other than 0.0. To (probably poorly) pack all the walls (and any cells with
 values higher than DijkstraMap.WALL) in a DijkstraMap's 2D array of doubles called dijkstraArray, you could call
 <code>packMulti(dijkstraArray, new double[]{DijkstraMap.WALL});</code>
 Then, you would use only the one sub-element of the returned short[][].</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a double[][] that probably was returned by FOV. If you obtained a double[][] from DijkstraMap, it
            will not meaningfully compress with this method unless you have very specific needs.</dd>
<dd><code>levels</code> - a double[] starting with the lowest value that should be counted as "on" (the outermost cells of
               an FOV map that has multiple grades of brightness would be counted by this) and ascending until the
               last value; the last value should be highest (commonly 1.0 for FOV), and will be used for any cells
               higher than all the other levels values. An example is an array of: 0.25, 0.5, 0.75, 1.0</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[][] that should, in most circumstances, be passed to unpackMultiDouble() or
               unpackMultiByte() when it needs to be used. The 2D array will be jagged with an outer length equal
               to the length of levels and sub-arrays that go from having longer lengths early on to very compact
               lengths by the end of the short[][].</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="packMulti(byte[][],int)">packMulti</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1104">packMulti</a></span>&#8203;(<span class="arguments">byte[][]&nbsp;map,
int&nbsp;levelCount)</span></div>
<div class="block">Compresses a byte[][] that stores any number of states, and an int no more than 63, returning a short[][] as
 described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This short[][] can be passed to 
 <a href="#unpackMultiByte(short%5B%5D%5B%5D,int,int)"><code>unpackMultiByte(short[][], int, int)</code></a> to restore the state at a position to the nearest state possible,
 capped at levelCount, and return a byte[][] that should preserve the states as closely as intended for most
 purposes.
<br>
 As stated in the class documentation, the compressed result is intended to use as little memory as possible for
 most roguelike FOV maps.
<br>
 <b>To store only two states</b>, you should use pack().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a byte[][] that probably was returned by a specialized FOV.</dd>
<dd><code>levelCount</code> - an int expressing how many levels should be present in the output; values greater than
                   levelCount in map will be treated as the highest level.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[][] that should, in most circumstances, be passed to unpackMultiDouble() or
               unpackMultiByte() when it needs to be used. The 2D array will be jagged with an outer length equal
               to the length of levels and sub-arrays that go from having longer lengths early on to very compact
               lengths by the end of the short[][].</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpack(short[],int,int)">unpack</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1197">unpack</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This returns a boolean[][] that stores the same values that were
 packed if the overload of pack() taking a boolean[][] was used. If a double[][] was compressed with pack(), the
 boolean[][] this returns will have true for all values greater than 0 and false for all others. If this is one
 of the sub-arrays compressed by packMulti(), the index of the sub-array will correspond to an index in the levels
 array passed to packMulti(), and any cells that were at least equal to the corresponding value in levels will be
 true, while all others will be false. Width and height do not technically need to match the dimensions of the
 original 2D array, but under most circumstances where they don't match, the data produced will be junk.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] encoded by calling one of this class' packing methods on a 2D array.</dd>
<dd><code>width</code> - the width of the 2D array that will be returned; should match the unpacked array's width.</dd>
<dd><code>height</code> - the height of the 2D array that will be returned; should match the unpacked array's height.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a boolean[][] storing which cells encoded by packed are on (true) or off (false).</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackDouble(short[],int,int)">unpackDouble</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1237">unpackDouble</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This returns a double[][] that stores 1.0 for true and 0.0 for
 false if the overload of pack() taking a boolean[][] was used. If a double[][] was compressed with pack(), the
 double[][] this returns will have 1.0 for all values greater than 0 and 0.0 for all others. If this is one
 of the sub-arrays compressed by packMulti(), the index of the sub-array will correspond to an index in the levels
 array passed to packMulti(), and any cells that were at least equal to the corresponding value in levels will be
 1.0, while all others will be 0.0. Width and height do not technically need to match the dimensions of the
 original 2D array, but under most circumstances where they don't match, the data produced will be junk.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] encoded by calling one of this class' packing methods on a 2D array.</dd>
<dd><code>width</code> - the width of the 2D array that will be returned; should match the unpacked array's width.</dd>
<dd><code>height</code> - the height of the 2D array that will be returned; should match the unpacked array's height.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a double[][] storing which cells encoded by packed are on (1.0) or off (0.0).</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackDoubleConical(short[],int,int,int,int,double,double)">unpackDoubleConical</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1277">unpackDoubleConical</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height,
int&nbsp;centerX,
int&nbsp;centerY,
double&nbsp;angle,
double&nbsp;span)</span></div>
<div class="block">Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
 the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. This returns a double[][] that stores 1.0 for true and 0.0 for
 false if the overload of pack() taking a boolean[][] was used. If a double[][] was compressed with pack(), the
 double[][] this returns will have 1.0 for all values greater than 0 and 0.0 for all others. If this is one
 of the sub-arrays compressed by packMulti(), the index of the sub-array will correspond to an index in the levels
 array passed to packMulti(), and any cells that were at least equal to the corresponding value in levels will be
 1.0, while all others will be 0.0. Width and height do not technically need to match the dimensions of the
 original 2D array, but under most circumstances where they don't match, the data produced will be junk.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] encoded by calling one of this class' packing methods on a 2D array.</dd>
<dd><code>width</code> - the width of the 2D array that will be returned; should match the unpacked array's width.</dd>
<dd><code>height</code> - the height of the 2D array that will be returned; should match the unpacked array's height.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a double[][] storing which cells encoded by packed are on (1.0) or off (0.0).</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackMultiDouble(short[][],int,int,double[])">unpackMultiDouble</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1331">unpackMultiDouble</a></span>&#8203;(<span class="arguments">short[][]&nbsp;packed,
int&nbsp;width,
int&nbsp;height,
double[]&nbsp;levels)</span></div>
<div class="block">Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
 using the given levels double[] as the values to assign, as described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class
 documentation. The length of levels and the length of the outer array of packed must be equal. However, the
 levels array passed to this method should not be identical to the levels array passed to packMulti(); for FOV
 compression, you should get an array for levels using generatePackingLevels(), but for decompression, you should
 create levels using generateLightLevels(), which should more appropriately fit the desired output. Reusing the
 levels array used to pack the FOV will usually produce values at the edge of FOV that are less than 0.01 but
 greater than 0, and will have a maximum value somewhat less than 1.0; neither are usually desirable, but using a
 different array made with generateLightLevels() will produce doubles ranging from 1.0 / levels.length to 1.0 at
 the highest. Width and height do not technically need to match the dimensions of the original 2D array, but under
 most circumstances where they don't match, the data produced will be junk.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[][] encoded by calling this class' packMulti() method on a 2D array.</dd>
<dd><code>width</code> - the width of the 2D array that will be returned; should match the unpacked array's width.</dd>
<dd><code>height</code> - the height of the 2D array that will be returned; should match the unpacked array's height.</dd>
<dd><code>levels</code> - a double[] that must have the same length as packed, and will be used to assign cells in the
               returned double[][] based on what levels parameter was used to compress packed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a double[][] where the values that corresponded to the nth value in the levels parameter used to
 compress packed will now correspond to the nth value in the levels parameter passed to this method.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackMultiDoublePartial(short[][],int,int,double[],int)">unpackMultiDoublePartial</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1386">unpackMultiDoublePartial</a></span>&#8203;(<span class="arguments">short[][]&nbsp;packed,
int&nbsp;width,
int&nbsp;height,
double[]&nbsp;levels,
int&nbsp;limit)</span></div>
<div class="block">Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
 using the given levels double[] as the values to assign, but only using the innermost indices up to limit, as
 described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. The length of levels and the length of the outer array
 of packed do not have to be equal. However, the levels array passed to this method should not be identical to the
 levels array passed to packMulti(); for FOV compression, you should get an array for levels using
 generatePackingLevels(), but for decompression, you should create levels using generateLightLevels(), which
 should more appropriately fit the desired output. Reusing the levels array used to pack the FOV will usually
 produce values at the edge of FOV that are less than 0.01 but greater than 0, and will have a maximum value
 somewhat less than 1.0; neither are usually desirable, but using a different array made with
 generateLightLevels() will produce doubles ranging from 1.0 / levels.length to 1.0 at the highest. Width and
 height do not technically need to match the dimensions of the original 2D array, but under most circumstances
 where they don't match, the data produced will be junk.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[][] encoded by calling this class' packMulti() method on a 2D array.</dd>
<dd><code>width</code> - the width of the 2D array that will be returned; should match the unpacked array's width.</dd>
<dd><code>height</code> - the height of the 2D array that will be returned; should match the unpacked array's height.</dd>
<dd><code>levels</code> - a double[] that must have the same length as packed, and will be used to assign cells in the
               returned double[][] based on what levels parameter was used to compress packed</dd>
<dd><code>limit</code> - the number of elements to consider from levels and packed, starting from the innermost.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a double[][] where the values that corresponded to the nth value in the levels parameter used to
 compress packed will now correspond to the nth value in the levels parameter passed to this method.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackMultiDoublePartialConical(short[][],int,int,double[],int,int,int,double,double)">unpackMultiDoublePartialConical</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1451">unpackMultiDoublePartialConical</a></span>&#8203;(<span class="arguments">short[][]&nbsp;packed,
int&nbsp;width,
int&nbsp;height,
double[]&nbsp;levels,
int&nbsp;limit,
int&nbsp;centerX,
int&nbsp;centerY,
double&nbsp;angle,
double&nbsp;span)</span></div>
<div class="block">Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
 using the given levels double[] as the values to assign, but only using the innermost indices up to limit, as
 described in the <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. The length of levels and the length of the outer array
 of packed do not have to be equal. However, the levels array passed to this method should not be identical to the
 levels array passed to packMulti(); for FOV compression, you should get an array for levels using
 generatePackingLevels(), but for decompression, you should create levels using generateLightLevels(), which
 should more appropriately fit the desired output. Reusing the levels array used to pack the FOV will usually
 produce values at the edge of FOV that are less than 0.01 but greater than 0, and will have a maximum value
 somewhat less than 1.0; neither are usually desirable, but using a different array made with
 generateLightLevels() will produce doubles ranging from 1.0 / levels.length to 1.0 at the highest. This method
 takes an angle and span as well as a centerX and centerY; the only values that will be greater than 0.0 in the
 result will be within the round-based conical section that could be produced by traveling from (centerX,centerY)
 along angle in a limitless line and expanding the cone to be span degrees broad (circularly), centered on angle.
 Width and height do not technically need to match the dimensions of the original 2D array, but under most
 circumstances where they don't match, the data produced will be junk.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[][] encoded by calling this class' packMulti() method on a 2D array.</dd>
<dd><code>width</code> - the width of the 2D array that will be returned; should match the unpacked array's width.</dd>
<dd><code>height</code> - the height of the 2D array that will be returned; should match the unpacked array's height.</dd>
<dd><code>levels</code> - a double[] that must have the same length as packed, and will be used to assign cells in the
               returned double[][] based on what levels parameter was used to compress packed</dd>
<dd><code>limit</code> - the number of elements to consider from levels and packed, starting from the innermost.</dd>
<dd><code>centerX</code> - the x position of the corner or origin of the conical FOV</dd>
<dd><code>centerY</code> - the y position of the corner or origin of the conical FOV</dd>
<dd><code>angle</code> - the center of the conical area to limit this to, in degrees</dd>
<dd><code>span</code> - the total span of the conical area to limit this to, in degrees</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a double[][] where the values that corresponded to the nth value in the levels parameter used to
 compress packed will now correspond to the nth value in the levels parameter passed to this method.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackMultiByte(short[][],int,int)">unpackMultiByte</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">byte[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1506">unpackMultiByte</a></span>&#8203;(<span class="arguments">short[][]&nbsp;packed,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Decompresses a short[][] returned by packMulti() and produces a simple 2D array where the values are bytes
 corresponding to 1 + the highest index into levels (that is, the original levels parameter passed to packMulti)
 matched by a cell, or 0 if the cell didn't match any levels during compression, as described in the
 <a href="CoordPacker.html" title="class in squidpony.squidmath"><code>CoordPacker</code></a> class documentation. Width and height do not technically need to match the dimensions of
 the original 2D array, but under most circumstances where they don't match, the data produced will be junk.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[][] encoded by calling this class' packMulti() method on a 2D array.</dd>
<dd><code>width</code> - the width of the 2D array that will be returned; should match the unpacked array's width.</dd>
<dd><code>height</code> - the height of the 2D array that will be returned; should match the unpacked array's height.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a byte[][] where the values that corresponded to the nth value in the levels parameter used to
 compress packed will now correspond to bytes with the value n+1, or 0 if they were "off" in the original array.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackChar(short[],char,char)">unpackChar</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">char[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1545">unpackChar</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
char&nbsp;t,
char&nbsp;f)</span></div>
<div class="block">Given a piece of packed data defining a region to use from that map, a char to use for "on" cells and a char to use
 for "off" cells, produces a 2D char array where all positions that are "off" in packed are filled with the char
 passed as f, and the cells that are "on" are filled with the char passed as t. Finds the bounding rectangle starting
 at the origin and extending to the highest x and highest y values encoded in packed, and uses that to determine the
 width and height of the returned 2D array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed short array, as produced by pack()</dd>
<dd><code>t</code> - the char to use for "on" positions in packed</dd>
<dd><code>f</code> - the char to use for "off" positions in packed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a 2D char array, with dimensions determined by the bounds of packed, where any "on" cells equal t and anything else equals f.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackChar(short[],int,int,char,char)">unpackChar</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">char[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1587">unpackChar</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height,
char&nbsp;t,
char&nbsp;f)</span></div>
<div class="block">Given a piece of packed data defining a region to use from that map, a desired width and height, a char to use for
 "on" cells and a char to use for "off" cells, produces a 2D char array where all positions that are "off" in packed
 are filled with the char passed as f, and the cells that are "on" are filled with the char passed as t.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed short array, as produced by pack()</dd>
<dd><code>width</code> - the desired 2D array width</dd>
<dd><code>height</code> - the desired 2D array height</dd>
<dd><code>t</code> - the char to use for "on" positions in packed</dd>
<dd><code>f</code> - the char to use for "off" positions in packed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a 2D char array, width by height in dimensions, where any "on" cells equal t and anything else equals f.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackGreasedRegion(short[],int,int)">unpackGreasedRegion</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="GreasedRegion.html" title="class in squidpony.squidmath">GreasedRegion</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1624">unpackGreasedRegion</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Utility method that constructs a GreasedRegion (a faster but more-memory-hungry way to encode regions)
 from a short array of packed data.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed short array, as produced by pack()</dd>
<dd><code>width</code> - the desired GreasedRegion's width</dd>
<dd><code>height</code> - the desired GreasedRegion's height</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a GreasedRegion that contains the same data as packed, with the specified width and height</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackIntoGreasedRegion(short[],squidpony.squidmath.GreasedRegion)">unpackIntoGreasedRegion</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="GreasedRegion.html" title="class in squidpony.squidmath">GreasedRegion</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1656">unpackIntoGreasedRegion</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
<a href="GreasedRegion.html" title="class in squidpony.squidmath">GreasedRegion</a>&nbsp;target)</span></div>
<div class="block">Utility method that fills an existing GreasedRegion <code>target</code> with any "on" cells in the packed short array
 <code>packed</code>. This method doesn't allocate unless an argument is null (then it throws a new Exception). It also
 won't insert any "on" cells in packed that are outside the width and height of target.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed short array, as produced by pack()</dd>
<dd><code>target</code> - a GreasedRegion that will be modified in-place to include "on" cells from packed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>target, after modifications to try to include any and all "on" cells in packed</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unpackIntoGreasedRegion(short[],squidpony.squidmath.GreasedRegion,int,int)">unpackIntoGreasedRegion</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="GreasedRegion.html" title="class in squidpony.squidmath">GreasedRegion</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1671">unpackIntoGreasedRegion</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
<a href="GreasedRegion.html" title="class in squidpony.squidmath">GreasedRegion</a>&nbsp;target,
int&nbsp;offsetX,
int&nbsp;offsetY)</span></div>
<div class="block">Utility method that fills an existing GreasedRegion <code>target</code> with any "on" cells in the packed short array
 <code>packed</code>, inserting cells from packed at an offset when they go into target. This method doesn't allocate
 unless an argument is null (then it throws a new Exception). It also won't insert any "on" cells in packed that
 are outside the width and height of target.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed short array, as produced by pack()</dd>
<dd><code>target</code> - a GreasedRegion that will be modified in-place to include "on" cells from packed</dd>
<dd><code>offsetX</code> - how much to offset x positions in packed by when they are placed into target</dd>
<dd><code>offsetY</code> - how much to offset y positions in packed by when they are placed into target</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>target, after modifications to try to include any and all "on" cells in packed</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="queryPacked(short[],int,int)">queryPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1701">queryPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;x,
int&nbsp;y)</span></div>
<div class="block">Quickly determines if an x,y position is true or false in the given packed array, without unpacking it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dd><code>x</code> - between 0 and 255, inclusive</dd>
<dd><code>y</code> - between 0 and 255, inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if the packed data stores true at the given x,y location, or false in any other case.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="queryPackedHilbert(short[],short)">queryPackedHilbert</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1725">queryPackedHilbert</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
short&nbsp;hilbert)</span></div>
<div class="block">Quickly determines if a Hilbert Curve index corresponds to true or false in the given packed array, without
 unpacking it.
 <br>
 Typically this method will not be needed by library-consuming code unless that code deals with Hilbert Curves in
 a frequent and deeply involved manner. It does have the potential to avoid converting to and from x,y coordinates
 and Hilbert Curve indices unnecessarily, which could matter for high-performance code.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dd><code>hilbert</code> - a Hilbert Curve index, such as one taken directly from a packed short[] without extra processing</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if the packed data stores true at the given Hilbert Curve index, or false in any other case.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="findManyPacked(int,int,short[]...)">findManyPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="OrderedSet.html" title="class in squidpony.squidmath">OrderedSet</a>&lt;short[]&gt;</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1747">findManyPacked</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y,
short[]...&nbsp;packed)</span></div>
<div class="block">Quickly determines if an x,y position is true or false in one of the given packed arrays, without unpacking them,
 and returns a List of all packed arrays that contain the position.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - between 0 and 255, inclusive</dd>
<dd><code>y</code> - between 0 and 255, inclusive</dd>
<dd><code>packed</code> - an array or vararg of short[], such as those returned by pack() or one of the sub-arrays in what is
               returned by packMulti(); null elements in packed will be skipped.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an OrderedSet of all packed arrays that store true at the given x,y location.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="findManyPacked(int,int,java.util.Collection)">findManyPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="OrderedSet.html" title="class in squidpony.squidmath">OrderedSet</a>&lt;short[]&gt;</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1775">findManyPacked</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y,
<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;short[]&gt;&nbsp;packed)</span></div>
<div class="block">Quickly determines if an x,y position is true or false in one of the given packed arrays, without unpacking them,
 and returns a List of all packed arrays that contain the position.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - between 0 and 255, inclusive</dd>
<dd><code>y</code> - between 0 and 255, inclusive</dd>
<dd><code>packed</code> - a Collection of short[] (as encoded by this class); null elements in packed will be skipped.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an OrderedSet of all packed arrays that store true at the given x,y location.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="regionsContain(short[],short[]...)">regionsContain</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1804">regionsContain</a></span>&#8203;(<span class="arguments">short[]&nbsp;checking,
short[]...&nbsp;packed)</span></div>
<div class="block">Quickly determines if a region is contained in one of the given packed arrays, without unpacking them, and
 returns true if the region checking has some overlap with any of the packed arrays, or false otherwise.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>checking</code> - the packed data to check for overlap with the other regions</dd>
<dd><code>packed</code> - an array or vararg of short[], such as those returned by pack() or one of the sub-arrays in what is
               returned by packMulti(); null elements in packed will be skipped</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if checking overlaps with any of the packed arrays, or false otherwise</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="regionsContain(short[],java.util.Collection)">regionsContain</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1821">regionsContain</a></span>&#8203;(<span class="arguments">short[]&nbsp;checking,
<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;short[]&gt;&nbsp;packed)</span></div>
<div class="block">Quickly determines if a region is contained in one of the given packed arrays, without unpacking them, and
 returns true if the region checking has some overlap with any of the packed arrays, or false otherwise.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>checking</code> - the packed data to check for overlap with the other regions</dd>
<dd><code>packed</code> - a Collection of short[], as encoded by this class; null elements in packed will be skipped</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if checking overlaps with any of the packed arrays, or false otherwise</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="findManyPackedHilbert(short,short[]...)">findManyPackedHilbert</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/ArrayList.html?is-external=true" title="class or interface in java.util" class="externalLink">ArrayList</a>&lt;short[]&gt;</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1843">findManyPackedHilbert</a></span>&#8203;(<span class="arguments">short&nbsp;hilbert,
short[]...&nbsp;packed)</span></div>
<div class="block">Quickly determines if a Hilbert Curve index corresponds to true or false in one of the given packed arrays,
 without unpacking them, and returns a List of all packed arrays that contain the position.
 <br>
 Typically this method will not be needed by library-consuming code unless that code deals with Hilbert Curves in
 a frequent and deeply involved manner. It does have the potential to avoid converting to and from x,y coordinates
 and Hilbert Curve indices unnecessarily, which could matter for high-performance code.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hilbert</code> - a Hilbert Curve index, such as one taken directly from a packed short[] without extra processing</dd>
<dd><code>packed</code> - an array or vararg of short[], such as those returned by pack() or one of the sub-arrays in what is
               returned by packMulti(); null elements in packed will be skipped.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an ArrayList of all packed arrays that store true at the given x,y location.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="allPacked(short[])">allPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1869">allPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
<div class="block">Gets all positions that are "on" in the given packed array, without unpacking it, and returns them as a Coord[].</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord[], ordered by distance along the Hilbert Curve, corresponding to all "on" cells in packed.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="allPackedHilbert(short[])">allPackedHilbert</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1899">allPackedHilbert</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
<div class="block">Gets all positions that are "on" in the given packed array, without unpacking it, and returns them as an array of
 Hilbert Curve indices.
 <br>
 Typically this method will not be needed by library-consuming code unless that code deals with Hilbert Curves in
 a frequent and deeply involved manner. It does have the potential to avoid converting to and from x,y coordinates
 and Hilbert Curve indices unnecessarily, which could matter for high-performance code.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Hilbert Curve index array, in ascending distance order, corresponding to all "on" cells in packed.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="nth(short[],int)">nth</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1929">nth</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;n)</span></div>
<div class="block">Gets the nth position that is "on" in the given packed array, without unpacking it, and returns it as a Coord.
 Uses Hilbert Curve ordering for the exact Hilbert Curve CoordPacker uses, so any two given Coords will always
 have the same before-after relationship. Returns null if n is not between 0 (inclusive) and the count of packed
 (exclusive), as by <code>CoordPacker.count()</code>.

 You can technically use nth to iterate over only the Coords that are defined in some packed data, but it's
 drastically more efficient to store a Coord array once with allPacked(). Using nth() as an iterator is
 essentially running a growing portion of what allPacked() does, over and over again, until the last Coord encoded
 in packed takes almost as long to process as one call to allPacked(). That said, for a single Coord this can be
 significantly faster than getting an array with allPacked() and fetching only one item from it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dd><code>n</code> - the index to get in packed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the nth Coord encoded as "on" by packed, ordered by distance along the Hilbert Curve, or null if n is out of bounds</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="fractionPacked(short[],int)">fractionPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.1967">fractionPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;fraction)</span></div>
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, repeatedly goes through a
 number of "on" cells equal to fraction and stores one of those cells as a Coord, and returns the accumulated
 portion of positions as a Coord[].
 <br>
 For purposes of finding mostly cells with a similar distance to each other but without obvious patterns, a value
 of 5, 6, or 7 for fraction works well for relatively-close Coords, but larger values are better for packed data
 with wide, expansive areas. If you want to make the regular pattern this uses impossible to discern, you can use
 <code>randomSeparated()</code> to keep distance between Coords and sample most areas of some packed data. Values for
 fraction that are multiples of 4 are likely to show a pattern in large open spaces more easily.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dd><code>fraction</code> - the denominator of the approximate fraction of "on" cells to use</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord[] corresponding to a fraction of the "on" cells in packed.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="randomSeparated(short[],int,squidpony.squidmath.IRNG)">randomSeparated</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2006">randomSeparated</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;separation,
<a href="IRNG.html" title="interface in squidpony.squidmath">IRNG</a>&nbsp;rng)</span></div>
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, repeatedly goes through a
 number of "on" cells equal to fraction and stores a random one of those cells as a Coord, and returns the
 accumulated random portion of positions as a Coord[]. Because of how this works, it is much more likely that the
 Coords will be dispersed so that there's a good amount of minimum distance between most Coords, while methods
 like randomPortion() do not make such dispersal a priority and may return tight clusters of Coords.
 <br>
 For purposes of finding mostly cells with a similar distance to each other but without obvious patterns, a value
 of at least 7 for fraction works well.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dd><code>separation</code> - the denominator of the approximate fraction of "on" cells to use</dd>
<dd><code>rng</code> - the <a href="IRNG.html" title="interface in squidpony.squidmath"><code>IRNG</code></a>, such as an <a href="RNG.html" title="class in squidpony.squidmath"><code>RNG</code></a> or <a href="GWTRNG.html" title="class in squidpony.squidmath"><code>GWTRNG</code></a>, to use to randomize retrieval</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord[] corresponding to a fraction of the "on" cells in packed.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="fractionPackedHilbert(short[],int)">fractionPackedHilbert</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2047">fractionPackedHilbert</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;fraction)</span></div>
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, repeatedly goes through a
 number of "on" cells equal to fraction and stores one of those cells as a Coord, and returns the accumulated
 portion of positions as an array of Hilbert Curve indices.
 <br>
 For purposes of finding mostly cells with a similar distance to each other but without obvious patterns, a value
 of 5, 6, or 7 for fraction works well.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dd><code>fraction</code> - the approximate fraction of "on" cells to use</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Hilbert Curve index array corresponding to a fraction of the "on" cells in packed.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="apartPacked(short[],int)">apartPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2074">apartPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;minDistance)</span></div>
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, keeps only positions that are
 at least minDistance apart from other positions this will return, and returns the positions as a Coord[].</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dd><code>minDistance</code> - the minimum distance (measured 8-way, Chebyshev) between any positions this returns</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord[] corresponding to a portion of the "on" cells in packed.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="apartPacked(short[],int,boolean)">apartPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2116">apartPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;minDistance,
boolean&nbsp;eightWay)</span></div>
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, keeps only positions that are
 at least minDistance apart from other positions this will return, and returns the positions as a Coord[].</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dd><code>minDistance</code> - the minimum distance (measurement depends on eightWay) between any positions this returns</dd>
<dd><code>eightWay</code> - true if distance should be measured equally in 8 directions, false to use 4 directions</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord[] corresponding to a portion of the "on" cells in packed.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="apartPackedHilbert(short[],int)">apartPackedHilbert</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2168">apartPackedHilbert</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;minDistance)</span></div>
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, keeps only positions that are
 at least minDistance apart from other positions this will return, and returns the positions as an array of
 Hilbert Curve indices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dd><code>minDistance</code> - the minimum distance (measured 8-way, Chebyshev) between any positions this returns</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Hilbert Curve index array corresponding to a portion of the "on" cells in packed.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="apartPackedHilbert(short[],int,boolean)">apartPackedHilbert</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2207">apartPackedHilbert</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;minDistance,
boolean&nbsp;eightWay)</span></div>
<div class="block">Gets the positions that are "on" in the given packed array, without unpacking it, keeps only positions that are
 at least minDistance apart from other positions this will return, and returns the positions as an array of
 Hilbert Curve indices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check due to very tight performance constraints).</dd>
<dd><code>minDistance</code> - the minimum distance (measurement depends on eightWay) between any positions this returns</dd>
<dd><code>eightWay</code> - true if distance should be measured equally in 8 directions, false to use 4 directions</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Hilbert Curve index array corresponding to a portion of the "on" cells in packed.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="translate(short[],int,int,int,int)">translate</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2262">translate</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;xMove,
int&nbsp;yMove,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Move all "on" positions in packed by the number of cells given in xMove and yMove, unless the move
 would take them further than 0, width - 1 (for xMove) or height - 1 (for yMove), in which case that
 cell is stopped at the edge (moving any shape by an xMove greater than width or yMove greater than
 height will move all "on" cells to that edge, in a 1-cell thick line). Returns a new packed short[]
 and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>xMove</code> - distance to move the x-coordinate; can be positive or negative</dd>
<dd><code>yMove</code> - distance to move the y-coordinate; can be positive or negative</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that were moved from cells that were "on" in packed</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="expand(short[],int,int,int)">expand</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2319">expand</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;expansion,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Expand each "on" position in packed to cover a a square with side length equal to 1 + expansion * 2,
 centered on the original "on" position, unless the expansion would take a cell further than 0,
 width - 1 (for xMove) or height - 1 (for yMove), in which case that cell is stopped at the edge.
 Uses 8-way movement (Chebyshev distance) unless the overload of this function that takes a boolean argument
 eightWay is used and that argument is false.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>expansion</code> - the positive (square) radius, in cells, to expand each cell out by</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for packed and cells that expanded from cells that were "on" in packed</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="expand(short[],int,int,int,boolean)">expand</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2385">expand</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;expansion,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</span></div>
<div class="block">Expand each "on" position in packed to cover a a square with side length equal to 1 + expansion * 2,
 centered on the original "on" position, unless the expansion would take a cell further than 0,
 width - 1 (for xMove) or height - 1 (for yMove), in which case that cell is stopped at the edge.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>expansion</code> - the positive (square) radius, in cells, to expand each cell out by</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dd><code>eightWay</code> - true if the expansion should be both diagonal and orthogonal; false for just orthogonal</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for packed and cells that expanded from cells that were "on" in packed</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="retract(short[],int,int,int)">retract</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2461">retract</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;retraction,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Finds the area made by removing the "on" positions in packed that are within the specified retraction distance of
 an "off" position or the edge of the map. This essentially finds a shrunken version of packed.
 Uses 8-way movement (Chebyshev distance) unless the overload of this function that takes a boolean argument
 eightWay is used and that argument is false.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>retraction</code> - the positive (square) radius, in cells, to pull each cell in by</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a short[] that encodes "on" for cells that were "on" in packed and were far enough from an "off" cell</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="retract(short[],int,int,int,boolean)">retract</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2531">retract</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;retraction,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</span></div>
<div class="block">Finds the area made by removing the "on" positions in packed that are within the specified retraction distance of
 an "off" position or the edge of the map. This essentially finds a shrunken version of packed.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>retraction</code> - the positive (square) radius, in cells, to pull each cell in by</dd>
<dd><code>width</code> - the maximum width; cells outside this are considered "off" for this method's purposes</dd>
<dd><code>height</code> - the maximum height; cells outside this are considered "off" for this method's purposes</dd>
<dd><code>eightWay</code> - true if the retraction should be both diagonal and orthogonal; false for just orthogonal</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for packed and cells that expanded from cells that were "on" in packed</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="fringe(short[],int,int,int)">fringe</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2614">fringe</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;expansion,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Finds the area around the cells encoded in packed, without including those cells. For each "on"
 position in packed, expand it to cover a a square with side length equal to 1 + expansion * 2,
 centered on the original "on" position, unless the expansion would take a cell further than 0,
 width - 1 (for xMove) or height - 1 (for yMove), in which case that cell is stopped at the edge.
 If a cell is "on" in packed, it will always be "off" in the result.
 Uses 8-way movement (Chebyshev distance) unless the overload of this function that takes a boolean argument
 eightWay is used and that argument is false.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>expansion</code> - the positive (square-shaped) radius, in cells, to expand each cell out by</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that were pushed from the edge of packed's "on" cells</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="fringe(short[],int,int,int,boolean)">fringe</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2691">fringe</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;expansion,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</span></div>
<div class="block">Finds the area around the cells encoded in packed, without including those cells. For each "on"
 position in packed, expand it to cover a a square with side length equal to 1 + expansion * 2,
 centered on the original "on" position, unless the expansion would take a cell further than 0,
 width - 1 (for xMove) or height - 1 (for yMove), in which case that cell is stopped at the edge.
 If a cell is "on" in packed, it will always be "off" in the result.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>expansion</code> - the positive (square-shaped) radius, in cells, to expand each cell out by</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dd><code>eightWay</code> - true if the expansion should be both diagonal and orthogonal; false for just orthogonal</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that were pushed from the edge of packed's "on" cells</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="fringe(short[],int,int,int,boolean,boolean)">fringe</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2778">fringe</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;expansion,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay,
boolean&nbsp;drop)</span></div>
<div class="block">Finds the area around the cells encoded in packed, without including those cells. For each "on"
 position in packed, expand it to cover a a square with side length equal to 1 + expansion * 2,
 centered on the original "on" position, unless the expansion would take a cell further than 0,
 width - 1 (for xMove) or height - 1 (for yMove), in which case that cell is removed if drop is
 true, or stopped at the edge if drop is false.
 If a cell is "on" in packed, it will always be "off" in the result.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>expansion</code> - the positive (square-shaped) radius, in cells, to expand each cell out by</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dd><code>eightWay</code> - true if the expansion should be both diagonal and orthogonal; false for just orthogonal</dd>
<dd><code>drop</code> - true to drop cells that would expand into negative coordinates or past width/height, false to stop
             their expansion early</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that were pushed from the edge of packed's "on" cells</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="fringes(short[],int,int,int)">fringes</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2880">fringes</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;expansions,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Finds the concentric areas around the cells encoded in packed, without including those cells. For each "on"
 position in packed, expand it to cover a a square with side length equal to 1 + n * 2, where n starts at 1 and
 goes up to include the expansions parameter, with each expansion centered on the original "on" position, unless
 the expansion would take a cell further than 0, width - 1 (for xMove) or height - 1 (for yMove), in which case
 that cell is stopped at the edge. If a cell is "on" in packed, it will always be "off" in the results.
 Returns a new packed short[][] where the outer array has length equal to expansions and the inner arrays are
 packed data encoding a one-cell-wide concentric fringe region. Uses 8-way measurement. Does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>expansions</code> - the positive (square-shaped) radius, in cells, to expand each cell out by, also the length
                   of the outer array returned by this method</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of packed arrays that encode "on" for cells that were pushed from the edge of packed's "on"
          cells; the outer array will have length equal to expansions, and inner arrays will normal packed data</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="fringes(short[],int,int,int,boolean)">fringes</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.2967">fringes</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;expansions,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</span></div>
<div class="block">Finds the concentric areas around the cells encoded in packed, without including those cells. For each "on"
 position in packed, expand it to cover a a square or diamond with radius equal to n, where n starts at 1 and
 goes up to include the expansions parameter, with each expansion centered on the original "on" position, unless
 the expansion would take a cell further than 0, width - 1 (for xMove) or height - 1 (for yMove), in which case
 that cell is stopped at the edge. If a cell is "on" in packed, it will always be "off" in the results.
 Returns a new packed short[][] where the outer array has length equal to expansions and the inner arrays are
 packed data encoding a one-cell-wide concentric fringe region. Does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>expansions</code> - the positive (square-shaped) radius, in cells, to expand each cell out by, also the length
                   of the outer array returned by this method</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dd><code>eightWay</code> - true if the expansion should be both diagonal and orthogonal; false for just orthogonal</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of packed arrays that encode "on" for cells that were pushed from the edge of packed's "on"
          cells; the outer array will have length equal to expansions, and inner arrays will normal packed data</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="surface(short[],int,int,int)">surface</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3055">surface</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;depth,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Finds the area consisting of the "on" positions in packed that are within the specified depth distance of an
 "off" position or the edge of the map. This essentially finds the part of packed that is close to its edge.
 Uses 8-way movement (Chebyshev distance) unless the overload of this function that takes a boolean argument
 eightWay is used and that argument is false.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>depth</code> - the positive (square) radius, in cells, to go inward from an "off" cell into the "in" cells</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a short[] that encodes "on" for cells that were "on" in packed and were close enough to an "off" cell</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="surface(short[],int,int,int,boolean)">surface</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3124">surface</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;depth,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</span></div>
<div class="block">Finds the area consisting of the "on" positions in packed that are within the specified depth distance of an
 "off" position or the edge of the map. This essentially finds the part of packed that is close to its edge.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>depth</code> - the positive (square) radius, in cells, to go inward from an "off" cell into the "in" cells</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dd><code>eightWay</code> - true if the retraction should be both diagonal and orthogonal; false for just orthogonal</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a short[] that encodes "on" for cells that were "on" in packed and were close enough to an "off" cell</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="surfaces(short[],int,int,int)">surfaces</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3141">surfaces</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;depth,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Finds the concentric, progressively-smaller surfaces of packed as if packed was shrinking with each iteration.
 Essentially, this is the inverse of fringes, where fringe finds a ring around packed and fringes finds concentric
 rings around growing versions of packed, while surface finds a ring at the edge and surfaces finds rings at the
 edge of shrinking versions of packed.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>depth</code> - the positive (square) radius, in cells, to go inward from an "off" cell into the "in" cells</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of packed short[] that each encodes "on" for cells that were "on" in packed and were at a
 distance between 1 and depth to an "off" cell</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="surfaces(short[],int,int,int,boolean)">surfaces</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3163">surfaces</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;depth,
int&nbsp;width,
int&nbsp;height,
boolean&nbsp;eightWay)</span></div>
<div class="block">Finds the concentric, progressively-smaller surfaces of packed as if packed was shrinking with each iteration.
 Essentially, this is the inverse of fringes, where fringe finds a ring around packed and fringes finds concentric
 rings around growing versions of packed, while surface finds a ring at the edge and surfaces finds rings at the
 edge of shrinking versions of packed.
 Returns a new packed short[] and does not modify packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()</dd>
<dd><code>depth</code> - the positive (square) radius, in cells, to go inward from an "off" cell into the "in" cells</dd>
<dd><code>width</code> - the maximum width; if a cell would move to x at least equal to width, it stops at width - 1</dd>
<dd><code>height</code> - the maximum height; if a cell would move to y at least equal to height, it stops at height - 1</dd>
<dd><code>eightWay</code> - true if the retraction should be both diagonal and orthogonal; false for just orthogonal</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of packed short[] that each encodes "on" for cells that were "on" in packed and were at a
 distance between 1 and depth to an "off" cell</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="flood(short[],short[],int)">flood</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3248">flood</a></span>&#8203;(<span class="arguments">short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;expansion)</span></div>
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and an
 amount of expansion, expands each cell in start by a Manhattan (diamond) radius equal to expansion, limiting any
 expansion to within bounds and returning the final expanded (limited) packed data.  Notably, if a small area is
 not present within bounds, then the flood will move around the "hole" similarly to DijkstraMap's behavior;
 essentially, it needs to expand around the hole to get to the other side, and this takes more steps of expansion
 than crossing straight over.
 Returns a new packed short[] and does not modify bounds or start.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bounds</code> - packed data representing the maximum extent of the region to flood-fill; often floors</dd>
<dd><code>start</code> - a packed array that encodes position(s) that the flood will spread outward from</dd>
<dd><code>expansion</code> - the positive (square) radius, in cells, to expand each cell out by</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that are "on" in bounds and are within expansion Manhattan
 distance from a Coord in start</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="flood(short[],short[],int,boolean)">flood</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3340">flood</a></span>&#8203;(<span class="arguments">short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;expansion,
boolean&nbsp;eightWay)</span></div>
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and an
 amount of expansion, expands each cell in start by a radius (if eightWay is true, it uses Chebyshev distance; if
 it is false, it uses Manhattan distance) equal to expansion, limiting any expansion to within bounds and
 returning the final expanded (limited) packed data. Notably, if a small area is not present within bounds, then
 the flood will move around the "hole" similarly to DijkstraMap's behavior; essentially, it needs to expand around
 the hole to get to the other side, and this takes more steps of expansion than crossing straight over.
 Returns a new packed short[] and does not modify bounds or start.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bounds</code> - packed data representing the maximum extent of the region to flood-fill; often floors</dd>
<dd><code>start</code> - a packed array that encodes position(s) that the flood will spread outward from</dd>
<dd><code>expansion</code> - the positive (square) radius, in cells, to expand each cell out by</dd>
<dd><code>eightWay</code> - true to flood-fill out in all eight directions at each step, false for just orthogonal</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that are "on" in bounds and are within expansion either
 Chebyshev (if eightWay is true) or Manhattan (otherwise) distance from a Coord in start</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="spill(short[],short[],int,squidpony.squidmath.IRNG)">spill</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3437">spill</a></span>&#8203;(<span class="arguments">short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;volume,
<a href="IRNG.html" title="interface in squidpony.squidmath">IRNG</a>&nbsp;rng)</span></div>
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, an IRNG,
 and a volume in cells, expands a random cell in start in a random Manhattan (diamond) direction equal, then
 continues to expand from random cells in start or the expanded area until it has filled volume cells, limiting
 any expansion to within bounds and returning the final expanded (limited) packed data.  Notably, if a small area
 is not present within bounds, then the spill will move around the "hole" similarly to DijkstraMap's behavior;
 essentially, it needs to expand around the hole to get to the other side, and this takes more steps of expansion
 than crossing straight over.
 <br>
 Could also be given a name like randomizedFlood(), but spill() is used by the Spill class that does this too.
 <br>
 Returns a new packed short[] and does not modify bounds or start.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bounds</code> - packed data representing the maximum extent of the region to random-flood-fill; often floors</dd>
<dd><code>start</code> - a packed array that encodes position(s) that the random-flood will spread outward from</dd>
<dd><code>volume</code> - the total number of cells to try to fill</dd>
<dd><code>rng</code> - the <a href="IRNG.html" title="interface in squidpony.squidmath"><code>IRNG</code></a>, such as an <a href="RNG.html" title="class in squidpony.squidmath"><code>RNG</code></a> or <a href="GWTRNG.html" title="class in squidpony.squidmath"><code>GWTRNG</code></a>, used to generate random numbers for the flooding</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that are "on" in bounds and are within expansion Manhattan
 distance from a Coord in start</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="radiate(short[],short[],int)">radiate</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3620">radiate</a></span>&#8203;(<span class="arguments">short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;expansion)</span></div>
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and an
 amount of expansion, expands each cell in start by a Manhattan (diamond) radius equal to expansion, limiting any
 expansion to within bounds and returning the final expanded (limited) packed data.
 Though this is otherwise similar to flood(), radiate() behaves like FOV and will not move around obstacles and
 will instead avoid expanding if it would go into any cell that cannot be reached by a straight line (drawn
 directly, not in grid steps) that is mostly unobstructed.
 Returns a new packed short[] and does not modify bounds or start.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bounds</code> - packed data representing the maximum extent of the region to flood-fill; often floors</dd>
<dd><code>start</code> - a packed array that encodes position(s) that the flood will spread outward from</dd>
<dd><code>expansion</code> - the positive (square) radius, in cells, to expand each cell out by</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that are "on" in bounds and are within expansion Manhattan
 distance from a Coord in start</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="radiate(short[],short[],int,squidpony.squidgrid.Radius)">radiate</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3640">radiate</a></span>&#8203;(<span class="arguments">short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;expansion,
<a href="../squidgrid/Radius.html" title="enum in squidpony.squidgrid">Radius</a>&nbsp;metric)</span></div>
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and an
 amount of expansion, expands each cell in start by a radius, with a shape determined by metric, equal to
 expansion, limiting any expansion to within bounds and returning the final expanded (limited) packed data.
 Though this is otherwise similar to flood(), radiate() behaves like FOV and will not move around obstacles and
 will instead avoid expanding if it would go into any cell that cannot be reached by a straight line (drawn
 directly, not in grid steps) that is mostly unobstructed.
 Returns a new packed short[] and does not modify bounds or start.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bounds</code> - packed data representing the maximum extent of the region to flood-fill; often floors</dd>
<dd><code>start</code> - a packed array that encodes position(s) that the flood will spread outward from</dd>
<dd><code>expansion</code> - the positive (square) radius, in cells, to expand each cell out by</dd>
<dd><code>metric</code> - a Radius that defines how this should expand, SQUARE for 8-way, DIAMOND for 4-way, CIRCLE for
               Euclidean expansion (not guaranteed to be perfectly circular)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that are "on" in bounds and are within expansion Manhattan
 distance from a Coord in start</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="radiate(short[],short[],int,boolean)">radiate</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3711">radiate</a></span>&#8203;(<span class="arguments">short[]&nbsp;bounds,
short[]&nbsp;start,
int&nbsp;expansion,
boolean&nbsp;eightWay)</span></div>
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and an
 amount of expansion, expands each cell in start by a radius, with a square shape if eightWay is true or a diamond
 otherwise, equal to expansion, limiting any expansion to within bounds and returning the final expanded (limited)
 packed data. Though this is otherwise similar to flood(), radiate() behaves like FOV and will not move around
 obstacles and will instead avoid expanding if it would go into any cell that cannot be reached by a straight line
 (drawn directly, not in grid steps) that is mostly unobstructed.
 Returns a new packed short[] and does not modify bounds or start.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bounds</code> - packed data representing the maximum extent of the region to flood-fill; often floors</dd>
<dd><code>start</code> - a packed array that encodes position(s) that the flood will spread outward from</dd>
<dd><code>expansion</code> - the positive (square) radius, in cells, to expand each cell out by</dd>
<dd><code>eightWay</code> - true to flood-fill out in all eight directions at each step, false for just orthogonal</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that are "on" in bounds and are within expansion either
 Chebyshev (if eightWay is true) or Manhattan (otherwise) distance from a Coord in start</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="reachable(short[],short[],squidpony.squidai.Reach)">reachable</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3738">reachable</a></span>&#8203;(<span class="arguments">short[]&nbsp;bounds,
short[]&nbsp;start,
<a href="../squidai/Reach.html" title="class in squidpony.squidai">Reach</a>&nbsp;reach)</span></div>
<div class="block">Given a packed array encoding a larger area, a packed array encoding one or more points inside bounds, and a
 Reach object that determines targeting constraints, gets all cells contained within bounds that can be targeted
 from a cell in start using the rules defined by reach.
 Though this is otherwise similar to flood(), reachable() behaves like FOV and will not move around obstacles and
 will instead avoid expanding if it would go into any cell that cannot be reached by a straight line (drawn
 directly, not in grid steps) that is mostly unobstructed. This does not behave quite like FOV if an AimLimit has
 been set in reach to any value other than null or AimLimit.FREE; in these cases it requires an exactly straight
 orthogonal or diagonal line without obstructions, checking only cells along the precise path. For diagonals and
 eight-way targeting, this means it can target through walls that only meet at a perpendicular diagonal, such as
 an X shape where one line is a one-cell-thick diagonal wall and the other is the targeting line. This is normally
 only allowed in some games and only if they use Chebyshev (Radius.SQUARE) distance, so be advised that it may not
 be desirable behavior.
 Returns a new packed short[] and does not modify bounds or start.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bounds</code> - packed data representing the max extent of the region to check for reach-ability; often floors</dd>
<dd><code>start</code> - a packed array that encodes position(s) that the flood will spread outward from</dd>
<dd><code>reach</code> - a <a href="../squidai/Reach.html" title="class in squidpony.squidai"><code>Reach</code></a> object that determines minimum and maximum range, distance metric, and AimLimit</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed array that encodes "on" for cells that are "on" in bounds and can be targeted from a cell in
 start using the given Reach</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="rectangle(int,int)">rectangle</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3849">rectangle</a></span>&#8203;(<span class="arguments">int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Given a width and height, returns a packed array that encodes "on" for the rectangle from (0,0) to
 (width - 1, height - 1). Primarily useful with intersectPacked() to ensure things like negatePacked() that can
 encode "on" cells in any position are instead limited to the bounds of the map.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>width</code> - the width of the rectangle</dd>
<dd><code>height</code> - the height of the rectangle</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] encoding "on" for all cells with x less than width and y less than height.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="rectangle(int,int,int,int)">rectangle</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3870">rectangle</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Given x, y, width and height, returns a packed array that encodes "on" for the rectangle from (x,y) to
 (width + x - 1, height + y - 1). Primarily useful with intersectPacked() to ensure things like negatePacked() that
 can encode "on" cells in any position are instead limited to the bounds of the map, but also handy for basic "box
 drawing" for other uses.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - the minimum x coordinate</dd>
<dd><code>y</code> - the minimum y coordinate</dd>
<dd><code>width</code> - the width of the rectangle</dd>
<dd><code>height</code> - the height of the rectangle</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] encoding "on" for all cells between (x,y) and (x+width-1,y+height-1).</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="rectangleHilbert(int,int,int,int)">rectangleHilbert</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3894">rectangleHilbert</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Given x, y, width and height, returns an array of all Hilbert distance within the rectangle from (x,y) to
 (width + x - 1, height + y - 1).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - the minimum x coordinate</dd>
<dd><code>y</code> - the minimum y coordinate</dd>
<dd><code>width</code> - the width of the rectangle</dd>
<dd><code>height</code> - the height of the rectangle</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a short[] that is not packed, and instead stores individual Hilbert distances in the rectangle</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="circle(squidpony.squidmath.Coord,int,int,int)">circle</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3922">circle</a></span>&#8203;(<span class="arguments"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;center,
int&nbsp;radius,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Given a center and radius for a circle, plus the width and height for the map boundaries, returns the packed data
 that encodes the circle.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>center</code> - center position of the circle</dd>
<dd><code>radius</code> - radius to extend in all directions from center</dd>
<dd><code>width</code> - the maximum width of the map (exclusive); the circle will not extend past this or below 0</dd>
<dd><code>height</code> - the maximum height of the map (exclusive); the circle will not extend past this or below 0</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a packed short[] encoding "on" for all elements inside the circle</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="count(short[])">count</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3931">count</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
<div class="block">Counts the number of "on" cells encoded in a packed array without unpacking it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed short array, as produced by pack()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number of "on" cells.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="count(short[],boolean)">count</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3942">count</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
boolean&nbsp;wanted)</span></div>
<div class="block">Counts the number of cells encoding a boolean equal to wanted in a packed array without unpacking it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed short array, as produced by pack()</dd>
<dd><code>wanted</code> - the boolean you want to count, true for "on" and false for "off"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number of cells that encode a value equal to wanted.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="covered(short[])">covered</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3957">covered</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
<div class="block">Finds how many cells are encoded in a packed array (both on and off) without unpacking it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed short array, as produced by pack()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number of cells that are encoded explicitly in the packed data as either on or off.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="bounds(short[])">bounds</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.3973">bounds</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
<div class="block">Finds the minimum bounding rectangle for a packed array without unpacking it. Returns a Coord array with 2
 elements: the minimum-x/minimum-y Coord corner of the bounds, then the maximum-x/maximum-y Coord corner. Both
 array elements will be the Coord (-1,-1) if the packed array does not encode any "on" values (all empty).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed short array, as produced by pack()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a 2-element Coord array starting with the bounds' minimum corner and followed by the maximum corner</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mask(char[][],short[],char)">mask</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">char[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4011">mask</a></span>&#8203;(<span class="arguments">char[][]&nbsp;map,
short[]&nbsp;packed,
char&nbsp;filler)</span></div>
<div class="block">Given a 2D char array for a map, a piece of packed data defining a region to use from that map, and a filler
 char, produces a 2D char array where all positions that are "off" in packed are filled with filler, and the rest
 are the same as in map.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - a 2D char array that will not be modified</dd>
<dd><code>packed</code> - a packed short array, as produced by pack()</dd>
<dd><code>filler</code> - the char to use for "off" positions in packed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a 2D char array similar to map but with any "off" positions in packed replaced with filler</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unionPacked(short[],short[])">unionPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4045">unionPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;left,
short[]&nbsp;right)</span></div>
<div class="block">Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
 that was "on" in either left or in right, and only encodes "off" for cells that were off in both. This method
 does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly preferred
 when merging two pieces of packed data.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>left</code> - A packed array such as one produced by pack()</dd>
<dd><code>right</code> - A packed array such as one produced by pack()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that were "on" in either left or right</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectPacked(short[],short[])">intersectPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4127">intersectPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;left,
short[]&nbsp;right)</span></div>
<div class="block">Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
 that was "on" in both left and in right, and encodes "off" for cells that were off in either array. This method
 does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly preferred
 when finding the intersection of two pieces of packed data.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>left</code> - A packed array such as one produced by pack()</dd>
<dd><code>right</code> - A packed array such as one produced by pack()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that were "on" in both left and right</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="isEmpty(short[])">isEmpty</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4194">isEmpty</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
<div class="block">Checks if no cells are encoded as "on" in packed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed array such as one produced by pack()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>false if there is at least one "on" cell in packed; true if there are no "on" cells</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersects(short[],short[])">intersects</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4207">intersects</a></span>&#8203;(<span class="arguments">short[]&nbsp;left,
short[]&nbsp;right)</span></div>
<div class="block">Given two packed short arrays, left and right, this returns true if they encode any overlapping area (their areas
 intersect), or false if they do not overlap at all (they don't intersect). This is more efficient than calculating
 the intersection with intersectPacked() just to check if it is non-empty, since this method can short-circuit and
 return true the moment it finds an intersection, plus it needs less overhead (slightly) to do so.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>left</code> - A packed array such as one produced by pack()</dd>
<dd><code>right</code> - A packed array such as one produced by pack()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The boolean true if left and right overlap at all, or false if they lack any intersecting area</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="negatePacked(short[])">negatePacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4265">negatePacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original)</span></div>
<div class="block">Given one packed short array, this produces a packed short array that is the exact opposite of the one passed in,
 that is, every "on" cell becomes "off" and every "off" cell becomes "on", including cells that were "off" because
 they were beyond the boundaries of the original 2D array passed to pack() or a similar method. This method does
 not do any unpacking (which can be somewhat computationally expensive), and actually requires among the lowest
 amounts of computation to get a result of any methods in CoordPacker. However, because it will cause cells to be
 considered "on" that would cause an exception if directly converted to x,y positions and accessed in the source
 2D array, this method should primarily be used in conjunction with operations such as intersectPacked(), or have
 the checking for boundaries handled internally by unpack() or related methods such as unpackMultiDouble().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" all cells that were "off" in original</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="differencePacked(short[],short[])">differencePacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4291">differencePacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;left,
short[]&nbsp;right)</span></div>
<div class="block">Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
 that was "on" in left but "off" in right, and encodes "off" for cells that were "on" in right or "off" in left.
 This method does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly
 preferred when finding a region of one packed array that is not contained in another packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>left</code> - A packed array such as one produced by pack()</dd>
<dd><code>right</code> - A packed array such as one produced by pack()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that were "on" in left and "off" in right</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="xorPacked(short[],short[])">xorPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4369">xorPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;left,
short[]&nbsp;right)</span></div>
<div class="block">Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
 that was "on" only in left or only in right, but not a cell that was "off" in both or "on" in both. This method
 does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly preferred
 when performing an exclusive-or operation on two pieces of packed data.
 <br>
 Could more-correctly be called exclusiveDisjunctionPacked to match the other terms, but... seriously?</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>left</code> - A packed array such as one produced by pack()</dd>
<dd><code>right</code> - A packed array such as one produced by pack()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells such that left's cell ^ right's cell returns true</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="packOne(int)">packOne</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4448">packOne</a></span>&#8203;(<span class="arguments">int&nbsp;hilbert)</span></div>
<div class="block">Returns a new packed short[] containing the Hilbert distance hilbert as "on", and all other cells "off".
 Much more efficient than packSeveral called with only one argument.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hilbert</code> - a Hilbert distance that will be encoded as "on"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the point given to this encoded as "on" in a packed short array</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="packOne(squidpony.squidmath.Coord)">packOne</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4458">packOne</a></span>&#8203;(<span class="arguments"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;point)</span></div>
<div class="block">Returns a new packed short[] containing the Coord point as "on", and all other cells "off".
 Much more efficient than packSeveral called with only one argument.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>point</code> - a Coord that will be encoded as "on"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the point given to this encoded as "on" in a packed short array</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="packOne(int,int)">packOne</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4469">packOne</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y)</span></div>
<div class="block">Returns a new packed short[] containing the given x,y cell as "on", and all other cells "off".
 Much more efficient than packSeveral called with only one argument.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - the x component of the point that will be encoded as "on"</dd>
<dd><code>y</code> - the y component of the point that will be encoded as "on"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the point given to this encoded as "on" in a packed short array</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="packSeveral(int...)">packSeveral</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4478">packSeveral</a></span>&#8203;(<span class="arguments">int...&nbsp;hilbert)</span></div>
<div class="block">Returns a new packed short[] containing the Hilbert distances in hilbert as "on" cells, and all other cells "off"</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hilbert</code> - a vararg or array of Hilbert distances that will be encoded as "on"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the points given to this encoded as "on" in a packed short array</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="packSeveral(squidpony.squidmath.Coord...)">packSeveral</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4508">packSeveral</a></span>&#8203;(<span class="arguments"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>...&nbsp;points)</span></div>
<div class="block">Returns a new packed short[] containing the Coords in points as "on" cells, and all other cells "off"</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - a vararg or array of Coords that will be encoded as "on"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the points given to this encoded as "on" in a packed short array</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="packSeveral(java.util.Collection)">packSeveral</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4543">packSeveral</a></span>&#8203;(<span class="arguments"><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&gt;&nbsp;points)</span></div>
<div class="block">Returns a new packed short[] containing the Coords in points as "on" cells, and all other cells "off"</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - a Collection of Coords that will be encoded as "on"</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the points given to this encoded as "on" in a packed short array</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insertPacked(short[],short)">insertPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4585">insertPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original,
short&nbsp;hilbert)</span></div>
<div class="block">Given one packed short array, original, and a Hilbert Curve index, hilbert, this produces a packed short array
 that encodes "on" for any cell that was "on" in original, always encodes "on" for the position referred
 to by hilbert, and encodes "off" for cells that were "off" in original and are not the cell hilbert refers to.
 This method does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly
 preferred when finding a region of one packed array that is not contained in another packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dd><code>hilbert</code> - A Hilbert Curve index that should be inserted into the result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that are "on" in original or correspond to hilbert</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insertPacked(short[],int,int)">insertPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4600">insertPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original,
int&nbsp;x,
int&nbsp;y)</span></div>
<div class="block">Given one packed short array, original, and a position as x,y numbers, this produces a packed short array
 that encodes "on" for any cell that was "on" in original, always encodes "on" for the position referred
 to by x and y, and encodes "off" for cells that were "off" in original and are not the cell x and y refer to.
 This method does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly
 preferred when finding a region of one packed array that is not contained in another packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dd><code>x</code> - The x position at which to insert the "on" cell</dd>
<dd><code>y</code> - The y position at which to insert the "on" cell</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that are "on" in original or correspond to x,y</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insertSeveralPacked(short[],int...)">insertSeveralPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4616">insertSeveralPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original,
int...&nbsp;hilbert)</span></div>
<div class="block">Given one packed short array, original, and a number of Hilbert Curve indices, hilbert, this produces a packed
 short array that encodes "on" for any cell that was "on" in original, always encodes "on" for the position
 referred to by any element of hilbert, and encodes "off" for cells that were "off" in original and are not in any
 cell hilbert refers to. This method does not do any unpacking (which can be somewhat computationally expensive)
 and so should be strongly preferred when you have several Hilbert Curve indices, possibly nearby each other but
 just as possibly not, that you need inserted into a packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dd><code>hilbert</code> - an array or vararg of Hilbert Curve indices that should be inserted into the result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that are "on" in original or are contained in hilbert</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insertSeveralPacked(short[],squidpony.squidmath.Coord...)">insertSeveralPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4631">insertSeveralPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original,
<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>...&nbsp;points)</span></div>
<div class="block">Given one packed short array, original, and a number of Coords, points, this produces a packed
 short array that encodes "on" for any cell that was "on" in original, always encodes "on" for the position
 referred to by any element of points, and encodes "off" for cells that were "off" in original and are not in any
 cell points refers to. This method does not do any unpacking (which can be somewhat computationally expensive)
 and so should be strongly preferred when you have several Coords, possibly nearby each other but
 just as possibly not, that you need inserted into a packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dd><code>points</code> - an array or vararg of Coords that should be inserted into the result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that are "on" in original or are contained in hilbert</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insertSeveralPacked(short[],java.util.Collection)">insertSeveralPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4646">insertSeveralPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original,
<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&gt;&nbsp;points)</span></div>
<div class="block">Given one packed short array, original, and a Collection of Coords, points, this produces a packed
 short array that encodes "on" for any cell that was "on" in original, always encodes "on" for the position
 referred to by any element of points, and encodes "off" for cells that were "off" in original and are not in any
 cell points refers to. This method does not do any unpacking (which can be somewhat computationally expensive)
 and so should be strongly preferred when you have several Coords, possibly nearby each other but
 just as possibly not, that you need inserted into a packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dd><code>points</code> - an array or vararg of Coords that should be inserted into the result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that are "on" in original or are contained in hilbert</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removePacked(short[],short)">removePacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4660">removePacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original,
short&nbsp;hilbert)</span></div>
<div class="block">Given one packed short array, original, and a Hilbert Curve index, hilbert, this produces a packed short array
 that encodes "on" for any cell that was "on" in original, unless it was the position referred to by hilbert, and
 encodes "off" for cells that were "off" in original or are the cell hilbert refers to.
 This method does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly
 preferred when finding a region of one packed array that is not contained in another packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dd><code>hilbert</code> - A Hilbert Curve index that should be removed from the result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that are "on" in original and don't correspond to hilbert</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removePacked(short[],int,int)">removePacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4675">removePacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original,
int&nbsp;x,
int&nbsp;y)</span></div>
<div class="block">Given one packed short array, original, and a position as x,y numbers, this produces a packed short array that
 encodes "on" for any cell that was "on" in original, unless it was the position referred to by x and y, and
 encodes "off" for cells that were "off" in original or are the cell x and y refer to.
 This method does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly
 preferred when finding a region of one packed array that is not contained in another packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dd><code>x</code> - The x position at which to remove any "on" cell</dd>
<dd><code>y</code> - The y position at which to remove any "on" cell</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that are "on" in original and don't correspond to x,y</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeSeveralPacked(short[],int...)">removeSeveralPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4692">removeSeveralPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original,
int...&nbsp;hilbert)</span></div>
<div class="block">Given one packed short array, original, and a number of Hilbert Curve indices, hilbert, this produces a packed
 short array that encodes "on" for any cell that was "on" in original, unless it was a position referred to by
 hilbert, and encodes "off" for cells that were "off" in original and are a cell hilbert refers to. This method
 does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly preferred
 when you have several Hilbert Curve indices, possibly nearby each other but just as possibly not, that you need
 removed from a packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dd><code>hilbert</code> - an array or vararg of Hilbert Curve indices that should be inserted into the result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that are "on" in original and aren't contained in hilbert</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeSeveralPacked(short[],squidpony.squidmath.Coord...)">removeSeveralPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4708">removeSeveralPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original,
<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>...&nbsp;points)</span></div>
<div class="block">Given one packed short array, original, and a number of Coords, points, this produces a packed short
 array that encodes "on" for any cell that was "on" in original, unless it was a position referred to by an element
 in points, and encodes "off" for cells that were "off" in original and are a cell points refers to. This method
 does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly preferred
 when you have several Hilbert Curve indices, possibly nearby each other but just as possibly not, that you need
 removed from a packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dd><code>points</code> - an array or vararg of Coords that should be removed from the result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that are "on" in original and aren't contained in points</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeSeveralPacked(short[],java.util.Collection)">removeSeveralPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4724">removeSeveralPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;original,
<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&gt;&nbsp;points)</span></div>
<div class="block">Given one packed short array, original, and a number of Coords, points, this produces a packed short
 array that encodes "on" for any cell that was "on" in original, unless it was a position referred to by an element
 in points, and encodes "off" for cells that were "off" in original and are a cell points refers to. This method
 does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly preferred
 when you have several Hilbert Curve indices, possibly nearby each other but just as possibly not, that you need
 removed from a packed array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - A packed array such as one produced by pack()</dd>
<dd><code>points</code> - a Collection of Coords that should be removed from the result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A packed array that encodes "on" for all cells that are "on" in original and aren't contained in points</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="split(short[])">split</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/ArrayList.html?is-external=true" title="class or interface in java.util" class="externalLink">ArrayList</a>&lt;short[]&gt;</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4752">split</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
<div class="block">Given a packed data array that encodes multiple unconnected "on" areas, this finds each isolated area (areas that
 are only adjacent diagonally are considered separate from each other) and returns it as an element in an
 ArrayList of short[], with one short[] array per isolated area. Useful when you have, for example, all the rooms
 in a dungeon with their connecting corridors removed, but want to separate the rooms. You can get the
 aforementioned data assuming a bare dungeon called map with WIDTH and HEIGHT constants using:
 <br>
 <code>short[] floors = pack(map, '.'),
 rooms = flood(floors, retract(floors, 1, WIDTH, HEIGHT, true), 2, false),
 corridors = differencePacked(floors, rooms),
 doors = intersectPacked(rooms, fringe(corridors, 1, WIDTH, HEIGHT, false));</code>
 <br>
 You can then get all rooms as separate regions with <code>List&lt;short[]&gt; apart = split(rooms);</code>, or substitute
 <code>split(corridors)</code> to get the corridors. The room-finding technique works by shrinking floors by a radius
 of 1 (8-way), which causes thin areas like corridors of 2 or less width to be removed, then flood-filling the
 floors out from the area that produces by 2 cells (4-way this time) to restore the original size of non-corridor
 areas (plus some extra to ensure odd shapes are kept). Corridors are obtained by removing the rooms from floors.
 The example code also gets the doors (which overlap with rooms, not corridors) by finding where the a room and a
 corridor are adjacent. This technique is used with some enhancements in the RoomFinder class.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed data array that probably encodes multiple unconnected "on" areas</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an ArrayList of short[] containing each unconnected area from packed as a short[] element</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../squidgrid/mapping/RoomFinder.html" title="class in squidpony.squidgrid.mapping"><code>for a class that uses this technique without exposing CoordPacker</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeIsolated(short[])">removeIsolated</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4773">removeIsolated</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="randomSample(short[],double,squidpony.squidmath.IRNG)">randomSample</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4804">randomSample</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
double&nbsp;fraction,
<a href="IRNG.html" title="interface in squidpony.squidmath">IRNG</a>&nbsp;rng)</span></div>
<div class="block">Gets a random subset of positions that are "on" in the given packed array, without unpacking it, and returns
 them as a Coord[]. Random numbers are generated by the rng parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check).</dd>
<dd><code>fraction</code> - the likelihood to return one of the "on" cells, from 0.0 to 1.0</dd>
<dd><code>rng</code> - the random number generator used to decide random factors.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord[], ordered by distance along the Hilbert Curve, corresponding to a random section of "on" cells
 in packed that has a random length approximately equal to the count of all "on" cells in packed times fraction.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="singleRandom(short[],squidpony.squidmath.IRNG)">singleRandom</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4835">singleRandom</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
<a href="IRNG.html" title="interface in squidpony.squidmath">IRNG</a>&nbsp;rng)</span></div>
<div class="block">Gets a single randomly chosen position that is "on" in the given packed array, without unpacking it, and returns
 it as a Coord or returns null of the array is empty. Random numbers are generated by the rng parameter.
 More efficient in most cases than randomSample(), and will always return at least one Coord for non-empty arrays.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check).</dd>
<dd><code>rng</code> - the random number generator used to decide random factors</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord corresponding to a random "on" cell in packed, or the Coord (-1, -1) if packed is empty</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="randomPortion(short[],int,squidpony.squidmath.IRNG)">randomPortion</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/ArrayList.html?is-external=true" title="class or interface in java.util" class="externalLink">ArrayList</a>&lt;<a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&gt;</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4899">randomPortion</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;size,
<a href="IRNG.html" title="interface in squidpony.squidmath">IRNG</a>&nbsp;rng)</span></div>
<div class="block">Gets a fixed number of randomly chosen positions that are "on" in the given packed array, without unpacking it,
 and returns a List of Coord with a count equal to size (or less if there aren't enough "on" cells). Random
 numbers are generated by the rng parameter. This orders the returned array in the order the Hilbert Curve takes,
 and you may want to call <a href="IRNG.html#shuffleInPlace(java.util.List)"><code>IRNG.shuffleInPlace(List)</code></a> with it as a parameter to randomize the order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
               not be null (this method does not check).</dd>
<dd><code>size</code> - the desired size of the List to return; may be smaller if there aren't enough elements</dd>
<dd><code>rng</code> - the random number generator used to decide random factors.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a List of Coords, ordered by distance along the Hilbert Curve, corresponding to randomly "on" cells in
 packed, with a length equal to the smaller of size and the count of all "on" cells in packed</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="sumMany(int,int,short[]...)">sumMany</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int[][]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4939">sumMany</a></span>&#8203;(<span class="arguments">int&nbsp;width,
int&nbsp;height,
short[]...&nbsp;many)</span></div>
<div class="block">Takes multiple pieces of packed data as short[], encoded by pack() or another similar method of this class, and
 generates a 2D int array with the specified width and height and a starting value of 0 for all elements, then
 where every occurrence of a cell as "on" in a piece of packed data increments the cell's value in the returned
 array. Width and height do not technically need to match the dimensions of the original 2D array, but under most
 circumstances where they don't match, the data produced will be junk.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>width</code> - the width of the 2D array that will be returned; should match the unpacked array's width</dd>
<dd><code>height</code> - the height of the 2D array that will be returned; should match the unpacked array's height</dd>
<dd><code>many</code> - a vararg or array of short[] encoded by calling one of this class' packing methods on a 2D array</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an int[][] storing at least 0 for all cells, plus 1 for every element of packed that has that cell "on"</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="printPacked(short[],int,int)">printPacked</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4971">printPacked</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed,
int&nbsp;width,
int&nbsp;height)</span></div>
<div class="block">Quick utility method for printing packed data as a grid of 1 (on) and/or 0 (off). Useful primarily for debugging.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed short[] such as one produced by pack()</dd>
<dd><code>width</code> - the width of the packed 2D array</dd>
<dd><code>height</code> - the height of the packed 2D array</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="printCompressedData(short[])">printCompressedData</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.4982">printCompressedData</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="encodeASCII(short[])">encodeASCII</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5002">encodeASCII</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
<div class="block">Encodes a short array of packed data as a (larger, more memory-hungry) ASCII string, which can be decoded using
 CoordPacker.decodeASCII() . Uses 64 printable chars, from '?' (ASCII 63) to '~' (ASCII 126).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed data item produced by pack() or some other method from this class.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a printable String, which can be decoded with CoordPacker.decodeASCII()</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="decodeASCII(java.lang.String)">decodeASCII</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5018">decodeASCII</a></span>&#8203;(<span class="arguments"><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;text)</span></div>
<div class="block">Given a String specifically produced by CoordPacker.encodeASCII(), this will produce a packed data array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>text</code> - a String produced by CoordPacker.encodeASCII(); this will almost certainly fail on other strings.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the packed data as a short array that was originally used to encode text</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="encodeBraille(short[])">encodeBraille</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5042">encodeBraille</a></span>&#8203;(<span class="arguments">short[]&nbsp;packed)</span></div>
<div class="block">Encodes a short array of packed data as a (larger, slightly more memory-hungry) Unicode string using only Braille
 characters, which can be decoded using CoordPacker.decodeBraille(). Uses 256 semi-printable chars, from 0x2800
 to 0x28FF, which allows UTF-8 encoding (and some other encodings) to more efficiently store the data. These are
 only semi-printable because many fonts do not support Braille, and 0x2800 is sometimes printed equivalently to a
 space char (or sometimes as 8 small dots or open circles, which is preferable). Braille was chosen because it's
 available as a full Unicode block of 256 characters with no gaps or chars that require special treatment, like
 newlines and carriage returns.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>packed</code> - a packed data item produced by pack() or some other method from this class.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a semi-printable String, which can be decoded with CoordPacker.decodeBraille()</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="decodeBraille(java.lang.String)">decodeBraille</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5062">decodeBraille</a></span>&#8203;(<span class="arguments"><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;text)</span></div>
<div class="block">Given a String specifically produced by CoordPacker.encodeBraille(), this will produce a packed data array.
 Uses 256 semi-printable chars, from 0x2800 to 0x28FF, which allows UTF-8 encoding (and some other encodings) to
 more efficiently store the data. These are only semi-printable because many fonts do not support Braille, and
 0x2800 is sometimes printed equivalently to a space char (or sometimes as 8 small dots or open circles, which is
 preferable). Braille was chosen because it's available as a full Unicode block of 256 characters with no gaps or
 chars that require special treatment, like newlines and carriage returns.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>text</code> - a String produced by CoordPacker.encodeBraille(); this will almost certainly fail on other strings.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the packed data as a short array that was originally used to encode text</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="grayEncode(int)">grayEncode</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5083">grayEncode</a></span>&#8203;(<span class="arguments">int&nbsp;n)</span></div>
<div class="block">Encode a number n as a Gray code; Gray codes have a relation to the Hilbert curve and may be useful.
 Source: http://xn--2-umb.com/15/hilbert , http://aggregate.org/MAGIC/#Gray%20Code%20Conversion</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - any int</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the gray code for n</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="grayDecode(int)">grayDecode</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5093">grayDecode</a></span>&#8203;(<span class="arguments">int&nbsp;n)</span></div>
<div class="block">Decode a number from a Gray code n; Gray codes have a relation to the Hilbert curve and may be useful.
 Source: http://xn--2-umb.com/15/hilbert , http://aggregate.org/MAGIC/#Gray%20Code%20Conversion</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - a gray code, as produced by grayEncode</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the decoded int</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="posToHilbert(int,int)">posToHilbert</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5110">posToHilbert</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y)</span></div>
<div class="block">Takes an x, y position and returns the length to travel along the 256x256 Hilbert curve to reach that position.
 This assumes x and y are between 0 and 255, inclusive.
 This uses a lookup table for the 256x256 Hilbert Curve, which should make it faster than calculating the
 distance along the Hilbert Curve repeatedly.
 Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - between 0 and 255 inclusive</dd>
<dd><code>y</code> - between 0 and 255 inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the distance to travel along the 256x256 Hilbert Curve to get to the given x, y point.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="posToHilbert3D(int,int,int)">posToHilbert3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5126">posToHilbert3D</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y,
int&nbsp;z)</span></div>
<div class="block">Takes an x, y, z position and returns the length to travel along the 8x8x8 Hilbert curve to reach that
 position. This assumes x, y, and z are between 0 and 7, inclusive.
 This uses a lookup table for the 8x8x8 Hilbert Curve, which should make it faster than calculating the
 distance along the Hilbert Curve repeatedly.
 Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - between 0 and 7 inclusive</dd>
<dd><code>y</code> - between 0 and 7 inclusive</dd>
<dd><code>z</code> - between 0 and 7 inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the distance to travel along the 8x8x8 Hilbert Curve to get to the given x, y, z point.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="posToMoore(int,int)">posToMoore</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5138">posToMoore</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y)</span></div>
<div class="block">Takes an x, y position and returns the length to travel along the 16x16 Moore curve to reach that position.
 This assumes x and y are between 0 and 15, inclusive.
 This uses a lookup table for the 16x16 Moore Curve, which should make it faster than calculating the
 distance along the Moore Curve repeatedly.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - between 0 and 15 inclusive</dd>
<dd><code>y</code> - between 0 and 15 inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the distance to travel along the 16x16 Moore Curve to get to the given x, y point.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mortonToHilbert(int)">mortonToHilbert</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5215">mortonToHilbert</a></span>&#8203;(<span class="arguments">int&nbsp;morton)</span></div>
<div class="block">Takes a position as a Morton code, with interleaved x and y bits and x in the least significant bit, and returns
 the length to travel along the 256x256 Hilbert Curve to reach that position.
 This uses 16 bits of the Morton code and requires that the code is non-negative.
 Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>morton</code> - a Morton code that interleaves two 8-bit unsigned numbers, with x as index1 and y as index2.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a distance to travel down the Hilbert Curve to reach the location that can be decoded from morton.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hilbertToMorton(int)">hilbertToMorton</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5241">hilbertToMorton</a></span>&#8203;(<span class="arguments">int&nbsp;hilbert)</span></div>
<div class="block">Takes a distance to travel along the 256x256 Hilbert curve and returns a Morton code representing the position
 in 2D space that corresponds to that point on the Hilbert Curve; the Morton code will have interleaved x and y
 bits and x in the least significant bit. This uses a lookup table for the 256x256 Hilbert curve, which should
 make it faster than calculating the position repeatedly.
 The parameter hilbert is an int but only 16 unsigned bits are used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hilbert</code> - a distance to travel down the Hilbert Curve</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Morton code that stores x and y interleaved; can be converted to a Coord with other methods.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hilbertToCoord(int)">hilbertToCoord</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5254">hilbertToCoord</a></span>&#8203;(<span class="arguments">int&nbsp;hilbert)</span></div>
<div class="block">Takes a distance to travel along the 256x256 Hilbert curve and returns a Coord representing the position
 in 2D space that corresponds to that point on the Hilbert curve. This uses a lookup table for the
 256x256 Hilbert curve, which should make it faster than calculating the position repeatedly.
 The parameter hilbert is an int but only 16 unsigned bits are used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hilbert</code> - a distance to travel down the Hilbert Curve</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord corresponding to the position in 2D space at the given distance down the Hilbert Curve</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mooreToCoord(int)">mooreToCoord</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5268">mooreToCoord</a></span>&#8203;(<span class="arguments">int&nbsp;moore)</span></div>
<div class="block">Takes a distance to travel along the 16x16 Hilbert curve and returns a Coord representing the position
 in 2D space that corresponds to that point on the Hilbert curve. This uses a lookup table for the
 16x16 Hilbert curve, which should make it faster than calculating the position repeatedly.
 The parameter moore is an int but only 8 unsigned bits are used, and since the Moore Curve loops, it is
 calculated as <code>moore &amp; 255</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>moore</code> - a distance to travel down the Moore Curve</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord corresponding to the position in 2D space at the given distance down the Hilbert Curve</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="coordToHilbert(squidpony.squidmath.Coord)">coordToHilbert</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5333">coordToHilbert</a></span>&#8203;(<span class="arguments"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;pt)</span></div>
<div class="block">Takes a position as a Coord called pt and returns the length to travel along the 256x256 Hilbert curve to reach
 that position.
 This assumes pt.x and pt.y are between 0 and 255, inclusive.
 Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pt</code> - a Coord with values between 0 and 255, inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a distance from the start of the 256x256 Hilbert curve to get to the position of pt</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="coordToMoore(squidpony.squidmath.Coord)">coordToMoore</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5345">coordToMoore</a></span>&#8203;(<span class="arguments"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;pt)</span></div>
<div class="block">Takes a position as a Coord called pt and returns the length to travel along the 16x16 Moore curve to reach
 that position.
 This assumes pt.x and pt.y are between 0 and 15, inclusive.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pt</code> - a Coord with values between 0 and 15, inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a distance from the "start" of the 16x16 Moore curve to get to the position of pt</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mortonEncode3D(int,int,int)">mortonEncode3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5350">mortonEncode3D</a></span>&#8203;(<span class="arguments">int&nbsp;index1,
int&nbsp;index2,
int&nbsp;index3)</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mortonDecode3D(int)">mortonDecode3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord3D.html" title="class in squidpony.squidmath">Coord3D</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5369">mortonDecode3D</a></span>&#8203;(<span class="arguments">int&nbsp;morton)</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mortonBitDecode3D(int)">mortonBitDecode3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5397">mortonBitDecode3D</a></span>&#8203;(<span class="arguments">int&nbsp;morton)</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getXMoore3D(int,int)">getXMoore3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5512">getXMoore3D</a></span>&#8203;(<span class="arguments">int&nbsp;index,
int&nbsp;n)</span></div>
<div class="block">Gets the x coordinate for a given index into the 16x16x(8*n) Moore curve. Expects indices to touch the following
 corners of the 16x16x(8*n) cube in this order, using x,y,z syntax:
 (0,0,0) (0,0,(8*n)) (0,16,(8*n)) (0,16,0) (16,16,0) (16,16,(8*n)) (16,0,(8*n)) (16,0,0)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - the index into the 3D 16x16x(8*n) Moore Curve, must be less than 0x1000</dd>
<dd><code>n</code> - the number of 8-deep layers to use as part of the box shape this travels through</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the x coordinate of the given distance traveled through the 3D 16x16x(8*n) Moore Curve</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getYMoore3D(int,int)">getYMoore3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5529">getYMoore3D</a></span>&#8203;(<span class="arguments">int&nbsp;index,
int&nbsp;n)</span></div>
<div class="block">Gets the y coordinate for a given index into the 16x16x(8*n) Moore curve. Expects indices to touch the following
 corners of the 16x16x(8*n) cube in this order, using x,y,z syntax:
 (0,0,0) (0,0,(8*n)) (0,16,(8*n)) (0,16,0) (16,16,0) (16,16,(8*n)) (16,0,(8*n)) (16,0,0)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - the index into the 3D 16x16x(8*n) Moore Curve, must be less than 0x1000</dd>
<dd><code>n</code> - the number of 8-deep layers to use as part of the box shape this travels through</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the y coordinate of the given distance traveled through the 3D 16x16x(8*n) Moore Curve</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getZMoore3D(int,int)">getZMoore3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5547">getZMoore3D</a></span>&#8203;(<span class="arguments">int&nbsp;index,
int&nbsp;n)</span></div>
<div class="block">Gets the z coordinate for a given index into the 16x16x(8*n) Moore curve. Expects indices to touch the following
 corners of the 16x16x(8*n) cube in this order, using x,y,z syntax:
 (0,0,0) (0,0,(8*n)) (0,16,(8*n)) (0,16,0) (16,16,0) (16,16,(8*n)) (16,0,(8*n)) (16,0,0)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - the index into the 3D 16x16x(8*n) Moore Curve, must be less than 0x1000</dd>
<dd><code>n</code> - the number of 8-deep layers to use as part of the box shape this travels through</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the z coordinate of the given distance traveled through the 3D 16x16x(8*n) Moore Curve</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="zEncode(short,short)">zEncode</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">short</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5567">zEncode</a></span>&#8203;(<span class="arguments">short&nbsp;index1,
short&nbsp;index2)</span></div>
<div class="block">Takes two 8-bit unsigned integers index1 and index2, and returns a Morton code, with interleaved index1 and
 index2 bits and index1 in the least significant bit. With this method, index1 and index2 can have up to 8 bits.
 This returns a 16-bit Morton code and WILL encode information in the sign bit if the inputs are large enough.
 Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index1</code> - a non-negative integer using at most 8 bits, to be placed in the "x" slots</dd>
<dd><code>index2</code> - a non-negative integer using at most 8 bits, to be placed in the "y" slots</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Morton code/Z-Code that interleaves the two numbers into one 16-bit short</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mortonEncode(int,int)">mortonEncode</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5594">mortonEncode</a></span>&#8203;(<span class="arguments">int&nbsp;index1,
int&nbsp;index2)</span></div>
<div class="block">Takes two 8-bit unsigned integers index1 and index2, and returns a Morton code, with interleaved index1 and
 index2 bits and index1 in the least significant bit. With this method, index1 and index2 can have up to 8 bits.
 This returns a 32-bit Morton code but only uses 16 bits, and will not encode information in the sign bit.
 Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index1</code> - a non-negative integer using at most 8 bits, to be placed in the "x" slots</dd>
<dd><code>index2</code> - a non-negative integer using at most 8 bits, to be placed in the "y" slots</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Morton code that interleaves the two numbers as one 32-bit int, but only in 16 bits of it</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mortonDecode(int)">mortonDecode</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5621">mortonDecode</a></span>&#8203;(<span class="arguments">int&nbsp;morton)</span></div>
<div class="block">Takes a Morton code, with interleaved x and y bits and x in the least significant bit, and returns the Coord
 representing the same x, y position.
 This uses 16 bits of the Morton code and requires that the code is non-negative.
 Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>morton</code> - an int containing two interleaved numbers, from 0 to 255 each</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord matching the x and y extracted from the Morton code</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="zDecode(short)">zDecode</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="Coord.html" title="class in squidpony.squidmath">Coord</a></span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/CoordPacker.html#line.5650">zDecode</a></span>&#8203;(<span class="arguments">short&nbsp;morton)</span></div>
<div class="block">Takes a Morton code, with interleaved x and y bits and x in the least significant bit, and returns the Coord
 representing the same x, y position.
 This takes a a 16-bit Z-Code with data in the sign bit, as returned by zEncode().
 Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>morton</code> - a short containing two interleaved numbers, from 0 to 255 each</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord matching the x and y extracted from the Morton code</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/CoordPacker.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2012&#x2013;2020. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
