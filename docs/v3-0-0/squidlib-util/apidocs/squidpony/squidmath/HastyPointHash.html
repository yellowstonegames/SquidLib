<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>HastyPointHash (squidlib-util 3.0.0)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: squidpony.squidmath, class: HastyPointHash">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":10,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":10,"i19":10,"i20":10,"i21":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flexBox">
<header role="banner" class="flexHeader">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/HastyPointHash.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="skipNav"><a id="skip.navbar.top">
<!--   -->
</a></div>
</nav>
</header>
<div class="flexContent">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">squidpony.squidmath</a></div>
<h1 title="Class HastyPointHash" class="title">Class HastyPointHash</h1>
</div>
<div class="contentContainer">
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">java.lang.Object</a>
<div class="inheritance"><a href="IPointHash.LongImpl.html" title="class in squidpony.squidmath">squidpony.squidmath.IPointHash.LongImpl</a>
<div class="inheritance">squidpony.squidmath.HastyPointHash</div>
</div>
</div>
<section class="description">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="IPointHash.html" title="interface in squidpony.squidmath">IPointHash</a></code></dd>
</dl>
<hr>
<pre>public final class <a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.14">HastyPointHash</a>
extends <a href="IPointHash.LongImpl.html" title="class in squidpony.squidmath">IPointHash.LongImpl</a></pre>
<div class="block">A group of similar methods for getting hashes of points based on long coordinates in 2, 3, 4, or 6 dimensions and
 a long for state; like <a href="PointHash.html" title="class in squidpony.squidmath"><code>PointHash</code></a> but faster and maybe not as high-quality. This implementation has
 high enough quality to be useful as a source of random numbers based on positions, but would likely not be a good
 option in a hash table (or at least not as good as the tailored implementation of <a href="Coord.html#hashCode()"><code>Coord.hashCode()</code></a>, for
 instance). At low dimensions, this is a little faster than <a href="PointHash.html" title="class in squidpony.squidmath"><code>PointHash</code></a>, but this class doesn't slow 
 down much at all as more dimensions are used, while PointHash and most other implementations do slow down. You
 can also consider <a href="IntPointHash.html" title="class in squidpony.squidmath"><code>IntPointHash</code></a> if your input and output types are usually int, since it's even faster.
 <br>
 This implements <a href="IPointHash.html" title="interface in squidpony.squidmath"><code>IPointHash</code></a> and has a long it uses internally for state, exposed by <a href="#getState()"><code>getState()</code></a>.</div>
</section>
<section class="summary">
<ul class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li class="blockList">
<section class="nestedClassSummary"><a id="nested.class.summary">
<!--   -->
</a>
<h2>Nested Class Summary</h2>
<div class="inheritedList">
<h2>Nested classes/interfaces inherited from interface&nbsp;squidpony.squidmath.<a href="IPointHash.html" title="interface in squidpony.squidmath">IPointHash</a></h2>
<a id="nested.classes.inherited.from.class.squidpony.squidmath.IPointHash">
<!--   -->
</a><code><a href="IPointHash.IntImpl.html" title="class in squidpony.squidmath">IPointHash.IntImpl</a>, <a href="IPointHash.LongImpl.html" title="class in squidpony.squidmath">IPointHash.LongImpl</a></code></div>
</section>
</li>
<!-- =========== FIELD SUMMARY =========== -->
<li class="blockList">
<section class="fieldSummary"><a id="field.summary">
<!--   -->
</a>
<h2>Field Summary</h2>
<div class="inheritedList">
<h3>Fields inherited from class&nbsp;squidpony.squidmath.<a href="IPointHash.LongImpl.html" title="class in squidpony.squidmath">IPointHash.LongImpl</a></h3>
<a id="fields.inherited.from.class.squidpony.squidmath.IPointHash.LongImpl">
<!--   -->
</a><code><a href="IPointHash.LongImpl.html#state">state</a></code></div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li class="blockList">
<section class="constructorSummary"><a id="constructor.summary">
<!--   -->
</a>
<h2>Constructor Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">HastyPointHash</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="tableTab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getState()">getState</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash256(long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets an 8-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash256(long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets an 8-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash256(long,long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets an 8-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash256(long,long,long,long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets an 8-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash256_alt(long,long,long,long,long)">hash256_alt</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;seed)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash32(long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 5-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash32(long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 5-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash32(long,long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 5-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash32(long,long,long,long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 5-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash64(long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 6-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash64(long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 6-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash64(long,long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 6-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash64(long,long,long,long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 6-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashAll(long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 64-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashAll(long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 64-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashAll(long,long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 64-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashAll(long,long,long,long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 64-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashWithState(int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;state)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashWithState(int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;state)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashWithState(int,int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;w,
int&nbsp;state)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashWithState(int,int,int,int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;w,
int&nbsp;u,
int&nbsp;v,
int&nbsp;state)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from class&nbsp;squidpony.squidmath.<a href="IPointHash.LongImpl.html" title="class in squidpony.squidmath">IPointHash.LongImpl</a></h3>
<a id="methods.inherited.from.class.squidpony.squidmath.IPointHash.LongImpl">
<!--   -->
</a><code><a href="IPointHash.LongImpl.html#hash(int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int,int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#setState(int)">setState</a>, <a href="IPointHash.LongImpl.html#setState(long)">setState</a></code></div>
<div class="inheritedList">
<h3>Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">Object</a></h3>
<a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a><code><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang" class="externalLink">clone</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang" class="externalLink">equals</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang" class="externalLink">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang" class="externalLink">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang" class="externalLink">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang" class="externalLink">notify</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang" class="externalLink">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang" class="externalLink">toString</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang" class="externalLink">wait</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang" class="externalLink">wait</a>, <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Object.html?is-external=true#wait(long,int)" title="class or interface in java.lang" class="externalLink">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li class="blockList">
<section class="constructorDetails"><a id="constructor.detail">
<!--   -->
</a>
<h2>Constructor Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="&lt;init&gt;()">HastyPointHash</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.14">HastyPointHash</a></span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="hashWithState(int,int,int)">hashWithState</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.16">hashWithState</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y,
int&nbsp;state)</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hashWithState(int,int,int,int)">hashWithState</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.21">hashWithState</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;state)</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hashWithState(int,int,int,int,int)">hashWithState</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.26">hashWithState</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;w,
int&nbsp;state)</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hashWithState(int,int,int,int,int,int,int)">hashWithState</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.31">hashWithState</a></span>&#8203;(<span class="arguments">int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;w,
int&nbsp;u,
int&nbsp;v,
int&nbsp;state)</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getState()">getState</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.36">getState</a></span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hashAll(long,long,long)">hashAll</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.57">hashAll</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hashAll(long,long,long,long)">hashAll</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.82">hashAll</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hashAll(long,long,long,long,long)">hashAll</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.109">hashAll</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hashAll(long,long,long,long,long,long,long)">hashAll</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.139">hashAll</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash256(long,long,long)">hash256</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.166">hash256</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash256(long,long,long,long)">hash256</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.191">hash256</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash256(long,long,long,long,long)">hash256</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.218">hash256</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash256(long,long,long,long,long,long,long)">hash256</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.248">hash256</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash32(long,long,long)">hash32</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.275">hash32</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash32(long,long,long,long)">hash32</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.300">hash32</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash32(long,long,long,long,long)">hash32</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.327">hash32</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash32(long,long,long,long,long,long,long)">hash32</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.357">hash32</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash64(long,long,long)">hash64</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.385">hash64</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash64(long,long,long,long)">hash64</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.410">hash64</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash64(long,long,long,long,long)">hash64</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.437">hash64</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash64(long,long,long,long,long,long,long)">hash64</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.467">hash64</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash256_alt(long,long,long,long,long)">hash256_alt</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/HastyPointHash.html#line.478">hash256_alt</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;seed)</span></div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/HastyPointHash.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2012&#x2013;2020. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
