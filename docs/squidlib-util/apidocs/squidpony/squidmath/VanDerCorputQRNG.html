<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>VanDerCorputQRNG (squidlib-util 3.0.6 API)</title>
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="VanDerCorputQRNG (squidlib-util 3.0.6 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":10,"i2":9,"i3":9,"i4":9,"i5":9,"i6":10,"i7":10,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":10,"i15":10,"i16":10,"i17":10,"i18":9,"i19":9,"i20":9,"i21":10,"i22":10,"i23":9,"i24":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/VanDerCorputQRNG.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../squidpony/squidmath/ValueNoise.html" title="class in squidpony.squidmath"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../squidpony/squidmath/VastNoise.html" title="class in squidpony.squidmath"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?squidpony/squidmath/VanDerCorputQRNG.html" target="_top">Frames</a></li>
<li><a href="VanDerCorputQRNG.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">squidpony.squidmath</div>
<h2 title="Class VanDerCorputQRNG" class="title">Class VanDerCorputQRNG</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>squidpony.squidmath.VanDerCorputQRNG</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.io.Serializable, <a href="../../squidpony/squidmath/RandomnessSource.html" title="interface in squidpony.squidmath">RandomnessSource</a>, <a href="../../squidpony/squidmath/StatefulRandomness.html" title="interface in squidpony.squidmath">StatefulRandomness</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">VanDerCorputQRNG</span>
extends java.lang.Object
implements <a href="../../squidpony/squidmath/StatefulRandomness.html" title="interface in squidpony.squidmath">StatefulRandomness</a>, <a href="../../squidpony/squidmath/RandomnessSource.html" title="interface in squidpony.squidmath">RandomnessSource</a>, java.io.Serializable</pre>
<div class="block">A quasi-random number generator that goes through one of many sub-random sequences found by J.G. van der Corput.
 More specifically, this offers the standard family of van der Corput sequences, each defined by a (almost always
 prime) base number. Each sequence only changes the state by incrementing it (this works better in the normal usage as
 part of a 2D or 3D point generator). The state is internally stored in a 64-bit long that is incremented once per
 generated number. The important things to know about this class are: size of state affects speed (prefer smaller
 seeds, but quality is sometimes a bit poor at first if you start at 0); the base (when given) should be prime
 (smaller bases tend to yield better quality, but oddly, larger bases perform better); this doesn't generate very
 random numbers, and is classified as a quasi-random number generator (which can be good for making points that
 should not overlap); this is a StatefulRandomness with an additional method for generating quasi-random doubles,
 <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#nextDouble--"><code>nextDouble()</code></a>; and there are several static methods offered for convenient generation of points on the
 related Halton sequence (as well as faster generation of doubles in the base-2 van der Corput sequence, and a special
 method that switches which base it uses depending on the index to seem even less clearly-patterned). There are also,
 for lack of a better place to put such small code, methods to generate points in the R2 sequence found by Martin
 Roberts, which is very similar in 2D to some Halton sequences but has better separation between points.
 <br>
 This generator allows a base (also called a radix) that changes the sequence significantly; a base should be prime,
 and this performs better in terms of time used with larger primes, though quality is also improved by preferring
 primes that aren't very large relative to the quantity of numbers expected to be generated. Unfortunately,
 performance is not especially similar to conventional PRNGs; smaller (positive) state values are processed more
 quickly than larger ones, or most negative states. At least one 64-bit integer modulus and one 64-bit integer
 division are required for any number to be produced, and the amount of both of these relatively-non-cheap operations
 increases linearly with the number of digits (in the specified base, which is usually not 10) needed to represent
 the current state. Since performance is not optimal, and the results are rather strange anyway relative to PRNGs,
 this should not be used as a direct substitute for a typical RandomnessSource (however, it is similar to, but simpler
 and faster than, <a href="../../squidpony/squidmath/SobolQRNG.html" title="class in squidpony.squidmath"><code>SobolQRNG</code></a>). So what's it good for?
 <br>
 A VanDerCorputSequence can be a nice building block for more complicated quasi-randomness, especially for points in
 2D or 3D. There's a simple way that should almost always "just work" as the static method
 <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#halton-int-int-int-int:A-"><code>halton(int, int, int, int[])</code></a> here. If it doesn't meet your needs, there's a little more complexity involved.
 Using a VanDerCorputQRNG with base 3 for the x-axis and another VanDerCorputQRNG with base 5 for the y-axis,
 requesting a double from each to make points between (0.0, 0.0) and (1.0, 1.0), has an interesting trait that can be
 desirable for many kinds of positioning in 2D: once a point has been generated, an identical point will never be
 generated until floating-point precision runs out, but more than that, nearby points will almost never be generated
 for many generations, and most points will stay at a comfortable distance from each other if the bases are different
 and both prime (or, more technically, if they share no common denominators). This is also known as a Halton sequence,
 which is a group of sequences of points instead of simply numbers. The choices of 3 and 5 are examples; any two
 different primes will technically work for 2D (as well as any two numbers that share no common factor other than 1,
 that is, they are relatively coprime), but patterns can be noticeable with primes larger than about 7, with 11 and 13
 sometimes acceptable. Three VanDerCorputQRNG sequences could be used for a Halton sequence of 3D
 points, using three different prime bases, four for 4D, etc. SobolQRNG can be used for the same purpose, but the
 points it generates are typically more closely-aligned to a specific pattern, the pattern is symmetrical between all
 four quadrants of the square between (0.0, 0.0) and (1.0, 1.0) in 2D, and it probably extends into higher dimensions.
 Using one of the possible Halton sequences gives some more flexibility in the kinds of random-like points produced.
 Oddly, using a base-2 van der Corput sequence as the x axis in a Halton sequence and a base-39 van der Corput
 sequence as the y axis results in the greatest minimum distance between points found so far while still involving a
 base-2 sequence (which is preferential for performance). There, the minimum distance between the first 65536 points
 in the [0,1) range is 0.001147395; a runner-up is a y base of 13, which has a minimum distance of 0.000871727 . The
 (2,39) Halton sequence is used by <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#halton-int-int-int-"><code>halton(int, int, int)</code></a> and <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#halton-int-int-int-int:A-"><code>halton(int, int, int, int[])</code></a>.
 <br>
 Created by Tommy Ettinger on 11/18/2016. Uses code adapted from
 <a href="https://blog.demofox.org/2017/05/29/when-random-numbers-are-too-random-low-discrepancy-sequences/">Alan Wolfe's blog</a>,
 which turned out to be a lot faster than the previous way I had it implemented.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../serialized-form.html#squidpony.squidmath.VanDerCorputQRNG">Serialized Form</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#base">base</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#state">state</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#VanDerCorputQRNG--">VanDerCorputQRNG</a></span>()</code>
<div class="block">Constructs a new van der Corput sequence generator with base 7, starting point 37, and scrambling disabled.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#VanDerCorputQRNG-int-long-">VanDerCorputQRNG</a></span>(int&nbsp;base,
                long&nbsp;seed)</code>
<div class="block">Constructs a new van der Corput sequence generator with the given base (a.k.a.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#VanDerCorputQRNG-long-">VanDerCorputQRNG</a></span>(long&nbsp;seed)</code>
<div class="block">Constructs a new van der Corput sequence generator with the given starting point in the sequence as a seed.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#altDetermine-long-int-">altDetermine</a></span>(long&nbsp;base,
            int&nbsp;index)</code>
<div class="block">Similar to <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determine-int-int-"><code>determine(int, int)</code></a>, but can take bases that aren't prime and can sometimes produce a
 Halton-like sequence with almost-as-good distance between points.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="../../squidpony/squidmath/VanDerCorputQRNG.html" title="class in squidpony.squidmath">VanDerCorputQRNG</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#copy--">copy</a></span>()</code>
<div class="block">Produces a copy of this StatefulRandomness that, if next() and/or nextLong() are called on this object and the
 copy, both will generate the same sequence of random numbers from the point copy() was called.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determine-int-int-">determine</a></span>(int&nbsp;base,
         int&nbsp;index)</code>
<div class="block">Convenience method to get a double from the van der Corput sequence with the given <code>base</code> at the requested
 <code>index</code> without needing to construct a VanDerCorputQRNG.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determine2_scrambled-int-">determine2_scrambled</a></span>(int&nbsp;index)</code>
<div class="block">Method to get a double from the van der Corput sequence with the base 2 at a scrambling of the requested
 <code>index</code> without needing to construct a VanDerCorputQRNG.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determine2-int-">determine2</a></span>(int&nbsp;index)</code>
<div class="block">Convenience method to get a double from the van der Corput sequence with the base 2 at the requested
 <code>index</code> without needing to construct a VanDerCorputQRNG.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determineMixed-int-">determineMixed</a></span>(int&nbsp;index)</code>
<div class="block">Chooses one sequence from the van der Corput sequences with bases 2, 3, and 5, where 5 is used 1/8 of the time,
 3 is used 3/8 of the time, and 2 is used 1/2 of the time, and returns a double from the chosen sequence at the
 specified <code>index</code>.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#equals-java.lang.Object-">equals</a></span>(java.lang.Object&nbsp;o)</code>&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#getState--">getState</a></span>()</code>
<div class="block">Get the current internal state of the StatefulRandomness as a long.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static <a href="../../squidpony/squidmath/Coord.html" title="class in squidpony.squidmath">Coord</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#haltoid-int-int-int-int-int-int-">haltoid</a></span>(int&nbsp;seed,
       int&nbsp;width,
       int&nbsp;height,
       int&nbsp;xOffset,
       int&nbsp;yOffset,
       int&nbsp;index)</code>
<div class="block">Samples a quasi-random Coord sequence that is almost unique to the given seed, getting a Coord with x between
 xOffset (inclusive) and width + xOffset (exclusive), y between yOffset (inclusive) and height + yOffset
 (exclusive).</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static <a href="../../squidpony/squidmath/Coord.html" title="class in squidpony.squidmath">Coord</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#halton-int-int-int-">halton</a></span>(int&nbsp;width,
      int&nbsp;height,
      int&nbsp;index)</code>
<div class="block">Convenience method that gets a quasi-random Coord between integer (0,0) inclusive and (width,height) exclusive
 and gets the corresponding Coord from the Coord pool.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static <a href="../../squidpony/squidmath/Coord3D.html" title="class in squidpony.squidmath">Coord3D</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#halton-int-int-int-int-">halton</a></span>(int&nbsp;width,
      int&nbsp;height,
      int&nbsp;depth,
      int&nbsp;index)</code>
<div class="block">Convenience method that gets a quasi-random Coord3D between integer (0,0,0) inclusive and (width,height,depth)
 exclusive.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#halton-int-int-int-int:A-">halton</a></span>(int&nbsp;width,
      int&nbsp;height,
      int&nbsp;index,
      int[]&nbsp;point)</code>
<div class="block">Convenience method that gets a quasi-random 2D point between integer (0,0) inclusive and (width,height)
 exclusive and fills it into point.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static <a href="../../squidpony/squidmath/Coord.html" title="class in squidpony.squidmath">Coord</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#halton-int-int-int-int-int-">halton</a></span>(int&nbsp;width,
      int&nbsp;height,
      int&nbsp;xOffset,
      int&nbsp;yOffset,
      int&nbsp;index)</code>
<div class="block">Convenience method that gets a quasi-random Coord between integer (0,0) inclusive and (width,height) exclusive
 and gets the corresponding Coord from the Coord pool.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#halton-int-int-int-int-int:A-">halton</a></span>(int&nbsp;width,
      int&nbsp;height,
      int&nbsp;depth,
      int&nbsp;index,
      int[]&nbsp;point)</code>
<div class="block">Convenience method that gets a quasi-random 3D point between integer (0,0,0) inclusive and (width,height,depth)
 exclusive.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#hashCode--">hashCode</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#next-int-">next</a></span>(int&nbsp;bits)</code>
<div class="block">Using this method, any algorithm that might use the built-in Java Random
 can interface with this randomness source.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#nextDouble--">nextDouble</a></span>()</code>
<div class="block">Gets the next quasi-random double from between 0.0 and 1.0 (normally both exclusive; only if state is negative or
 has wrapped around to a negative value can 0.0 ever be produced).</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#nextLong--">nextLong</a></span>()</code>
<div class="block">Gets the next quasi-random long as a fraction of <code>Long.MAX_VALUE</code>; this can never produce a negative value.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#planarDetermine-long-int-">planarDetermine</a></span>(long&nbsp;base,
               int&nbsp;index)</code>
<div class="block">A quasi-random number generator of doubles between 0.0 inclusive and 1.0 exclusive, but that has issues when it
 would be used like a Halton sequence.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#roberts-int-int-int-">roberts</a></span>(int&nbsp;span,
       int&nbsp;offset,
       int&nbsp;index)</code>
<div class="block">Martin Roberts' "unreasonably effective" quasi-random int sequence based on the golden ratio.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static <a href="../../squidpony/squidmath/Coord.html" title="class in squidpony.squidmath">Coord</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#roberts-int-int-int-int-int-">roberts</a></span>(int&nbsp;width,
       int&nbsp;height,
       int&nbsp;xOffset,
       int&nbsp;yOffset,
       int&nbsp;index)</code>
<div class="block">Martin Roberts' "unreasonably effective" quasi-random point sequence based on a 2D analogue to the golden ratio.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#setState-long-">setState</a></span>(long&nbsp;state)</code>
<div class="block">Set the current internal state of this StatefulRandomness with a long.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#toString--">toString</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#weakDetermine-int-">weakDetermine</a></span>(int&nbsp;index)</code>
<div class="block">Given any int (0 is allowed), this gets a somewhat-sub-random float from 0.0 (inclusive) to 1.0 (exclusive)
 using the same implementation as <a href="../../squidpony/squidmath/NumberTools.html#randomFloat-long-"><code>NumberTools.randomFloat(long)</code></a> but with index alterations.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/VanDerCorputQRNG.html#weakSignedDetermine-int-">weakSignedDetermine</a></span>(int&nbsp;index)</code>
<div class="block">Like <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#weakDetermine-int-"><code>weakDetermine(int)</code></a>, but returns a float between -1.0f and 1.0f, exclusive on both.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="state">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>state</h4>
<pre>public&nbsp;long state</pre>
</li>
</ul>
<a name="base">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>base</h4>
<pre>public final&nbsp;int base</pre>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="VanDerCorputQRNG--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VanDerCorputQRNG</h4>
<pre>public&nbsp;VanDerCorputQRNG()</pre>
<div class="block">Constructs a new van der Corput sequence generator with base 7, starting point 37, and scrambling disabled.</div>
</li>
</ul>
<a name="VanDerCorputQRNG-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VanDerCorputQRNG</h4>
<pre>public&nbsp;VanDerCorputQRNG(long&nbsp;seed)</pre>
<div class="block">Constructs a new van der Corput sequence generator with the given starting point in the sequence as a seed.
 Usually seed should be at least 20 with this constructor, but not drastically larger; 2000 is probably too much.
 This will use a base 7 van der Corput sequence and have scrambling disabled.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>seed</code> - the seed as a long that will be used as the starting point in the sequence; ideally positive but low</dd>
</dl>
</li>
</ul>
<a name="VanDerCorputQRNG-int-long-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>VanDerCorputQRNG</h4>
<pre>public&nbsp;VanDerCorputQRNG(int&nbsp;base,
                        long&nbsp;seed)</pre>
<div class="block">Constructs a new van der Corput sequence generator with the given base (a.k.a. radix; if given a base less than
 2, this will use base 2 instead) and starting point in the sequence as a seed. Good choices for base are between
 10 and 60 or so, and should usually be prime. Good choices for seed are larger than base but not by very much,
 and should generally be positive at construction time.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - the base or radix used for this VanDerCorputQRNG; for most uses this should be prime but small-ish</dd>
<dd><code>seed</code> - the seed as a long that will be used as the starting point in the sequence; ideally positive but low</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="nextLong--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextLong</h4>
<pre>public&nbsp;long&nbsp;nextLong()</pre>
<div class="block">Gets the next quasi-random long as a fraction of <code>Long.MAX_VALUE</code>; this can never produce a negative value.
 It is extremely unlikely to produce two identical values unless the state is very high or is negative; state
 increases by exactly 1 each time this, <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#next-int-"><code>next(int)</code></a>, or <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#nextDouble--"><code>nextDouble()</code></a> is called and can potentially
 wrap around to negative values after many generations.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../squidpony/squidmath/RandomnessSource.html#nextLong--">nextLong</a></code>&nbsp;in interface&nbsp;<code><a href="../../squidpony/squidmath/RandomnessSource.html" title="interface in squidpony.squidmath">RandomnessSource</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a quasi-random non-negative long; may return 0 rarely, probably can't return <code>Long.MAX_VALUE</code></dd>
</dl>
</li>
</ul>
<a name="next-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>next</h4>
<pre>public&nbsp;int&nbsp;next(int&nbsp;bits)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../squidpony/squidmath/RandomnessSource.html#next-int-">RandomnessSource</a></code></span></div>
<div class="block">Using this method, any algorithm that might use the built-in Java Random
 can interface with this randomness source.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../squidpony/squidmath/RandomnessSource.html#next-int-">next</a></code>&nbsp;in interface&nbsp;<code><a href="../../squidpony/squidmath/RandomnessSource.html" title="interface in squidpony.squidmath">RandomnessSource</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bits</code> - the number of bits to be returned</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the integer containing the appropriate number of bits</dd>
</dl>
</li>
</ul>
<a name="nextDouble--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextDouble</h4>
<pre>public&nbsp;double&nbsp;nextDouble()</pre>
<div class="block">Gets the next quasi-random double from between 0.0 and 1.0 (normally both exclusive; only if state is negative or
 has wrapped around to a negative value can 0.0 ever be produced). It should be nearly impossible for this to
 return the same number twice unless floating-point precision has been exhausted or a very large amount of numbers
 have already been generated. Certain unusual bases may make this more likely.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a quasi-random double that will always be less than 1.0 and will be no lower than 0.0</dd>
</dl>
</li>
</ul>
<a name="copy--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre>public&nbsp;<a href="../../squidpony/squidmath/VanDerCorputQRNG.html" title="class in squidpony.squidmath">VanDerCorputQRNG</a>&nbsp;copy()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../squidpony/squidmath/StatefulRandomness.html#copy--">StatefulRandomness</a></code></span></div>
<div class="block">Produces a copy of this StatefulRandomness that, if next() and/or nextLong() are called on this object and the
 copy, both will generate the same sequence of random numbers from the point copy() was called. This just needs to
 copy the state so it isn't shared, usually, and produce a new value with the same exact state.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../squidpony/squidmath/RandomnessSource.html#copy--">copy</a></code>&nbsp;in interface&nbsp;<code><a href="../../squidpony/squidmath/RandomnessSource.html" title="interface in squidpony.squidmath">RandomnessSource</a></code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../squidpony/squidmath/StatefulRandomness.html#copy--">copy</a></code>&nbsp;in interface&nbsp;<code><a href="../../squidpony/squidmath/StatefulRandomness.html" title="interface in squidpony.squidmath">StatefulRandomness</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a copy of this StatefulRandomness</dd>
</dl>
</li>
</ul>
<a name="getState--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getState</h4>
<pre>public&nbsp;long&nbsp;getState()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../squidpony/squidmath/StatefulRandomness.html#getState--">StatefulRandomness</a></code></span></div>
<div class="block">Get the current internal state of the StatefulRandomness as a long.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../squidpony/squidmath/StatefulRandomness.html#getState--">getState</a></code>&nbsp;in interface&nbsp;<code><a href="../../squidpony/squidmath/StatefulRandomness.html" title="interface in squidpony.squidmath">StatefulRandomness</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current internal state of this object.</dd>
</dl>
</li>
</ul>
<a name="setState-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setState</h4>
<pre>public&nbsp;void&nbsp;setState(long&nbsp;state)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../squidpony/squidmath/StatefulRandomness.html#setState-long-">StatefulRandomness</a></code></span></div>
<div class="block">Set the current internal state of this StatefulRandomness with a long.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../squidpony/squidmath/StatefulRandomness.html#setState-long-">setState</a></code>&nbsp;in interface&nbsp;<code><a href="../../squidpony/squidmath/StatefulRandomness.html" title="interface in squidpony.squidmath">StatefulRandomness</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>state</code> - a 64-bit long. You should avoid passing 0, even though some implementations can handle that.</dd>
</dl>
</li>
</ul>
<a name="toString--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="equals-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre>public&nbsp;boolean&nbsp;equals(java.lang.Object&nbsp;o)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>equals</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="hashCode--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashCode</h4>
<pre>public&nbsp;int&nbsp;hashCode()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>hashCode</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="halton-int-int-int-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>halton</h4>
<pre>public static&nbsp;int[]&nbsp;halton(int&nbsp;width,
                           int&nbsp;height,
                           int&nbsp;index,
                           int[]&nbsp;point)</pre>
<div class="block">Convenience method that gets a quasi-random 2D point between integer (0,0) inclusive and (width,height)
 exclusive and fills it into point. This is roughly equivalent to creating two VanDerCorputQRNG generators, one
 with <code>new VanDerCorputQRNG(2, index)</code> and the other with
 <code>new VanDerCorputQRNG(39, index)</code>, then getting an x-coordinate from the first with
 <code>(int)(nextDouble() * width)</code> and similarly for y with the other generator. The advantage here is you don't
 actually create any objects using this static method, only assigning to point, if valid. You might find an
 advantage in using values for index that start higher than 20 or so, but you can pass sequential values for index
 and generally get points that won't be near each other; this is not true for all parameters to Halton sequences,
 but it is true for this one.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>width</code> - the maximum exclusive bound for the x-positions (index 0) of points this can return</dd>
<dd><code>height</code> - the maximum exclusive bound for the y-positions (index 1) of points this can return</dd>
<dd><code>index</code> - an int that, if unique, positive, and not too large, will usually result in unique points</dd>
<dd><code>point</code> - an int array that will be modified; should have length 2; if null or too small, a new array will be created</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>point after modifications to the first two items, or a new array if point is null or too small</dd>
</dl>
</li>
</ul>
<a name="halton-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>halton</h4>
<pre>public static&nbsp;<a href="../../squidpony/squidmath/Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;halton(int&nbsp;width,
                           int&nbsp;height,
                           int&nbsp;index)</pre>
<div class="block">Convenience method that gets a quasi-random Coord between integer (0,0) inclusive and (width,height) exclusive
 and gets the corresponding Coord from the Coord pool. This is roughly equivalent to creating two VanDerCorputQRNG
 generators, one with <code>new VanDerCorputQRNG(2, index)</code> and the other with
 <code>new VanDerCorputQRNG(39, index)</code>, then getting an x-coordinate from the first with
 <code>(int)(nextDouble() * width)</code> and similarly for y with the other generator. You might find an advantage in
 using values for index that start higher than 20 or so, but you can pass sequential values for index and
 generally get points that won't be near each other; this is not true for all parameters to Halton sequences, but
 it is true for this one.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>width</code> - the maximum exclusive bound for the x-positions (index 0) of points this can return</dd>
<dd><code>height</code> - the maximum exclusive bound for the y-positions (index 1) of points this can return</dd>
<dd><code>index</code> - an int that, if unique, positive, and not too large, will usually result in unique points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>point after modifications to the first two items, or a new array if point is null or too small</dd>
</dl>
</li>
</ul>
<a name="halton-int-int-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>halton</h4>
<pre>public static&nbsp;<a href="../../squidpony/squidmath/Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;halton(int&nbsp;width,
                           int&nbsp;height,
                           int&nbsp;xOffset,
                           int&nbsp;yOffset,
                           int&nbsp;index)</pre>
<div class="block">Convenience method that gets a quasi-random Coord between integer (0,0) inclusive and (width,height) exclusive
 and gets the corresponding Coord from the Coord pool. This is roughly equivalent to creating two VanDerCorputQRNG
 generators, one with <code>new VanDerCorputQRNG(2, index)</code> and the other with
 <code>new VanDerCorputQRNG(39, index)</code>, then getting an x-coordinate from the first with
 <code>(int)(nextDouble() * width)</code> and similarly for y with the other generator. You might find an advantage in
 using values for index that start higher than 20 or so, but you can pass sequential values for index and
 generally get points that won't be near each other; this is not true for all parameters to Halton sequences, but
 it is true for this one.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>width</code> - the width of the area this can cover</dd>
<dd><code>height</code> - the height of the area this can cover</dd>
<dd><code>xOffset</code> - the lowest x-coordinate this can produce, and also added to width to get the upper bound on x</dd>
<dd><code>yOffset</code> - the lowest y-coordinate this can produce, and also added to height to get the upper bound on y</dd>
<dd><code>index</code> - an int that, if unique, positive, and not too large, will usually result in unique points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>point after modifications to the first two items, or a new array if point is null or too small</dd>
</dl>
</li>
</ul>
<a name="halton-int-int-int-int-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>halton</h4>
<pre>public static&nbsp;int[]&nbsp;halton(int&nbsp;width,
                           int&nbsp;height,
                           int&nbsp;depth,
                           int&nbsp;index,
                           int[]&nbsp;point)</pre>
<div class="block">Convenience method that gets a quasi-random 3D point between integer (0,0,0) inclusive and (width,height,depth)
 exclusive. This is roughly equivalent to creating three VanDerCorputQRNG generators, one with
 <code>new VanDerCorputQRNG(2, index)</code> another with <code>new VanDerCorputQRNG(3, index)</code>,
 and another with <code>new VanDerCorputQRNG(5, index)</code>, then getting an x-coordinate from the first with
 <code>(int)(nextDouble() * width)</code> and similarly for y and z with the other generators. The advantage here is
 you don't actually create any objects using this static method, only assigning to point, if valid. You might find
 an advantage in using values for index that start higher than 20 or so, but you can pass sequential values for
 index and generally get points that won't be near each other; this is not true for all parameters to Halton
 sequences, but it is true for this one.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>width</code> - the maximum exclusive bound for the x-positions (index 0) of points this can return</dd>
<dd><code>height</code> - the maximum exclusive bound for the y-positions (index 1) of points this can return</dd>
<dd><code>depth</code> - the maximum exclusive bound for the z-positions (index 2) of points this can return</dd>
<dd><code>index</code> - an int that, if unique, positive, and not too large, will usually result in unique points</dd>
<dd><code>point</code> - an int array that will be modified; should have length 3; if null or too small, a new array will be created</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>point after modifications to the first two items, or a new array if point is null or too small</dd>
</dl>
</li>
</ul>
<a name="halton-int-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>halton</h4>
<pre>public static&nbsp;<a href="../../squidpony/squidmath/Coord3D.html" title="class in squidpony.squidmath">Coord3D</a>&nbsp;halton(int&nbsp;width,
                             int&nbsp;height,
                             int&nbsp;depth,
                             int&nbsp;index)</pre>
<div class="block">Convenience method that gets a quasi-random Coord3D between integer (0,0,0) inclusive and (width,height,depth)
 exclusive. This is roughly equivalent to creating three VanDerCorputQRNG generators, one with
 <code>new VanDerCorputQRNG(2, index)</code> another with <code>new VanDerCorputQRNG(3, index)</code>,
 and another with <code>new VanDerCorputQRNG(5, index)</code>, then getting an x-coordinate from the first with
 <code>(int)(nextDouble() * width)</code> and similarly for y and z with the other generators. This overload always
 creates a new Coord3D object, so you might prefer <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#halton-int-int-int-int-int:A-"><code>halton(int, int, int, int, int[])</code></a>, which can reuse an
 int array. You might find an advantage in using values for index that start higher than 20 or so, but you can
 pass sequential values for index and generally get points that won't be near each other; this is not true for all
 parameters to Halton sequences, but it is true for this one.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>width</code> - the maximum exclusive bound for the x-positions (index 0) of points this can return</dd>
<dd><code>height</code> - the maximum exclusive bound for the y-positions (index 1) of points this can return</dd>
<dd><code>depth</code> - the maximum exclusive bound for the z-positions (index 2) of points this can return</dd>
<dd><code>index</code> - an int that, if unique, positive, and not too large, will usually result in unique points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new Coord3D with x,y,z between 0,0,0 (inclusive) and width,height,depth (exclusive)</dd>
</dl>
</li>
</ul>
<a name="determine-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determine</h4>
<pre>public static&nbsp;double&nbsp;determine(int&nbsp;base,
                               int&nbsp;index)</pre>
<div class="block">Convenience method to get a double from the van der Corput sequence with the given <code>base</code> at the requested
 <code>index</code> without needing to construct a VanDerCorputQRNG. You should use a prime number for base; 2, 3, 5,
 and 7 should be among the first choices to ensure optimal quality unless you are scrambling the index yourself.
 If speed is the priority, then larger prime bases counter-intuitively perform better than small ones; 0x1337,
 0xDE4D, 0x510B and 0xACED are all probable primes (using <code>BigInteger.isProbablePrime(int)</code>) that
 may do well here for speed but will likely require some basic scrambling of the index order. This method on its
 own does not perform any scrambling on index other than incrementing it and ensuring it is positive (by
 discarding the sign bit; for all positive index values other than 0x7FFFFFFF, this has no effect). If you want
 to quickly scramble an int index <code>i</code> for this purpose, try
 <code>(i ^ (i &lt;&lt; 7 | i &gt;&gt;&gt; 25) ^ (i &lt;&lt; 19 | i &gt;&gt;&gt; 13))</code>, which may compile to SSE instructions on recent 
 desktop processors and won't risk losing precision on GWT.
 <br>
 Uses the same algorithm as <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determine2-int-"><code>determine2(int)</code></a> when base is 2, which should offer some speed improvement.
 The other bases use code adapted from
 <a href="https://blog.demofox.org/2017/05/29/when-random-numbers-are-too-random-low-discrepancy-sequences/">Alan Wolfe's blog</a>,
 which turned out to be a lot faster than the previous way I had it implemented.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - a prime number to use as the base/radix of the van der Corput sequence</dd>
<dd><code>index</code> - the position in the sequence of the requested base, as a non-negative int</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a quasi-random double between 0.0 (inclusive) and 1.0 (exclusive).</dd>
</dl>
</li>
</ul>
<a name="determine2-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determine2</h4>
<pre>public static&nbsp;double&nbsp;determine2(int&nbsp;index)</pre>
<div class="block">Convenience method to get a double from the van der Corput sequence with the base 2 at the requested
 <code>index</code> without needing to construct a VanDerCorputQRNG. This does not perform any scrambling on index
 other than incrementing it and ensuring it is positive (by discarding the sign bit; for all positive index values
 other than 0x7FFFFFFF (<code>Integer.MAX_VALUE</code>), this has no effect).
 <br>
 Because binary manipulation of numbers is easier and more efficient, the technique used by this method is also
 used by <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determine-int-int-"><code>determine(int, int)</code></a> when base is 2, and should be faster than other bases.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - the position in the base-2 van der Corput sequence, as a non-negative int</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a quasi-random double between 0.0 (inclusive) and 1.0 (exclusive).</dd>
</dl>
</li>
</ul>
<a name="determine2_scrambled-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determine2_scrambled</h4>
<pre>public static&nbsp;double&nbsp;determine2_scrambled(int&nbsp;index)</pre>
<div class="block">Method to get a double from the van der Corput sequence with the base 2 at a scrambling of the requested
 <code>index</code> without needing to construct a VanDerCorputQRNG. This performs different scrambling on index
 than the instance methods on this class perform, and it seems to do well enough while being a little simpler.
 This is meant to be usable as an alternative to a different base for a van der Corput sequence when you need two
 different sequences, and are already using base 2 via <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determine2-int-"><code>determine2(int)</code></a>.
 <br>
 Because binary manipulation of numbers is easier and more efficient, this method should be somewhat faster than
 the alternatives, like <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determine-int-int-"><code>determine(int, int)</code></a> with base 2. It should take only slightly longer to run than
 <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determine2-int-"><code>determine2(int)</code></a>, due to the brief amount of time needed to scramble the index.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - the position in the sequence of the requested base</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a quasi-random double between 0.0 (inclusive) and 1.0 (exclusive).</dd>
</dl>
</li>
</ul>
<a name="determineMixed-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determineMixed</h4>
<pre>public static&nbsp;double&nbsp;determineMixed(int&nbsp;index)</pre>
<div class="block">Chooses one sequence from the van der Corput sequences with bases 2, 3, and 5, where 5 is used 1/8 of the time,
 3 is used 3/8 of the time, and 2 is used 1/2 of the time, and returns a double from the chosen sequence at the
 specified <code>index</code>. The exact setup used for the choice this makes is potentially fragile, but in certain
 circumstances this does better than <a href="../../squidpony/squidmath/SobolQRNG.html" title="class in squidpony.squidmath"><code>SobolQRNG</code></a> at avoiding extremely close values (the kind that overlap
 on actual maps). Speed is not a concern here; this should be very much fast enough for the expected usage in
 map generation (it's used in <a href="../../squidpony/squidmath/GreasedRegion.html#quasiRandomSeparated-double-"><code>GreasedRegion.quasiRandomSeparated(double)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - the index to use from one of the sequences; will also be used to select sequence</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a double from 0.0 (inclusive, but extremely rare) to 1.0 (exclusive); values will tend to spread apart</dd>
</dl>
</li>
</ul>
<a name="weakDetermine-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weakDetermine</h4>
<pre>public static&nbsp;float&nbsp;weakDetermine(int&nbsp;index)</pre>
<div class="block">Given any int (0 is allowed), this gets a somewhat-sub-random float from 0.0 (inclusive) to 1.0 (exclusive)
 using the same implementation as <a href="../../squidpony/squidmath/NumberTools.html#randomFloat-long-"><code>NumberTools.randomFloat(long)</code></a> but with index alterations. Only "weak"
 because it lacks the stronger certainty of subsequent numbers being separated that the Van der Corput sequence
 has. Not actually sub-random, but should be distributed fairly well (internally uses <a href="../../squidpony/squidmath/ThrustAltRNG.html" title="class in squidpony.squidmath"><code>ThrustAltRNG</code></a>'s
 algorithm, which does not guarantee that its outputs are unique).
 <br>
 Not all int values for index will produce unique results, since this produces a float and there are less distinct
 floats between 0.0 and 1.0 than there are all ints (1/512 as many floats in that range as ints, specifically).
 It should take a while calling this method before you hit an actual collision.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - any int</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a float from 0.0 (inclusive) to 1.0 (exclusive) that should not be closely correlated to index</dd>
</dl>
</li>
</ul>
<a name="weakSignedDetermine-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weakSignedDetermine</h4>
<pre>public static&nbsp;float&nbsp;weakSignedDetermine(int&nbsp;index)</pre>
<div class="block">Like <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#weakDetermine-int-"><code>weakDetermine(int)</code></a>, but returns a float between -1.0f and 1.0f, exclusive on both. Uses
 <a href="../../squidpony/squidmath/NumberTools.html#randomSignedFloat-long-"><code>NumberTools.randomSignedFloat(long)</code></a> internally but alters the index parameter so calls with nearby values
 for index are less likely to have nearby results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - any int</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a sub-random float between -1.0f and 1.0f (both exclusive, unlike some other methods)</dd>
</dl>
</li>
</ul>
<a name="altDetermine-long-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>altDetermine</h4>
<pre>public static&nbsp;double&nbsp;altDetermine(long&nbsp;base,
                                  int&nbsp;index)</pre>
<div class="block">Similar to <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#determine-int-int-"><code>determine(int, int)</code></a>, but can take bases that aren't prime and can sometimes produce a
 Halton-like sequence with almost-as-good distance between points. The base is allowed to be any odd long, 
 (negative bases are allowed). The index can technically also be negative, and if this is given 0 it will not
 return any specific number (it will vary with the base). This returns a double between 0.0 inclusive and 1.0
 exclusive. Better results have been found with larger bases (points tend to be more spread out). It is never as
 good at spreading out 2D points as a 2,3 Halton sequence, at least for any bases tried so far.
 <br>
 Earlier versions of this method wound up only producing points on parallel lines in 2D, never placing points in
 between those lines. This sometimes formed a hex-like grid that, as hexagons do, has optimal packing properties,
 which made the optimal distance seem very good despite the points having a clear pattern. This can still
 sometimes be useful; when you want optimal distance and don't have a case where a clear pattern on a grid is an
 issue, it can have high performance. The code for the old way is small, though not simple:
 <code>((base * Integer.reverse(index) &lt;&lt; 21) &amp; 0x1fffffffffffffL) * 0x1p-53</code>, where base is an odd long and
 index is any int. It works best in one dimension.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - any odd long</dd>
<dd><code>index</code> - any int</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a double between 0.0 inclusive and 1.0 exclusive</dd>
</dl>
</li>
</ul>
<a name="planarDetermine-long-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>planarDetermine</h4>
<pre>public static&nbsp;double&nbsp;planarDetermine(long&nbsp;base,
                                     int&nbsp;index)</pre>
<div class="block">A quasi-random number generator of doubles between 0.0 inclusive and 1.0 exclusive, but that has issues when it
 would be used like a Halton sequence. Only ideal in 1D, this produces well-separated points that are aligned to
 parallel hyperplanes when called with different bases and each base used as an axis for more than 1 dimension.
 This can produce points with more separation in 2D than a Halton sequence can, but not often. Two bases that do
 this when used together are the ints 0xDE4DBEEF and 0x1337D00D (or in decimal, -565330193 and 322424845; note
 that 0xDE4DBEEF is a negative integer); they were tried as a gimmick but nothing else turned out better. They do
 still produce points on parallel lines, and like all bases, never points between those lines.
 <br>
 Note, the source of this method is one line, and you may see benefits from copying that code into the call-site
 with minor modifications. This returns
 <code>(((base * Integer.reverse(index)) &lt;&lt; 21) &amp; 0x1fffffffffffffL) * 0x1p-53;</code>, where base is a long and index
 is an int (as in the method signature). The multiplier 0x1p-53 is a very small hexadecimal double literal, using
 the same syntax as other parts of SquidLib use for packed floats; using this helps avoid precision loss. If you
 want a range larger than 0.0 to 1.0, you can change the multiplier <code>0x1p-53</code> to some other constant, like
 declaring <code>final double upTo100 = 0x1p-53 * 100.0</code> before some code that wants quasi-random numbers between
 0.0 inclusive and 100.0 exclusive, then using
 <code>(((base * Integer.reverse(index)) &lt;&lt; 21) &amp; 0x1fffffffffffffL) * upTo100;</code> to get those numbers. It isn't
 precise to use this technique to get numbers with an upper bound less than 1.0, because 0x1p-53 is about as small
 as a double can get with precision intact. In that case, you can use
 <code>(((base * Integer.reverse(index)) &lt;&lt; 8) &amp; 0xffffffffffL) * smallBound;</code> where smallBound has been declared
 as <code>final double smallBound = 0x1p-40 * 0.05;</code> (where 0.05 can be switched out for any double between
 1.0/8192.0 and 1.0).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - any odd long; the most significant 21 bits (except the sign bit) are effectively ignored</dd>
<dd><code>index</code> - any int; if 0 this will return 0</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a double between 0.0 inclusive and 1.0 exclusive</dd>
</dl>
</li>
</ul>
<a name="haltoid-int-int-int-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>haltoid</h4>
<pre>public static&nbsp;<a href="../../squidpony/squidmath/Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;haltoid(int&nbsp;seed,
                            int&nbsp;width,
                            int&nbsp;height,
                            int&nbsp;xOffset,
                            int&nbsp;yOffset,
                            int&nbsp;index)</pre>
<div class="block">Samples a quasi-random Coord sequence that is almost unique to the given seed, getting a Coord with x between
 xOffset (inclusive) and width + xOffset (exclusive), y between yOffset (inclusive) and height + yOffset
 (exclusive). The seed is "almost" unique because even seeds are discouraged; there is an identical sequence for
 every even seed produced by some odd seed. This generates a not-very random number, reverses its bits as other
 methods in this class do, then treats that single 32-bit int as two coordinates on a Z-order curve to get
 separate x and y from them. In practice these Coords are very well-dispersed if only a small amount are sampled
 and all the index values are close-by, and get closer together as more are sampled. Unlike the Halton sequence,
 this has very different results with different seeds (Halton only allows bases to be changed), and doesn't
 involve any division, modulus, conditionals, or loops.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>seed</code> - an int seed that should be an odd number</dd>
<dd><code>width</code> - the width of the area this can cover</dd>
<dd><code>height</code> - the height of the area this can cover</dd>
<dd><code>xOffset</code> - the lowest x-coordinate this can produce, and also added to width to get the upper bound on x</dd>
<dd><code>yOffset</code> - the lowest y-coordinate this can produce, and also added to height to get the upper bound on y</dd>
<dd><code>index</code> - the index in the sequence, almost always a positive int that increases by 1 with each call</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord between (xOffset, yOffset) inclusive and (width+xOffset, height+yOffset) exclusive</dd>
</dl>
</li>
</ul>
<a name="roberts-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>roberts</h4>
<pre>public static&nbsp;int&nbsp;roberts(int&nbsp;span,
                          int&nbsp;offset,
                          int&nbsp;index)</pre>
<div class="block">Martin Roberts' "unreasonably effective" quasi-random int sequence based on the golden ratio.
 See <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">his blog</a> for
 more detailed info, but this can be summarized as being excellent at separating outputs at the expense of
 seeming less random. Produces an int between offset (inclusive) and offset + span (exclusive), with the int at
 each <code>index</code> likely to be different for at least <code>span / 4</code> indices (very low spans may offer less of
 a guarantee).
 <br>
 Note, use <a href="../../squidpony/squidmath/VanDerCorputQRNG.html#roberts-int-int-int-int-int-"><code>roberts(int, int, int, int, int)</code></a> for 2D points and this method for 1D values; the same
 properties won't be preserved if you use a 1D Roberts sequence in 2D.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>span</code> - the size of the range this can return</dd>
<dd><code>offset</code> - the minimum value this can return</dd>
<dd><code>index</code> - the index of the int in the 1D Roberts sequence; should be greater than 0, but not required to be</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an int between offset inclusive and offset+span exclusive</dd>
</dl>
</li>
</ul>
<a name="roberts-int-int-int-int-int-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>roberts</h4>
<pre>public static&nbsp;<a href="../../squidpony/squidmath/Coord.html" title="class in squidpony.squidmath">Coord</a>&nbsp;roberts(int&nbsp;width,
                            int&nbsp;height,
                            int&nbsp;xOffset,
                            int&nbsp;yOffset,
                            int&nbsp;index)</pre>
<div class="block">Martin Roberts' "unreasonably effective" quasi-random point sequence based on a 2D analogue to the golden ratio.
 See <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">his blog</a> for
 more detailed info, but this can be summarized as being excellent at separating points at the expense of
 seeming less random. Produces a Coord with x between xOffset (inclusive) and xOffset + width (exclusive), and y
 between yOffset (inclusive) and yOffset + height (exclusive), with the Coord at each <code>index</code> likely to be
 different for at least <code>width * height / 4</code> indices (very low sizes may offer less of a guarantee).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>width</code> - the x-size of the space this can place a Coord</dd>
<dd><code>height</code> - the y-size of the space this can place a Coord</dd>
<dd><code>xOffset</code> - the minimum x-position of a Coord</dd>
<dd><code>yOffset</code> - the minimum y-position of a Coord</dd>
<dd><code>index</code> - the index of the Coord in the 2D Roberts sequence; should be greater than 0, but not required to be</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Coord with x,y between xOffset,yOffset inclusive and xOffset+width,yOffset+height exclusive</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/VanDerCorputQRNG.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../squidpony/squidmath/ValueNoise.html" title="class in squidpony.squidmath"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../squidpony/squidmath/VastNoise.html" title="class in squidpony.squidmath"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?squidpony/squidmath/VanDerCorputQRNG.html" target="_top">Frames</a></li>
<li><a href="VanDerCorputQRNG.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; Eben Howard 2012&#x2013;2022. All rights reserved.</small></p>
</body>
</html>
