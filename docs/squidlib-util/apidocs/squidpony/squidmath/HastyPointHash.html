<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>HastyPointHash (squidlib-util 3.0.5-SNAPSHOT API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: squidpony.squidmath, class: HastyPointHash">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/HastyPointHash.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">squidpony.squidmath</a></div>
<h1 title="Class HastyPointHash" class="title">Class HastyPointHash</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance"><a href="IPointHash.LongImpl.html" title="class in squidpony.squidmath">squidpony.squidmath.IPointHash.LongImpl</a>
<div class="inheritance">squidpony.squidmath.HastyPointHash</div>
</div>
</div>
<section class="description">
<dl class="notes">
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="IPointHash.html" title="interface in squidpony.squidmath">IPointHash</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">HastyPointHash</span>
<span class="extends-implements">extends <a href="IPointHash.LongImpl.html" title="class in squidpony.squidmath">IPointHash.LongImpl</a></span></div>
<div class="block">A group of similar methods for getting hashes of points based on long coordinates in 2, 3, 4, or 6 dimensions and
 a long for state; like <a href="PointHash.html" title="class in squidpony.squidmath"><code>PointHash</code></a> but faster and maybe not as high-quality. This implementation has
 high enough quality to be useful as a source of random numbers based on positions, but would likely not be a good
 option in a hash table (or at least not as good as the tailored implementation of <a href="Coord.html#hashCode()"><code>Coord.hashCode()</code></a>, for
 instance). At low dimensions, this is a little faster than <a href="PointHash.html" title="class in squidpony.squidmath"><code>PointHash</code></a>, but this class doesn't slow 
 down much at all as more dimensions are used, while PointHash and most other implementations do slow down. You
 can also consider <a href="IntPointHash.html" title="class in squidpony.squidmath"><code>IntPointHash</code></a> if your input and output types are usually int, since it's even faster.
 <br>
 This implements <a href="IPointHash.html" title="interface in squidpony.squidmath"><code>IPointHash</code></a> and has a long it uses internally for state, exposed by <a href="#getState()"><code>getState()</code></a>.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested.class.summary">
<h2>Nested Class Summary</h2>
<div class="inherited-list">
<h2 id="nested.classes.inherited.from.class.squidpony.squidmath.IPointHash">Nested classes/interfaces inherited from interface&nbsp;squidpony.squidmath.<a href="IPointHash.html" title="interface in squidpony.squidmath">IPointHash</a></h2>
<code><a href="IPointHash.IntImpl.html" title="class in squidpony.squidmath">IPointHash.IntImpl</a>, <a href="IPointHash.LongImpl.html" title="class in squidpony.squidmath">IPointHash.LongImpl</a></code></div>
</section>
</li>
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static <a href="HastyPointHash.html" title="class in squidpony.squidmath">HastyPointHash</a></code></div>
<div class="col-second even-row-color"><code><span class="member-name-link"><a href="#INSTANCE">INSTANCE</a></span></code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
<div class="inherited-list">
<h3 id="fields.inherited.from.class.squidpony.squidmath.IPointHash.LongImpl">Fields inherited from class&nbsp;squidpony.squidmath.<a href="IPointHash.LongImpl.html" title="class in squidpony.squidmath">IPointHash.LongImpl</a></h3>
<code><a href="IPointHash.LongImpl.html#state">state</a></code></div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><span class="member-name-link"><a href="#%3Cinit%3E()">HastyPointHash</a></span>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-constructor-name odd-row-color"><code><span class="member-name-link"><a href="#%3Cinit%3E(int)">HastyPointHash</a></span>&#8203;(int&nbsp;state)</code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-constructor-name even-row-color"><code><span class="member-name-link"><a href="#%3Cinit%3E(long)">HastyPointHash</a></span>&#8203;(long&nbsp;state)</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code>long</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#getState()">getState</a></span>()</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash256(long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets an 8-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash256(long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets an 8-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash256(long,long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets an 8-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash256(long,long,long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets an 8-bit point hash of a 5D point (x, y, z, w, and u are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash256(long,long,long,long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;v,
 long&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets an 8-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash256_alt(long,long,long,long,long)">hash256_alt</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;seed)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash32(long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 5-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash32(long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 5-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash32(long,long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 5-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash32(long,long,long,long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;v,
 long&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 5-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash64(long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 6-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash64(long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 6-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash64(long,long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 6-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hash64(long,long,long,long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;v,
 long&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 6-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hashAll(long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 64-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hashAll(long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 64-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hashAll(long,long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 64-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hashAll(long,long,long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 64-bit point hash of a 5D point (x, y, z, w, and u are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hashAll(long,long,long,long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;v,
 long&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Gets a 64-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code>int</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hashWithState(int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
 int&nbsp;y,
 int&nbsp;state)</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hashWithState(int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
 int&nbsp;y,
 int&nbsp;z,
 int&nbsp;state)</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table">&nbsp;</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code>int</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hashWithState(int,int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
 int&nbsp;y,
 int&nbsp;z,
 int&nbsp;w,
 int&nbsp;state)</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hashWithState(int,int,int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
 int&nbsp;y,
 int&nbsp;z,
 int&nbsp;w,
 int&nbsp;u,
 int&nbsp;state)</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table">&nbsp;</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code>int</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#hashWithState(int,int,int,int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
 int&nbsp;y,
 int&nbsp;z,
 int&nbsp;w,
 int&nbsp;u,
 int&nbsp;v,
 int&nbsp;state)</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table-tab4 method-summary-table">&nbsp;</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.squidpony.squidmath.IPointHash.LongImpl">Methods inherited from class&nbsp;squidpony.squidmath.<a href="IPointHash.LongImpl.html" title="class in squidpony.squidmath">IPointHash.LongImpl</a></h3>
<code><a href="IPointHash.LongImpl.html#hash(int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int,int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#setState(int)">setState</a>, <a href="IPointHash.LongImpl.html#setState(long)">setState</a></code></div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="INSTANCE">
<h3>INSTANCE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="HastyPointHash.html" title="class in squidpony.squidmath">HastyPointHash</a></span>&nbsp;<span class="element-name">INSTANCE</span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>HastyPointHash</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">HastyPointHash</span>()</div>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(int)">
<h3>HastyPointHash</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">HastyPointHash</span>&#8203;<span class="parameters">(int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(long)">
<h3>HastyPointHash</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">HastyPointHash</span>&#8203;<span class="parameters">(long&nbsp;state)</span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="hashWithState(int,int,int)">
<h3>hashWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hashWithState</span>&#8203;<span class="parameters">(int&nbsp;x,
 int&nbsp;y,
 int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="hashWithState(int,int,int,int)">
<h3>hashWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hashWithState</span>&#8203;<span class="parameters">(int&nbsp;x,
 int&nbsp;y,
 int&nbsp;z,
 int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="hashWithState(int,int,int,int,int)">
<h3>hashWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hashWithState</span>&#8203;<span class="parameters">(int&nbsp;x,
 int&nbsp;y,
 int&nbsp;z,
 int&nbsp;w,
 int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="hashWithState(int,int,int,int,int,int)">
<h3>hashWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hashWithState</span>&#8203;<span class="parameters">(int&nbsp;x,
 int&nbsp;y,
 int&nbsp;z,
 int&nbsp;w,
 int&nbsp;u,
 int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="hashWithState(int,int,int,int,int,int,int)">
<h3>hashWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hashWithState</span>&#8203;<span class="parameters">(int&nbsp;x,
 int&nbsp;y,
 int&nbsp;z,
 int&nbsp;w,
 int&nbsp;u,
 int&nbsp;v,
 int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="getState()">
<h3>getState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">getState</span>()</div>
</section>
</li>
<li>
<section class="detail" id="hashAll(long,long,long)">
<h3>hashAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">hashAll</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>64-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hashAll(long,long,long,long)">
<h3>hashAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">hashAll</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>64-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hashAll(long,long,long,long,long)">
<h3>hashAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">hashAll</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>64-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hashAll(long,long,long,long,long,long)">
<h3>hashAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">hashAll</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 5D point (x, y, z, w, and u are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>64-bit hash of the x,y,z,w,u point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hashAll(long,long,long,long,long,long,long)">
<h3>hashAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">hashAll</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;v,
 long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>64-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256(long,long,long)">
<h3>hash256</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash256</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>8-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256(long,long,long,long)">
<h3>hash256</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash256</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>8-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256(long,long,long,long,long)">
<h3>hash256</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash256</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>8-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256(long,long,long,long,long,long)">
<h3>hash256</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash256</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 5D point (x, y, z, w, and u are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>8-bit hash of the x,y,z,w,u point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256(long,long,long,long,long,long,long)">
<h3>hash256</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash256</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;v,
 long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>8-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash32(long,long,long)">
<h3>hash32</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash32</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>5-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash32(long,long,long,long)">
<h3>hash32</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash32</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>5-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash32(long,long,long,long,long)">
<h3>hash32</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash32</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>5-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash32(long,long,long,long,long,long,long)">
<h3>hash32</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash32</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;v,
 long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>5-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash64(long,long,long)">
<h3>hash64</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash64</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>6-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash64(long,long,long,long)">
<h3>hash64</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash64</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>6-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash64(long,long,long,long,long)">
<h3>hash64</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash64</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>6-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash64(long,long,long,long,long,long,long)">
<h3>hash64</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash64</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;u,
 long&nbsp;v,
 long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>6-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256_alt(long,long,long,long,long)">
<h3>hash256_alt</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hash256_alt</span>&#8203;<span class="parameters">(long&nbsp;x,
 long&nbsp;y,
 long&nbsp;z,
 long&nbsp;w,
 long&nbsp;seed)</span></div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small>Copyright &#169; Eben Howard 2012&#x2013;2021. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
