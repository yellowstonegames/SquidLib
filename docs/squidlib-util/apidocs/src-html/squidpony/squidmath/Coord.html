<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Source code</title>
<meta name="description" content="source: package: squidpony.squidmath, class: Coord">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source">
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">package squidpony.squidmath;</a>
<span class="sourceLineNo">002</span><a id="line.2"></a>
<span class="sourceLineNo">003</span><a id="line.3">import squidpony.squidgrid.Direction;</a>
<span class="sourceLineNo">004</span><a id="line.4"></a>
<span class="sourceLineNo">005</span><a id="line.5">import java.io.Serializable;</a>
<span class="sourceLineNo">006</span><a id="line.6"></a>
<span class="sourceLineNo">007</span><a id="line.7">/**</a>
<span class="sourceLineNo">008</span><a id="line.8"> * A 2D coordinate with (constant) x and y fields. Coord objects are immutable; a single pool of Coord values, with</a>
<span class="sourceLineNo">009</span><a id="line.9"> * x and y each ranging from -3 to 255, is shared by all users of Coord. This pool helps reduce pressure on the</a>
<span class="sourceLineNo">010</span><a id="line.10"> * garbage collector when many Coord values would have been created for some purpose and quickly discarded; instead</a>
<span class="sourceLineNo">011</span><a id="line.11"> * of creating a new Coord with a constructor, you use the static method {@link #get(int, int)}, which retrieves an</a>
<span class="sourceLineNo">012</span><a id="line.12"> * already-existing Coord from the pool if possible, and always returns a usable Coord.</a>
<span class="sourceLineNo">013</span><a id="line.13"> * &lt;br&gt;</a>
<span class="sourceLineNo">014</span><a id="line.14"> * The Coord class is a fundamental part of SquidLib; any class that uses positions on a grid makes use of it here.</a>
<span class="sourceLineNo">015</span><a id="line.15"> * It finds usage naturally in classes throughout {@link squidpony.squidgrid}, with {@link squidpony.squidgrid.zone}</a>
<span class="sourceLineNo">016</span><a id="line.16"> * providing an abstraction around groups of Coord and {@link squidpony.squidgrid.iterator} providing various ways to</a>
<span class="sourceLineNo">017</span><a id="line.17"> * iterate through the Coords that make up a larger shape. In this package, {@link squidpony.squidmath}, a few classes</a>
<span class="sourceLineNo">018</span><a id="line.18"> * should be pointed out. {@link CoordPacker} is a class with all static methods that provides various ways to compress</a>
<span class="sourceLineNo">019</span><a id="line.19"> * the memory usage of regions made of many Coord values (and can be constructed in other ways but still provide Coords</a>
<span class="sourceLineNo">020</span><a id="line.20"> * later), but since Coords don't use much memory anyway, the real use of the class is for manipulating the shapes and</a>
<span class="sourceLineNo">021</span><a id="line.21"> * sizes of the regions those Coords are part of. {@link GreasedRegion} has similar functionality to CoordPacker, but</a>
<span class="sourceLineNo">022</span><a id="line.22"> * where CoordPacker is purely static, taking and returning regions as encoded, usually-low-memory-cost arrays of</a>
<span class="sourceLineNo">023</span><a id="line.23"> * {@code short} that it considers immutable, a GreasedRegion is a mutable object that allows the same region-altering</a>
<span class="sourceLineNo">024</span><a id="line.24"> * techniques to be applied in-place in a way that is relatively (very) low-time-cost. If deciding between the two,</a>
<span class="sourceLineNo">025</span><a id="line.25"> * GreasedRegion should usually be preferred, and CoordPacker cannot actually be used when storing regions in larger</a>
<span class="sourceLineNo">026</span><a id="line.26"> * than a 256x256 space (usually when the Coord pool has been expanded; see below); GreasedRegion can store potentially</a>
<span class="sourceLineNo">027</span><a id="line.27"> * large positions.</a>
<span class="sourceLineNo">028</span><a id="line.28"> * &lt;br&gt;</a>
<span class="sourceLineNo">029</span><a id="line.29"> * More on the Coord pool used by this class:  Coords can't always be retrieved from the pool; Coord.get constructs a</a>
<span class="sourceLineNo">030</span><a id="line.30"> * new Coord if one of x or y is unusually large (greater than 255) or too negative (below -3). The upper limit of 255</a>
<span class="sourceLineNo">031</span><a id="line.31"> * is not a hard rule; you can increase the limit on the pool by calling {@link #expandPoolTo(int, int)} or</a>
<span class="sourceLineNo">032</span><a id="line.32"> * {@link #expandPool(int, int)}, which cause more memory to be spent initially on storing Coords but can save memory</a>
<span class="sourceLineNo">033</span><a id="line.33"> * or ease GC pressure over the long term by preventing duplicate Coords from being created many times. The pool can</a>
<span class="sourceLineNo">034</span><a id="line.34"> * never shrink because allowing that would cause completely unpredictable results if existing Coords were in use, or</a>
<span class="sourceLineNo">035</span><a id="line.35"> * could easily cause crashes on Android after resuming an application that had previously shrunken the pool due to</a>
<span class="sourceLineNo">036</span><a id="line.36"> * platform quirks. Long story short, you should only expand the pool size when your game needs a larger set of 2D</a>
<span class="sourceLineNo">037</span><a id="line.37"> * points it will commonly use, and in most cases you shouldn't need to change it at all.</a>
<span class="sourceLineNo">038</span><a id="line.38"> * </a>
<span class="sourceLineNo">039</span><a id="line.39"> * Created by Tommy Ettinger on 8/12/2015.</a>
<span class="sourceLineNo">040</span><a id="line.40"> */</a>
<span class="sourceLineNo">041</span><a id="line.41">public class Coord implements Serializable {</a>
<span class="sourceLineNo">042</span><a id="line.42">    private static final long serialVersionUID = 300L;</a>
<span class="sourceLineNo">043</span><a id="line.43"></a>
<span class="sourceLineNo">044</span><a id="line.44">        /** The x-coordinate. */</a>
<span class="sourceLineNo">045</span><a id="line.45">        public final int x;</a>
<span class="sourceLineNo">046</span><a id="line.46"></a>
<span class="sourceLineNo">047</span><a id="line.47">        /** The y-coordinate (the ordinate) */</a>
<span class="sourceLineNo">048</span><a id="line.48">        public final int y;</a>
<span class="sourceLineNo">049</span><a id="line.49"></a>
<span class="sourceLineNo">050</span><a id="line.50">    protected Coord()</a>
<span class="sourceLineNo">051</span><a id="line.51">    {</a>
<span class="sourceLineNo">052</span><a id="line.52">        this(0, 0);</a>
<span class="sourceLineNo">053</span><a id="line.53">    }</a>
<span class="sourceLineNo">054</span><a id="line.54">    protected Coord(final int x, final int y)</a>
<span class="sourceLineNo">055</span><a id="line.55">    {</a>
<span class="sourceLineNo">056</span><a id="line.56">        this.x = x;</a>
<span class="sourceLineNo">057</span><a id="line.57">        this.y = y;</a>
<span class="sourceLineNo">058</span><a id="line.58">    }</a>
<span class="sourceLineNo">059</span><a id="line.59">    public static Coord get(final int x, final int y)</a>
<span class="sourceLineNo">060</span><a id="line.60">    {</a>
<span class="sourceLineNo">061</span><a id="line.61">        if(x &gt;= -3 &amp;&amp; y &gt;= -3 &amp;&amp; x &lt; POOL.length - 3 &amp;&amp; y &lt; POOL[x + 3].length - 3)</a>
<span class="sourceLineNo">062</span><a id="line.62">            return POOL[x + 3][y + 3];</a>
<span class="sourceLineNo">063</span><a id="line.63">        else return new Coord(x, y);</a>
<span class="sourceLineNo">064</span><a id="line.64">    }</a>
<span class="sourceLineNo">065</span><a id="line.65"></a>
<span class="sourceLineNo">066</span><a id="line.66">        /**</a>
<span class="sourceLineNo">067</span><a id="line.67">     * Gets the angle in degrees to go between two Coords; 0 is up.</a>
<span class="sourceLineNo">068</span><a id="line.68">         * @param from the starting Coord to measure from</a>
<span class="sourceLineNo">069</span><a id="line.69">         * @param to the ending Coord to measure to</a>
<span class="sourceLineNo">070</span><a id="line.70">         * @return The degree from {@code from} to {@code to}; 0 is up</a>
<span class="sourceLineNo">071</span><a id="line.71">         */</a>
<span class="sourceLineNo">072</span><a id="line.72">        public static double degrees(final Coord from, final Coord to) {</a>
<span class="sourceLineNo">073</span><a id="line.73">                final int x = to.x - from.x;</a>
<span class="sourceLineNo">074</span><a id="line.74">                final int y = to.y - from.y;</a>
<span class="sourceLineNo">075</span><a id="line.75">                double degree = Math.toDegrees(NumberTools.atan2(y, x));</a>
<span class="sourceLineNo">076</span><a id="line.76">                degree += 450;// rotate to all positive and 0 is up</a>
<span class="sourceLineNo">077</span><a id="line.77">                degree %= 360;// normalize</a>
<span class="sourceLineNo">078</span><a id="line.78">                return degree;</a>
<span class="sourceLineNo">079</span><a id="line.79">        }</a>
<span class="sourceLineNo">080</span><a id="line.80"></a>
<span class="sourceLineNo">081</span><a id="line.81">    /**</a>
<span class="sourceLineNo">082</span><a id="line.82">     * Provided for compatibility with earlier code that used the AWT Point API.</a>
<span class="sourceLineNo">083</span><a id="line.83">     * @return this Coord, without changes</a>
<span class="sourceLineNo">084</span><a id="line.84">     */</a>
<span class="sourceLineNo">085</span><a id="line.85">    public Coord getLocation()</a>
<span class="sourceLineNo">086</span><a id="line.86">    {</a>
<span class="sourceLineNo">087</span><a id="line.87">        return this;</a>
<span class="sourceLineNo">088</span><a id="line.88">    }</a>
<span class="sourceLineNo">089</span><a id="line.89"></a>
<span class="sourceLineNo">090</span><a id="line.90">    /**</a>
<span class="sourceLineNo">091</span><a id="line.91">     * Takes this Coord, adds x to its x and y to its y, and returns the Coord at that position.</a>
<span class="sourceLineNo">092</span><a id="line.92">     * @param x the amount of x distance to move</a>
<span class="sourceLineNo">093</span><a id="line.93">     * @param y the amount of y distance to move</a>
<span class="sourceLineNo">094</span><a id="line.94">     * @return a Coord (usually cached and not a new instance) that has been moved the specified distance</a>
<span class="sourceLineNo">095</span><a id="line.95">     */</a>
<span class="sourceLineNo">096</span><a id="line.96">    public Coord translate(final int x, final int y)</a>
<span class="sourceLineNo">097</span><a id="line.97">    {</a>
<span class="sourceLineNo">098</span><a id="line.98">        return get(this.x + x, this.y + y);</a>
<span class="sourceLineNo">099</span><a id="line.99">    }</a>
<span class="sourceLineNo">100</span><a id="line.100">    /**</a>
<span class="sourceLineNo">101</span><a id="line.101">     * Takes this Coord, adds x to its x and y to its y, limiting x from 0 to width and limiting y from 0 to height,</a>
<span class="sourceLineNo">102</span><a id="line.102">     * and returns the Coord at that position.</a>
<span class="sourceLineNo">103</span><a id="line.103">     * @param x the amount of x distance to move</a>
<span class="sourceLineNo">104</span><a id="line.104">     * @param y the amount of y distance to move</a>
<span class="sourceLineNo">105</span><a id="line.105">     * @param width one higher than the maximum x value this can use; typically the length of an array</a>
<span class="sourceLineNo">106</span><a id="line.106">     * @param height one higher than the maximum y value this can use; typically the length of an array</a>
<span class="sourceLineNo">107</span><a id="line.107">     * @return a Coord (usually cached and not a new instance) that has been moved the specified distance</a>
<span class="sourceLineNo">108</span><a id="line.108">     */</a>
<span class="sourceLineNo">109</span><a id="line.109">    public Coord translateCapped(final int x, final int y, final int width, final int height)</a>
<span class="sourceLineNo">110</span><a id="line.110">    {</a>
<span class="sourceLineNo">111</span><a id="line.111">        return get(Math.min(Math.max(0, this.x + x), width - 1), Math.min(Math.max(0, this.y + y), height - 1));</a>
<span class="sourceLineNo">112</span><a id="line.112">    }</a>
<span class="sourceLineNo">113</span><a id="line.113"></a>
<span class="sourceLineNo">114</span><a id="line.114">    /**</a>
<span class="sourceLineNo">115</span><a id="line.115">     * Separately combines the x and y positions of this Coord and other, producing a different Coord as their "sum."</a>
<span class="sourceLineNo">116</span><a id="line.116">     * @param other another Coord</a>
<span class="sourceLineNo">117</span><a id="line.117">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x + other.x; y = this.y + other.y}</a>
<span class="sourceLineNo">118</span><a id="line.118">     */</a>
<span class="sourceLineNo">119</span><a id="line.119">    public Coord add(final Coord other)</a>
<span class="sourceLineNo">120</span><a id="line.120">    {</a>
<span class="sourceLineNo">121</span><a id="line.121">        return get(x + other.x, y + other.y);</a>
<span class="sourceLineNo">122</span><a id="line.122">    }</a>
<span class="sourceLineNo">123</span><a id="line.123"></a>
<span class="sourceLineNo">124</span><a id="line.124">    /**</a>
<span class="sourceLineNo">125</span><a id="line.125">     * Separately adds the x and y positions of this Coord to operand, producing a different Coord as their</a>
<span class="sourceLineNo">126</span><a id="line.126">     * "sum."</a>
<span class="sourceLineNo">127</span><a id="line.127">     * @param operand a value to add each of x and y to</a>
<span class="sourceLineNo">128</span><a id="line.128">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x + operand; y = this.y + operand}</a>
<span class="sourceLineNo">129</span><a id="line.129">     */</a>
<span class="sourceLineNo">130</span><a id="line.130">    public Coord add(final int operand)</a>
<span class="sourceLineNo">131</span><a id="line.131">    {</a>
<span class="sourceLineNo">132</span><a id="line.132">        return get(x + operand, y + operand);</a>
<span class="sourceLineNo">133</span><a id="line.133">    }</a>
<span class="sourceLineNo">134</span><a id="line.134"></a>
<span class="sourceLineNo">135</span><a id="line.135">    /**</a>
<span class="sourceLineNo">136</span><a id="line.136">     * Separately adds the x and y positions of this Coord to operand, rounding to the nearest int for each of x</a>
<span class="sourceLineNo">137</span><a id="line.137">     * and y and producing a different Coord as their "sum."</a>
<span class="sourceLineNo">138</span><a id="line.138">     * @param operand a value to add each of x and y to</a>
<span class="sourceLineNo">139</span><a id="line.139">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x + operand; y = this.y +</a>
<span class="sourceLineNo">140</span><a id="line.140">     *          operand}, with both x and y rounded accordingly</a>
<span class="sourceLineNo">141</span><a id="line.141">     */</a>
<span class="sourceLineNo">142</span><a id="line.142">    public Coord add(final double operand)</a>
<span class="sourceLineNo">143</span><a id="line.143">    {</a>
<span class="sourceLineNo">144</span><a id="line.144">        return get((int)Math.round(x + operand), (int)Math.round(y + operand));</a>
<span class="sourceLineNo">145</span><a id="line.145">    }</a>
<span class="sourceLineNo">146</span><a id="line.146"></a>
<span class="sourceLineNo">147</span><a id="line.147">    /**</a>
<span class="sourceLineNo">148</span><a id="line.148">     * Separately subtracts the x and y positions of other from this Coord, producing a different Coord as their</a>
<span class="sourceLineNo">149</span><a id="line.149">     * "difference."</a>
<span class="sourceLineNo">150</span><a id="line.150">     * @param other another Coord</a>
<span class="sourceLineNo">151</span><a id="line.151">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x - other.x; y = this.y - other.y}</a>
<span class="sourceLineNo">152</span><a id="line.152">     */</a>
<span class="sourceLineNo">153</span><a id="line.153">    public Coord subtract(final Coord other)</a>
<span class="sourceLineNo">154</span><a id="line.154">    {</a>
<span class="sourceLineNo">155</span><a id="line.155">        return get(x - other.x, y - other.y);</a>
<span class="sourceLineNo">156</span><a id="line.156">    }</a>
<span class="sourceLineNo">157</span><a id="line.157"></a>
<span class="sourceLineNo">158</span><a id="line.158">    /**</a>
<span class="sourceLineNo">159</span><a id="line.159">     * Separately subtracts operand from the x and y positions of this Coord, producing a different Coord as their</a>
<span class="sourceLineNo">160</span><a id="line.160">     * "difference."</a>
<span class="sourceLineNo">161</span><a id="line.161">     * @param operand a value to subtract from each of x and y</a>
<span class="sourceLineNo">162</span><a id="line.162">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x - operand; y = this.y - operand}</a>
<span class="sourceLineNo">163</span><a id="line.163">     */</a>
<span class="sourceLineNo">164</span><a id="line.164">    public Coord subtract(final int operand)</a>
<span class="sourceLineNo">165</span><a id="line.165">    {</a>
<span class="sourceLineNo">166</span><a id="line.166">        return get(x - operand, y - operand);</a>
<span class="sourceLineNo">167</span><a id="line.167">    }</a>
<span class="sourceLineNo">168</span><a id="line.168"></a>
<span class="sourceLineNo">169</span><a id="line.169">    /**</a>
<span class="sourceLineNo">170</span><a id="line.170">     * Separately subtracts operand from the x and y positions of this Coord, rounding to the nearest int for each of x</a>
<span class="sourceLineNo">171</span><a id="line.171">     * and y and producing a different Coord as their "difference."</a>
<span class="sourceLineNo">172</span><a id="line.172">     * @param operand a value to subtract from each of x and y</a>
<span class="sourceLineNo">173</span><a id="line.173">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x - operand; y = this.y -</a>
<span class="sourceLineNo">174</span><a id="line.174">     *          operand}, with both x and y rounded accordingly</a>
<span class="sourceLineNo">175</span><a id="line.175">     */</a>
<span class="sourceLineNo">176</span><a id="line.176">    public Coord subtract(final double operand)</a>
<span class="sourceLineNo">177</span><a id="line.177">    {</a>
<span class="sourceLineNo">178</span><a id="line.178">        return get((int)Math.round(x - operand), (int)Math.round(y - operand));</a>
<span class="sourceLineNo">179</span><a id="line.179">    }</a>
<span class="sourceLineNo">180</span><a id="line.180">    /**</a>
<span class="sourceLineNo">181</span><a id="line.181">     * Separately multiplies the x and y positions of other from this Coord, producing a different Coord as their</a>
<span class="sourceLineNo">182</span><a id="line.182">     * "product."</a>
<span class="sourceLineNo">183</span><a id="line.183">     * @param other another Coord</a>
<span class="sourceLineNo">184</span><a id="line.184">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x * other.x; y = this.y * other.y}</a>
<span class="sourceLineNo">185</span><a id="line.185">     */</a>
<span class="sourceLineNo">186</span><a id="line.186">    public Coord multiply(final Coord other)</a>
<span class="sourceLineNo">187</span><a id="line.187">    {</a>
<span class="sourceLineNo">188</span><a id="line.188">        return get(x * other.x, y * other.y);</a>
<span class="sourceLineNo">189</span><a id="line.189">    }</a>
<span class="sourceLineNo">190</span><a id="line.190">    /**</a>
<span class="sourceLineNo">191</span><a id="line.191">     * Separately multiplies the x and y positions of this Coord by operand, producing a different Coord as their</a>
<span class="sourceLineNo">192</span><a id="line.192">     * "product."</a>
<span class="sourceLineNo">193</span><a id="line.193">     * @param operand a value to multiply each of x and y by</a>
<span class="sourceLineNo">194</span><a id="line.194">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x * operand; y = this.y * operand}</a>
<span class="sourceLineNo">195</span><a id="line.195">     */</a>
<span class="sourceLineNo">196</span><a id="line.196">    public Coord multiply(final int operand)</a>
<span class="sourceLineNo">197</span><a id="line.197">    {</a>
<span class="sourceLineNo">198</span><a id="line.198">        return get(x * operand, y * operand);</a>
<span class="sourceLineNo">199</span><a id="line.199">    }</a>
<span class="sourceLineNo">200</span><a id="line.200"></a>
<span class="sourceLineNo">201</span><a id="line.201">    /**</a>
<span class="sourceLineNo">202</span><a id="line.202">     * Separately multiplies the x and y positions of this Coord by operand, rounding to the nearest int for each of x</a>
<span class="sourceLineNo">203</span><a id="line.203">     * and y and producing a different Coord as their "product."</a>
<span class="sourceLineNo">204</span><a id="line.204">     * @param operand a value to multiply each of x and y by</a>
<span class="sourceLineNo">205</span><a id="line.205">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x * operand; y = this.y *</a>
<span class="sourceLineNo">206</span><a id="line.206">     *          operand}, with both x and y rounded accordingly</a>
<span class="sourceLineNo">207</span><a id="line.207">     */</a>
<span class="sourceLineNo">208</span><a id="line.208">    public Coord multiply(final double operand)</a>
<span class="sourceLineNo">209</span><a id="line.209">    {</a>
<span class="sourceLineNo">210</span><a id="line.210">        return get((int)Math.round(x * operand), (int)Math.round(y * operand));</a>
<span class="sourceLineNo">211</span><a id="line.211">    }</a>
<span class="sourceLineNo">212</span><a id="line.212"></a>
<span class="sourceLineNo">213</span><a id="line.213">    /**</a>
<span class="sourceLineNo">214</span><a id="line.214">     * Separately divides the x and y positions of this Coord by other, producing a different Coord as their</a>
<span class="sourceLineNo">215</span><a id="line.215">     * "quotient." If other has 0 for x or y, this will throw an exception, as dividing by 0 is expected to do.</a>
<span class="sourceLineNo">216</span><a id="line.216">     * @param other another Coord</a>
<span class="sourceLineNo">217</span><a id="line.217">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / other.x; y = this.y / other.y}</a>
<span class="sourceLineNo">218</span><a id="line.218">     */</a>
<span class="sourceLineNo">219</span><a id="line.219">    public Coord divide(final Coord other)</a>
<span class="sourceLineNo">220</span><a id="line.220">    {</a>
<span class="sourceLineNo">221</span><a id="line.221">        return get(x / other.x, y / other.y);</a>
<span class="sourceLineNo">222</span><a id="line.222">    }</a>
<span class="sourceLineNo">223</span><a id="line.223">    /**</a>
<span class="sourceLineNo">224</span><a id="line.224">     * Separately divides the x and y positions of this Coord by operand, producing a different Coord as their</a>
<span class="sourceLineNo">225</span><a id="line.225">     * "quotient." If operand is 0, this will throw an exception, as dividing by 0 is expected to do.</a>
<span class="sourceLineNo">226</span><a id="line.226">     * @param operand a value to divide each of x and y by</a>
<span class="sourceLineNo">227</span><a id="line.227">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / operand; y = this.y / operand}</a>
<span class="sourceLineNo">228</span><a id="line.228">     */</a>
<span class="sourceLineNo">229</span><a id="line.229">    public Coord divide(final int operand)</a>
<span class="sourceLineNo">230</span><a id="line.230">    {</a>
<span class="sourceLineNo">231</span><a id="line.231">        return get(x / operand, y / operand);</a>
<span class="sourceLineNo">232</span><a id="line.232">    }</a>
<span class="sourceLineNo">233</span><a id="line.233"></a>
<span class="sourceLineNo">234</span><a id="line.234">    /**</a>
<span class="sourceLineNo">235</span><a id="line.235">     * Separately divides the x and y positions of this Coord by operand, flooring to a lower int for each of x and</a>
<span class="sourceLineNo">236</span><a id="line.236">     * y and producing a different Coord as their "quotient." If operand is 0.0, expect strange results (infinity and</a>
<span class="sourceLineNo">237</span><a id="line.237">     * NaN are both possibilities).</a>
<span class="sourceLineNo">238</span><a id="line.238">     * @param operand a value to divide each of x and y by</a>
<span class="sourceLineNo">239</span><a id="line.239">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / operand; y = this.y /</a>
<span class="sourceLineNo">240</span><a id="line.240">     *          operand}, with both x and y rounded accordingly</a>
<span class="sourceLineNo">241</span><a id="line.241">     */</a>
<span class="sourceLineNo">242</span><a id="line.242">    public Coord divide(final double operand)</a>
<span class="sourceLineNo">243</span><a id="line.243">    {</a>
<span class="sourceLineNo">244</span><a id="line.244">        return get((int)(x / operand), (int)(y / operand));</a>
<span class="sourceLineNo">245</span><a id="line.245">    }</a>
<span class="sourceLineNo">246</span><a id="line.246"></a>
<span class="sourceLineNo">247</span><a id="line.247">    /**</a>
<span class="sourceLineNo">248</span><a id="line.248">     * Separately divides the x and y positions of this Coord by operand, rounding to the nearest int for each of x and</a>
<span class="sourceLineNo">249</span><a id="line.249">     * y and producing a different Coord as their "quotient." If operand is 0.0, expect strange results (infinity and</a>
<span class="sourceLineNo">250</span><a id="line.250">     * NaN are both possibilities).</a>
<span class="sourceLineNo">251</span><a id="line.251">     * @param operand a value to divide each of x and y by</a>
<span class="sourceLineNo">252</span><a id="line.252">     * @return a Coord (usually cached and not a new instance) with {@code x = this.x / operand; y = this.y /</a>
<span class="sourceLineNo">253</span><a id="line.253">     *          operand}, with both x and y rounded accordingly</a>
<span class="sourceLineNo">254</span><a id="line.254">     */</a>
<span class="sourceLineNo">255</span><a id="line.255">    public Coord divideRounding(final double operand)</a>
<span class="sourceLineNo">256</span><a id="line.256">    {</a>
<span class="sourceLineNo">257</span><a id="line.257">        return get((int)Math.round(x / operand), (int)Math.round(y / operand));</a>
<span class="sourceLineNo">258</span><a id="line.258">    }</a>
<span class="sourceLineNo">259</span><a id="line.259"></a>
<span class="sourceLineNo">260</span><a id="line.260">    /**</a>
<span class="sourceLineNo">261</span><a id="line.261">     * Separately averages the x and y positions of this Coord with other, producing a different Coord as their</a>
<span class="sourceLineNo">262</span><a id="line.262">     * "midpoint."</a>
<span class="sourceLineNo">263</span><a id="line.263">     * @param other another Coord</a>
<span class="sourceLineNo">264</span><a id="line.264">     * @return a Coord (usually cached and not a new instance) halfway between this and other, rounded nearest.</a>
<span class="sourceLineNo">265</span><a id="line.265">     */</a>
<span class="sourceLineNo">266</span><a id="line.266">    public Coord average(final Coord other)</a>
<span class="sourceLineNo">267</span><a id="line.267">    {</a>
<span class="sourceLineNo">268</span><a id="line.268">        return get(Math.round((x + other.x) / 2.0f), Math.round((y + other.y) / 2.0f));</a>
<span class="sourceLineNo">269</span><a id="line.269">    }</a>
<span class="sourceLineNo">270</span><a id="line.270">        /**</a>
<span class="sourceLineNo">271</span><a id="line.271">         * @param d</a>
<span class="sourceLineNo">272</span><a id="line.272">         *            A non-{@code null} direction.</a>
<span class="sourceLineNo">273</span><a id="line.273">         * @return The coordinate obtained by applying {@code d} on {@code this}.</a>
<span class="sourceLineNo">274</span><a id="line.274">         */</a>
<span class="sourceLineNo">275</span><a id="line.275">        public Coord translate(final Direction d) {</a>
<span class="sourceLineNo">276</span><a id="line.276">                return Coord.get(x + d.deltaX, y + d.deltaY);</a>
<span class="sourceLineNo">277</span><a id="line.277">        }</a>
<span class="sourceLineNo">278</span><a id="line.278"></a>
<span class="sourceLineNo">279</span><a id="line.279">        /**</a>
<span class="sourceLineNo">280</span><a id="line.280">         * @param i</a>
<span class="sourceLineNo">281</span><a id="line.281">         * @return {@code (x*i,y*i)}.</a>
<span class="sourceLineNo">282</span><a id="line.282">         */</a>
<span class="sourceLineNo">283</span><a id="line.283">        public Coord scale(final int i) {</a>
<span class="sourceLineNo">284</span><a id="line.284">                return Coord.get(x * i, y * i);</a>
<span class="sourceLineNo">285</span><a id="line.285">        }</a>
<span class="sourceLineNo">286</span><a id="line.286"></a>
<span class="sourceLineNo">287</span><a id="line.287">        /**</a>
<span class="sourceLineNo">288</span><a id="line.288">         * @param i</a>
<span class="sourceLineNo">289</span><a id="line.289">         * @return {@code (x*i,y*j)}.</a>
<span class="sourceLineNo">290</span><a id="line.290">         */</a>
<span class="sourceLineNo">291</span><a id="line.291">        public Coord scale(final int i, final int j) {</a>
<span class="sourceLineNo">292</span><a id="line.292">                return Coord.get(x * i, y * j);</a>
<span class="sourceLineNo">293</span><a id="line.293">        }</a>
<span class="sourceLineNo">294</span><a id="line.294"></a>
<span class="sourceLineNo">295</span><a id="line.295">    public double distance(final double x2, final double y2)</a>
<span class="sourceLineNo">296</span><a id="line.296">    {</a>
<span class="sourceLineNo">297</span><a id="line.297">        return Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));</a>
<span class="sourceLineNo">298</span><a id="line.298">    }</a>
<span class="sourceLineNo">299</span><a id="line.299">    public double distance(final Coord co)</a>
<span class="sourceLineNo">300</span><a id="line.300">    {</a>
<span class="sourceLineNo">301</span><a id="line.301">        return Math.sqrt((co.x - x) * (co.x - x) + (co.y - y) * (co.y - y));</a>
<span class="sourceLineNo">302</span><a id="line.302">    }</a>
<span class="sourceLineNo">303</span><a id="line.303">    public double distanceSq(final double x2, final double y2)</a>
<span class="sourceLineNo">304</span><a id="line.304">    {</a>
<span class="sourceLineNo">305</span><a id="line.305">        return (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);</a>
<span class="sourceLineNo">306</span><a id="line.306">    }</a>
<span class="sourceLineNo">307</span><a id="line.307">    public double distanceSq(final Coord co) { return (co.x - x) * (co.x - x) + (co.y - y) * (co.y - y); }</a>
<span class="sourceLineNo">308</span><a id="line.308"></a>
<span class="sourceLineNo">309</span><a id="line.309">    /**</a>
<span class="sourceLineNo">310</span><a id="line.310">     * Gets a Coord based off this instance but with odd values for x and/or y decreased to the nearest even number.</a>
<span class="sourceLineNo">311</span><a id="line.311">     * May be useful for thin-wall maps as produced by {@link squidpony.squidgrid.mapping.ThinDungeonGenerator} and used</a>
<span class="sourceLineNo">312</span><a id="line.312">     * with {@link squidpony.squidgrid.Adjacency.ThinWallAdjacency}.</a>
<span class="sourceLineNo">313</span><a id="line.313">     * @return a Coord (probably from the pool) with even x and even y, changing (decrementing) only if they are odd</a>
<span class="sourceLineNo">314</span><a id="line.314">     */</a>
<span class="sourceLineNo">315</span><a id="line.315">    public Coord makeEven()</a>
<span class="sourceLineNo">316</span><a id="line.316">    {</a>
<span class="sourceLineNo">317</span><a id="line.317">        return get(x &amp; -2, y &amp; -2);</a>
<span class="sourceLineNo">318</span><a id="line.318">    }</a>
<span class="sourceLineNo">319</span><a id="line.319"></a>
<span class="sourceLineNo">320</span><a id="line.320">    /**</a>
<span class="sourceLineNo">321</span><a id="line.321">     * Gets a Coord based off this instance but with even values for x and/or y increased to the nearest odd number.</a>
<span class="sourceLineNo">322</span><a id="line.322">     * May be useful for thin-wall maps as produced by {@link squidpony.squidgrid.mapping.ThinDungeonGenerator} and used</a>
<span class="sourceLineNo">323</span><a id="line.323">     * with {@link squidpony.squidgrid.Adjacency.ThinWallAdjacency}.</a>
<span class="sourceLineNo">324</span><a id="line.324">     * @return a Coord (probably from the pool) with odd x and odd y, changing (incrementing) only if they are even</a>
<span class="sourceLineNo">325</span><a id="line.325">     */</a>
<span class="sourceLineNo">326</span><a id="line.326">    public Coord makeOdd() {</a>
<span class="sourceLineNo">327</span><a id="line.327">        return get(x | 1, y | 1);</a>
<span class="sourceLineNo">328</span><a id="line.328">    }</a>
<span class="sourceLineNo">329</span><a id="line.329"></a>
<span class="sourceLineNo">330</span><a id="line.330">        /**</a>
<span class="sourceLineNo">331</span><a id="line.331">         * @param c</a>
<span class="sourceLineNo">332</span><a id="line.332">         * @return Whether {@code this} is adjacent to {@code c}. Not that a cell is</a>
<span class="sourceLineNo">333</span><a id="line.333">         *         not adjacent to itself with this method.</a>
<span class="sourceLineNo">334</span><a id="line.334">         */</a>
<span class="sourceLineNo">335</span><a id="line.335">        public boolean isAdjacent(final Coord c) {</a>
<span class="sourceLineNo">336</span><a id="line.336">                switch (Math.abs(x - c.x)) {</a>
<span class="sourceLineNo">337</span><a id="line.337">                case 0:</a>
<span class="sourceLineNo">338</span><a id="line.338">                        return Math.abs(y - c.y) == 1;</a>
<span class="sourceLineNo">339</span><a id="line.339">                case 1:</a>
<span class="sourceLineNo">340</span><a id="line.340">                        return y == c.y || Math.abs(y - c.y) == 1;</a>
<span class="sourceLineNo">341</span><a id="line.341">                default:</a>
<span class="sourceLineNo">342</span><a id="line.342">                        return false;</a>
<span class="sourceLineNo">343</span><a id="line.343">                }</a>
<span class="sourceLineNo">344</span><a id="line.344">        }</a>
<span class="sourceLineNo">345</span><a id="line.345"></a>
<span class="sourceLineNo">346</span><a id="line.346">        /**</a>
<span class="sourceLineNo">347</span><a id="line.347">         * Precondition: {@code this} is {@link #isAdjacent(Coord) adjacent} to</a>
<span class="sourceLineNo">348</span><a id="line.348">         * {@code adjacent}.</a>
<span class="sourceLineNo">349</span><a id="line.349">     *</a>
<span class="sourceLineNo">350</span><a id="line.350">         * @param adjacent</a>
<span class="sourceLineNo">351</span><a id="line.351">         *            A {@link Coord} that is {@link #isAdjacent(Coord) adjacent} to</a>
<span class="sourceLineNo">352</span><a id="line.352">         *            {@code this}.</a>
<span class="sourceLineNo">353</span><a id="line.353">         * @return The direction to go from {@code this} to {@code adjacent} i.e.</a>
<span class="sourceLineNo">354</span><a id="line.354">         *         the direction {@code d} such that {@code translate(this, d)}</a>
<span class="sourceLineNo">355</span><a id="line.355">         *         yields {@code adjacent}.</a>
<span class="sourceLineNo">356</span><a id="line.356">         * @throws IllegalStateException</a>
<span class="sourceLineNo">357</span><a id="line.357">         *             If {@code this} isn't adjacent to {@code adjacent}.</a>
<span class="sourceLineNo">358</span><a id="line.358">         */</a>
<span class="sourceLineNo">359</span><a id="line.359">        /* different implementation than before, closer to isAdjacent() */</a>
<span class="sourceLineNo">360</span><a id="line.360">        public Direction toGoTo(final Coord adjacent) {</a>
<span class="sourceLineNo">361</span><a id="line.361">        switch (adjacent.x - x) {</a>
<span class="sourceLineNo">362</span><a id="line.362">            case 0:</a>
<span class="sourceLineNo">363</span><a id="line.363">                switch (adjacent.y - y)</a>
<span class="sourceLineNo">364</span><a id="line.364">                {</a>
<span class="sourceLineNo">365</span><a id="line.365">                    case -1: return Direction.UP;</a>
<span class="sourceLineNo">366</span><a id="line.366">                    case 1: return Direction.DOWN;</a>
<span class="sourceLineNo">367</span><a id="line.367">                    default:</a>
<span class="sourceLineNo">368</span><a id="line.368">                        throw new IllegalStateException(this + " is not adjacent to " + adjacent);</a>
<span class="sourceLineNo">369</span><a id="line.369">                }</a>
<span class="sourceLineNo">370</span><a id="line.370">            case 1:</a>
<span class="sourceLineNo">371</span><a id="line.371">                switch (adjacent.y - y)</a>
<span class="sourceLineNo">372</span><a id="line.372">                {</a>
<span class="sourceLineNo">373</span><a id="line.373">                    case -1: return Direction.UP_RIGHT;</a>
<span class="sourceLineNo">374</span><a id="line.374">                    case 0: return Direction.RIGHT;</a>
<span class="sourceLineNo">375</span><a id="line.375">                    case 1: return Direction.DOWN_RIGHT;</a>
<span class="sourceLineNo">376</span><a id="line.376">                    default:</a>
<span class="sourceLineNo">377</span><a id="line.377">                        throw new IllegalStateException(this + " is not adjacent to " + adjacent);</a>
<span class="sourceLineNo">378</span><a id="line.378">                }</a>
<span class="sourceLineNo">379</span><a id="line.379">            case -1:</a>
<span class="sourceLineNo">380</span><a id="line.380">                switch (adjacent.y - y)</a>
<span class="sourceLineNo">381</span><a id="line.381">                {</a>
<span class="sourceLineNo">382</span><a id="line.382">                    case -1: return Direction.UP_LEFT;</a>
<span class="sourceLineNo">383</span><a id="line.383">                    case 0: return Direction.LEFT;</a>
<span class="sourceLineNo">384</span><a id="line.384">                    case 1: return Direction.DOWN_LEFT;</a>
<span class="sourceLineNo">385</span><a id="line.385">                    default:</a>
<span class="sourceLineNo">386</span><a id="line.386">                        throw new IllegalStateException(this + " is not adjacent to " + adjacent);</a>
<span class="sourceLineNo">387</span><a id="line.387">                }</a>
<span class="sourceLineNo">388</span><a id="line.388">            default:</a>
<span class="sourceLineNo">389</span><a id="line.389">                throw new IllegalStateException(this + " is not adjacent to " + adjacent);</a>
<span class="sourceLineNo">390</span><a id="line.390">        }</a>
<span class="sourceLineNo">391</span><a id="line.391">        }</a>
<span class="sourceLineNo">392</span><a id="line.392"></a>
<span class="sourceLineNo">393</span><a id="line.393">    /**</a>
<span class="sourceLineNo">394</span><a id="line.394">     * Returns true if x is between 0 (inclusive) and width (exclusive) and y is between 0 (inclusive) and height</a>
<span class="sourceLineNo">395</span><a id="line.395">     * (exclusive), false otherwise.</a>
<span class="sourceLineNo">396</span><a id="line.396">     * @param width the upper limit on x to check, exclusive</a>
<span class="sourceLineNo">397</span><a id="line.397">     * @param height the upper limit on y to check, exclusive</a>
<span class="sourceLineNo">398</span><a id="line.398">     * @return true if this Coord is within the limits of width and height and has non-negative x and y</a>
<span class="sourceLineNo">399</span><a id="line.399">     */</a>
<span class="sourceLineNo">400</span><a id="line.400">    public boolean isWithin(final int width, final int height)</a>
<span class="sourceLineNo">401</span><a id="line.401">    {</a>
<span class="sourceLineNo">402</span><a id="line.402">        return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &lt; height;</a>
<span class="sourceLineNo">403</span><a id="line.403">    }</a>
<span class="sourceLineNo">404</span><a id="line.404">    /**</a>
<span class="sourceLineNo">405</span><a id="line.405">     * Returns true if x is between minX (inclusive) and maxX (exclusive) and y is between minY (inclusive) and maxY</a>
<span class="sourceLineNo">406</span><a id="line.406">     * (exclusive), false otherwise.</a>
<span class="sourceLineNo">407</span><a id="line.407">     * @param minX the lower limit on x to check, inclusive</a>
<span class="sourceLineNo">408</span><a id="line.408">     * @param minY the lower limit on y to check, inclusive</a>
<span class="sourceLineNo">409</span><a id="line.409">     * @param maxX the upper limit on x to check, exclusive</a>
<span class="sourceLineNo">410</span><a id="line.410">     * @param maxY the upper limit on y to check, exclusive</a>
<span class="sourceLineNo">411</span><a id="line.411">     * @return true if this Coord is within the limits of the given parameters</a>
<span class="sourceLineNo">412</span><a id="line.412">     */</a>
<span class="sourceLineNo">413</span><a id="line.413">    public boolean isWithinRectangle(int minX, int minY, int maxX, int maxY)</a>
<span class="sourceLineNo">414</span><a id="line.414">    {</a>
<span class="sourceLineNo">415</span><a id="line.415">        return x &gt;= minX &amp;&amp; y &gt;= minY &amp;&amp; x &lt; maxX &amp;&amp; y &lt; maxY;</a>
<span class="sourceLineNo">416</span><a id="line.416">    }</a>
<span class="sourceLineNo">417</span><a id="line.417">    public int getX() {</a>
<span class="sourceLineNo">418</span><a id="line.418">        return x;</a>
<span class="sourceLineNo">419</span><a id="line.419">    }</a>
<span class="sourceLineNo">420</span><a id="line.420"></a>
<span class="sourceLineNo">421</span><a id="line.421">    public Coord setX(final int x) {</a>
<span class="sourceLineNo">422</span><a id="line.422">        return get(x, y);</a>
<span class="sourceLineNo">423</span><a id="line.423">    }</a>
<span class="sourceLineNo">424</span><a id="line.424"></a>
<span class="sourceLineNo">425</span><a id="line.425">    public int getY() {</a>
<span class="sourceLineNo">426</span><a id="line.426">        return y;</a>
<span class="sourceLineNo">427</span><a id="line.427">    }</a>
<span class="sourceLineNo">428</span><a id="line.428"></a>
<span class="sourceLineNo">429</span><a id="line.429">    public Coord setY(final int y) {</a>
<span class="sourceLineNo">430</span><a id="line.430">        return get(x, y);</a>
<span class="sourceLineNo">431</span><a id="line.431">    }</a>
<span class="sourceLineNo">432</span><a id="line.432"></a>
<span class="sourceLineNo">433</span><a id="line.433">    @Override</a>
<span class="sourceLineNo">434</span><a id="line.434">    public String toString()</a>
<span class="sourceLineNo">435</span><a id="line.435">    {</a>
<span class="sourceLineNo">436</span><a id="line.436">        return "(" + x + "," + y + ")";</a>
<span class="sourceLineNo">437</span><a id="line.437">    }</a>
<span class="sourceLineNo">438</span><a id="line.438"></a>
<span class="sourceLineNo">439</span><a id="line.439">    /**</a>
<span class="sourceLineNo">440</span><a id="line.440">     * Gets the hash code for this Coord; does not use the standard "auto-complete" style of hash that most IDEs will</a>
<span class="sourceLineNo">441</span><a id="line.441">     * generate, but instead uses a highly-specific technique based on Cantor's pairing function, xorshifts,</a>
<span class="sourceLineNo">442</span><a id="line.442">     * xor-rotate-xor-rotate, and an XLCG step at the end. It manages to get extremely low collision rates under many</a>
<span class="sourceLineNo">443</span><a id="line.443">     * circumstances, and very frequently manages to avoid colliding on more than 25% of Coords (making the load factor</a>
<span class="sourceLineNo">444</span><a id="line.444">     * of most hash-based collections fine at a default of 0.75) while often having 0 collisions with some data sets.</a>
<span class="sourceLineNo">445</span><a id="line.445">     * It tolerates negative x and y for Coords fairly well.</a>
<span class="sourceLineNo">446</span><a id="line.446">     * &lt;br&gt;</a>
<span class="sourceLineNo">447</span><a id="line.447">     * This gets comparable collision rates to a previous version used by SquidLib, around 3% across a wide variety of</a>
<span class="sourceLineNo">448</span><a id="line.448">     * rectangular areas, but has much better results when used for seeding procedural generation based on a Coord (a</a>
<span class="sourceLineNo">449</span><a id="line.449">     * reasonable usage of this method). The previous method changed bits in large checkerboard patterns, leaving heavy</a>
<span class="sourceLineNo">450</span><a id="line.450">     * square-shaped biases in generated results, while this version only has checkerboard-reminiscent patterns in the</a>
<span class="sourceLineNo">451</span><a id="line.451">     * lowest 4 or 5 bits, and even then has some chaotic scattering.</a>
<span class="sourceLineNo">452</span><a id="line.452">     * &lt;br&gt;</a>
<span class="sourceLineNo">453</span><a id="line.453">     * This changed at least six times in SquidLib's history. In general, you shouldn't rely on hashCodes to stay the</a>
<span class="sourceLineNo">454</span><a id="line.454">     * same across platforms and versions, whether for the JDK or this library. SquidLib (tries to) never depend on the</a>
<span class="sourceLineNo">455</span><a id="line.455">     * unpredictable ordering of some hash-based collections like HashSet and HashMap, instead using its own</a>
<span class="sourceLineNo">456</span><a id="line.456">     * {@link OrderedSet} and {@link OrderedMap}; if you use the ordered kinds, then the only things that matter about</a>
<span class="sourceLineNo">457</span><a id="line.457">     * this hash code are that it's fast (it's fast enough), it's cross-platform compatible (this version avoids using</a>
<span class="sourceLineNo">458</span><a id="line.458">     * long values, which are slow on GWT, and is carefully written to behave the same on GWT as desktop) and that it</a>
<span class="sourceLineNo">459</span><a id="line.459">     * doesn't collide often (which is now much more accurate than in earlier versions of this method).</a>
<span class="sourceLineNo">460</span><a id="line.460">     * @see #cantorHashCode(int, int) A static method that gets the same result as this method without involving a Coord</a>
<span class="sourceLineNo">461</span><a id="line.461">     * @return an int that should, for most different Coord values, be significantly different from the other hash codes</a>
<span class="sourceLineNo">462</span><a id="line.462">     */</a>
<span class="sourceLineNo">463</span><a id="line.463">    @Override</a>
<span class="sourceLineNo">464</span><a id="line.464">    public int hashCode() {</a>
<span class="sourceLineNo">465</span><a id="line.465">        int r = x, s = y;</a>
<span class="sourceLineNo">466</span><a id="line.466">        r ^= r &gt;&gt; 31;</a>
<span class="sourceLineNo">467</span><a id="line.467">        s ^= s &gt;&gt; 31;</a>
<span class="sourceLineNo">468</span><a id="line.468">        s += ((r+s) * (r+s+1) &gt;&gt; 1);</a>
<span class="sourceLineNo">469</span><a id="line.469">        s ^= s &gt;&gt;&gt; 1 ^ s &gt;&gt;&gt; 6;</a>
<span class="sourceLineNo">470</span><a id="line.470">        return (s ^ (s &lt;&lt; 15 | s &gt;&gt;&gt; 17) ^ (s &lt;&lt; 23 | s &gt;&gt;&gt; 9)) * 0x125493 ^ 0xD1B54A35;</a>
<span class="sourceLineNo">471</span><a id="line.471">    }</a>
<span class="sourceLineNo">472</span><a id="line.472"></a>
<span class="sourceLineNo">473</span><a id="line.473">    /**</a>
<span class="sourceLineNo">474</span><a id="line.474">     * A static version of the current {@link #hashCode()} method of this class, taking x and y as parameters instead of</a>
<span class="sourceLineNo">475</span><a id="line.475">     * requiring a Coord object. Like the current hashCode() method, this involves the close-to-optimal mathematical</a>
<span class="sourceLineNo">476</span><a id="line.476">     * Cantor pairing function to distribute x and y without overlap until they get very large. Cantor's pairing</a>
<span class="sourceLineNo">477</span><a id="line.477">     * function can be written simply as {@code ((x + y) * (x + y + 1)) / 2 + y}; it produces sequential results for a</a>
<span class="sourceLineNo">478</span><a id="line.478">     * sequence of positive points traveling in diagonal stripes away from the origin.</a>
<span class="sourceLineNo">479</span><a id="line.479">     * @param x the x coordinate of the "imaginary Coord" to hash</a>
<span class="sourceLineNo">480</span><a id="line.480">     * @param y the y coordinate of the "imaginary Coord" to hash</a>
<span class="sourceLineNo">481</span><a id="line.481">     * @return the equivalent to the hashCode() of an "imaginary Coord"</a>
<span class="sourceLineNo">482</span><a id="line.482">     */</a>
<span class="sourceLineNo">483</span><a id="line.483">    public static int cantorHashCode(int x, int y) {</a>
<span class="sourceLineNo">484</span><a id="line.484">        x ^= x &gt;&gt; 31;</a>
<span class="sourceLineNo">485</span><a id="line.485">        y ^= y &gt;&gt; 31;</a>
<span class="sourceLineNo">486</span><a id="line.486">        y += ((x + y) * (x + y + 1) &gt;&gt; 1);</a>
<span class="sourceLineNo">487</span><a id="line.487">        y ^= y &gt;&gt;&gt; 1 ^ y &gt;&gt;&gt; 6;</a>
<span class="sourceLineNo">488</span><a id="line.488">        return (y ^ (y &lt;&lt; 15 | y &gt;&gt;&gt; 17) ^ (y &lt;&lt; 23 | y &gt;&gt;&gt; 9)) * 0x125493 ^ 0xD1B54A35;</a>
<span class="sourceLineNo">489</span><a id="line.489">    }</a>
<span class="sourceLineNo">490</span><a id="line.490">    /**</a>
<span class="sourceLineNo">491</span><a id="line.491">     * An earlier hashCode() implementation used by this class, now standalone in case you want to replicate the results</a>
<span class="sourceLineNo">492</span><a id="line.492">     * of the older code. This uses only bitwise operations, which tend to be fairly fast on all platforms, and when</a>
<span class="sourceLineNo">493</span><a id="line.493">     * used in a collection it has comparable collision rates to the current hashCode() method (very, very low rates),</a>
<span class="sourceLineNo">494</span><a id="line.494">     * but if used for procedural generation it's simply terrible, with large blocks of nearby x,y points having</a>
<span class="sourceLineNo">495</span><a id="line.495">     * identical values for several bits and all changes happening in a repetitive checkerboard pattern. It is</a>
<span class="sourceLineNo">496</span><a id="line.496">     * structured very similarly to {@link XoRoRNG} and {@link Lathe32RNG} in particular, but using only bitwise math.</a>
<span class="sourceLineNo">497</span><a id="line.497">     * @param x the x coordinate of the "imaginary Coord" to hash</a>
<span class="sourceLineNo">498</span><a id="line.498">     * @param y the y coordinate of the "imaginary Coord" to hash</a>
<span class="sourceLineNo">499</span><a id="line.499">     * @return the equivalent to the hashCode() of an "imaginary Coord"</a>
<span class="sourceLineNo">500</span><a id="line.500">     */</a>
<span class="sourceLineNo">501</span><a id="line.501">    public static int xoroHashCode(final int x, final int y) {</a>
<span class="sourceLineNo">502</span><a id="line.502">        int r = x ^ y;</a>
<span class="sourceLineNo">503</span><a id="line.503">        r ^= (x &lt;&lt; 13 | x &gt;&gt;&gt; 19) ^ (r &lt;&lt; 5) ^ (r &lt;&lt; 28 | r &gt;&gt;&gt; 4);</a>
<span class="sourceLineNo">504</span><a id="line.504">        r = x ^ (r &lt;&lt; 11 | r &gt;&gt;&gt; 21);</a>
<span class="sourceLineNo">505</span><a id="line.505">        return r ^ (r &lt;&lt; 25 | r &gt;&gt;&gt; 7);</a>
<span class="sourceLineNo">506</span><a id="line.506">    }</a>
<span class="sourceLineNo">507</span><a id="line.507"></a>
<span class="sourceLineNo">508</span><a id="line.508">    /**</a>
<span class="sourceLineNo">509</span><a id="line.509">     * Something like hashCode(), but reversible with {@code Coord.decode()}. Works for Coords between roughly -256 and</a>
<span class="sourceLineNo">510</span><a id="line.510">     * 32000 in each of x and y, but will probably only decode to pooled Coords if x and y are both between -3 and 255</a>
<span class="sourceLineNo">511</span><a id="line.511">     * (inclusive for both).</a>
<span class="sourceLineNo">512</span><a id="line.512">     * @return an int as a unique code for this Coord</a>
<span class="sourceLineNo">513</span><a id="line.513">     */</a>
<span class="sourceLineNo">514</span><a id="line.514">    public int encode()</a>
<span class="sourceLineNo">515</span><a id="line.515">    {</a>
<span class="sourceLineNo">516</span><a id="line.516">        return ((x + 256) &lt;&lt; 16) ^ (y + 256);</a>
<span class="sourceLineNo">517</span><a id="line.517">    }</a>
<span class="sourceLineNo">518</span><a id="line.518"></a>
<span class="sourceLineNo">519</span><a id="line.519">    /**</a>
<span class="sourceLineNo">520</span><a id="line.520">     * An alternative to getting a Coord with Coord.get() only to encode() it as the next step. This doesn't create a</a>
<span class="sourceLineNo">521</span><a id="line.521">     * Coord in the middle step. Can be decoded with Coord.decode() to get the (x,y) Coord.</a>
<span class="sourceLineNo">522</span><a id="line.522">     * @param x the x position to encode</a>
<span class="sourceLineNo">523</span><a id="line.523">     * @param y the y position to encode</a>
<span class="sourceLineNo">524</span><a id="line.524">     * @return the coded int that a Coord at (x,y) would produce with encode()</a>
<span class="sourceLineNo">525</span><a id="line.525">     */</a>
<span class="sourceLineNo">526</span><a id="line.526">    public static int pureEncode(final int x, final int y)</a>
<span class="sourceLineNo">527</span><a id="line.527">    {</a>
<span class="sourceLineNo">528</span><a id="line.528">        return ((x + 256) &lt;&lt; 16) ^ (y + 256);</a>
<span class="sourceLineNo">529</span><a id="line.529">    }</a>
<span class="sourceLineNo">530</span><a id="line.530">    /**</a>
<span class="sourceLineNo">531</span><a id="line.531">     * This can take an int produced by {@code someCoord.encode()} and get the original Coord back out of it. It</a>
<span class="sourceLineNo">532</span><a id="line.532">     * works for all pooled Coords where the pool hasn't been expanded past about 32,000 in either dimension. It even</a>
<span class="sourceLineNo">533</span><a id="line.533">     * works for Coords with negative x or y as well, if they are no lower than -256 in either dimension. This will</a>
<span class="sourceLineNo">534</span><a id="line.534">     * almost certainly fail (producing a gibberish Coord that probably won't be pooled) on hashes produced by any other</a>
<span class="sourceLineNo">535</span><a id="line.535">     * class, including subclasses of Coord.</a>
<span class="sourceLineNo">536</span><a id="line.536">     * @param code an encoded int from a Coord, but not a subclass of Coord</a>
<span class="sourceLineNo">537</span><a id="line.537">     * @return the Coord that gave hash as its hashCode()</a>
<span class="sourceLineNo">538</span><a id="line.538">     */</a>
<span class="sourceLineNo">539</span><a id="line.539">    public static Coord decode(final int code)</a>
<span class="sourceLineNo">540</span><a id="line.540">    {</a>
<span class="sourceLineNo">541</span><a id="line.541">        return get((code &gt;&gt;&gt; 16) - 256, (code &amp; 0xFFFF) - 256);</a>
<span class="sourceLineNo">542</span><a id="line.542">    }</a>
<span class="sourceLineNo">543</span><a id="line.543"></a>
<span class="sourceLineNo">544</span><a id="line.544">    @Override</a>
<span class="sourceLineNo">545</span><a id="line.545">    public boolean equals(Object o) {</a>
<span class="sourceLineNo">546</span><a id="line.546">        if (o instanceof Coord) {</a>
<span class="sourceLineNo">547</span><a id="line.547">            Coord other = (Coord) o;</a>
<span class="sourceLineNo">548</span><a id="line.548">            return x == other.x &amp;&amp; y == other.y;</a>
<span class="sourceLineNo">549</span><a id="line.549">        } else {</a>
<span class="sourceLineNo">550</span><a id="line.550">            return false;</a>
<span class="sourceLineNo">551</span><a id="line.551">        }</a>
<span class="sourceLineNo">552</span><a id="line.552">    }</a>
<span class="sourceLineNo">553</span><a id="line.553">    private static Coord[][] POOL = new Coord[259][259];</a>
<span class="sourceLineNo">554</span><a id="line.554">    static {</a>
<span class="sourceLineNo">555</span><a id="line.555">        int width = POOL.length, height = POOL[0].length;</a>
<span class="sourceLineNo">556</span><a id="line.556">        for (int i = 0; i &lt; width; i++) {</a>
<span class="sourceLineNo">557</span><a id="line.557">            for (int j = 0; j &lt; height; j++) {</a>
<span class="sourceLineNo">558</span><a id="line.558">                POOL[i][j] = new Coord(i - 3, j - 3);</a>
<span class="sourceLineNo">559</span><a id="line.559">            }</a>
<span class="sourceLineNo">560</span><a id="line.560">        }</a>
<span class="sourceLineNo">561</span><a id="line.561">    }</a>
<span class="sourceLineNo">562</span><a id="line.562"></a>
<span class="sourceLineNo">563</span><a id="line.563">    /**</a>
<span class="sourceLineNo">564</span><a id="line.564">     * Gets the width of the pool used as a cache for Coords, not including negative Coords.</a>
<span class="sourceLineNo">565</span><a id="line.565">     * Unless expandPool() has been called, this should be 256.</a>
<span class="sourceLineNo">566</span><a id="line.566">     * Useful for finding the upper (exclusive) bound for x values that can be used efficiently in Coords.</a>
<span class="sourceLineNo">567</span><a id="line.567">     * Requesting a Coord with a x greater than or equal to this value will result in a new Coord being allocated and</a>
<span class="sourceLineNo">568</span><a id="line.568">     * not cached, which may cause problems with code that expects the normal reference equality of Coords to be upheld</a>
<span class="sourceLineNo">569</span><a id="line.569">     * and in extreme cases may require more time garbage collecting than is normally necessary.</a>
<span class="sourceLineNo">570</span><a id="line.570">     * @return the width of the Coord cache, disregarding negative Coords</a>
<span class="sourceLineNo">571</span><a id="line.571">     */</a>
<span class="sourceLineNo">572</span><a id="line.572">    public static int getCacheWidth()</a>
<span class="sourceLineNo">573</span><a id="line.573">    {</a>
<span class="sourceLineNo">574</span><a id="line.574">        return POOL.length - 3;</a>
<span class="sourceLineNo">575</span><a id="line.575">    }</a>
<span class="sourceLineNo">576</span><a id="line.576"></a>
<span class="sourceLineNo">577</span><a id="line.577">    /**</a>
<span class="sourceLineNo">578</span><a id="line.578">     * Gets the height of the pool used as a cache for Coords, not including negative Coords.</a>
<span class="sourceLineNo">579</span><a id="line.579">     * Unless expandPool() has been called, this should be 256.</a>
<span class="sourceLineNo">580</span><a id="line.580">     * Useful for finding the upper (exclusive) bound for y values that can be used efficiently in Coords.</a>
<span class="sourceLineNo">581</span><a id="line.581">     * Requesting a Coord with a y greater than or equal to this value will result in a new Coord being allocated and</a>
<span class="sourceLineNo">582</span><a id="line.582">     * not cached, which may cause problems with code that expects the normal reference equality of Coords to be upheld</a>
<span class="sourceLineNo">583</span><a id="line.583">     * and in extreme cases may require more time garbage collecting than is normally necessary.</a>
<span class="sourceLineNo">584</span><a id="line.584">     * @return the height of the Coord cache, disregarding negative Coords</a>
<span class="sourceLineNo">585</span><a id="line.585">     */</a>
<span class="sourceLineNo">586</span><a id="line.586">    public static int getCacheHeight()</a>
<span class="sourceLineNo">587</span><a id="line.587">    {</a>
<span class="sourceLineNo">588</span><a id="line.588">        return POOL[0].length - 3;</a>
<span class="sourceLineNo">589</span><a id="line.589">    }</a>
<span class="sourceLineNo">590</span><a id="line.590"></a>
<span class="sourceLineNo">591</span><a id="line.591">    /**</a>
<span class="sourceLineNo">592</span><a id="line.592">     * Enlarges the pool of cached Coords to the given width and height, and doesn't change</a>
<span class="sourceLineNo">593</span><a id="line.593">     * a dimension if it would be reduced in size.</a>
<span class="sourceLineNo">594</span><a id="line.594">     * Cached Coord values will be reused by Coord.get instead of re-allocated each time.</a>
<span class="sourceLineNo">595</span><a id="line.595">     * The default pool allows Coords with x and y each between -3 and 255, inclusive, to</a>
<span class="sourceLineNo">596</span><a id="line.596">     * be cached, and is considered to have width and height of 256 to begin with. Giving a</a>
<span class="sourceLineNo">597</span><a id="line.597">     * width greater than 256 will allow Coords with x greater than 255 to be cached;</a>
<span class="sourceLineNo">598</span><a id="line.598">     * likewise for height. If width or height is smaller than the current cache width or</a>
<span class="sourceLineNo">599</span><a id="line.599">     * height, that dimension will not change, but the other still may if it is valid. You</a>
<span class="sourceLineNo">600</span><a id="line.600">     * cannot shrink the pool size.</a>
<span class="sourceLineNo">601</span><a id="line.601">     * @param width the new width for the pool of cached Coords; will be ignored if smaller than the current width</a>
<span class="sourceLineNo">602</span><a id="line.602">     * @param height the new height for the pool of cached Coords; will be ignored if smaller than the current height</a>
<span class="sourceLineNo">603</span><a id="line.603">     */</a>
<span class="sourceLineNo">604</span><a id="line.604">    public static void expandPoolTo(final int width, final int height)</a>
<span class="sourceLineNo">605</span><a id="line.605">    {</a>
<span class="sourceLineNo">606</span><a id="line.606">        expandPool(Math.max(0, width + 3 - POOL.length), Math.max(0, height + 3 - POOL[0].length));</a>
<span class="sourceLineNo">607</span><a id="line.607">    }</a>
<span class="sourceLineNo">608</span><a id="line.608"></a>
<span class="sourceLineNo">609</span><a id="line.609">    /**</a>
<span class="sourceLineNo">610</span><a id="line.610">     * Enlarges the pool of cached Coords by the given amount of expansion for x and y.</a>
<span class="sourceLineNo">611</span><a id="line.611">     * Cached Coord values will be reused by Coord.get instead of re-allocated each time.</a>
<span class="sourceLineNo">612</span><a id="line.612">     * The default pool allows Coords with x and y each between -3 and 255, inclusive, to</a>
<span class="sourceLineNo">613</span><a id="line.613">     * be cached, and this can increase the size in the positive direction. If either</a>
<span class="sourceLineNo">614</span><a id="line.614">     * xIncrease or yIncrease is negative, this method returns immediately and does nothing</a>
<span class="sourceLineNo">615</span><a id="line.615">     * else; the same is true of both arguments are zero. You cannot shrink the pool size.</a>
<span class="sourceLineNo">616</span><a id="line.616">     * @param xIncrease the amount to increase cache's width by</a>
<span class="sourceLineNo">617</span><a id="line.617">     * @param yIncrease the amount to increase cache's height by</a>
<span class="sourceLineNo">618</span><a id="line.618">     */</a>
<span class="sourceLineNo">619</span><a id="line.619">    public static void expandPool(final int xIncrease, final int yIncrease)</a>
<span class="sourceLineNo">620</span><a id="line.620">    {</a>
<span class="sourceLineNo">621</span><a id="line.621">        if(xIncrease &lt; 0 || yIncrease &lt; 0 || (xIncrease | yIncrease) == 0 )</a>
<span class="sourceLineNo">622</span><a id="line.622">            return;</a>
<span class="sourceLineNo">623</span><a id="line.623">        int width = POOL.length, height = POOL[0].length;</a>
<span class="sourceLineNo">624</span><a id="line.624">        Coord[][] POOL2 = new Coord[width + xIncrease][height + yIncrease];</a>
<span class="sourceLineNo">625</span><a id="line.625">        for (int i = 0; i &lt; width; i++) {</a>
<span class="sourceLineNo">626</span><a id="line.626">            POOL2[i] = new Coord[height + yIncrease];</a>
<span class="sourceLineNo">627</span><a id="line.627">            System.arraycopy(POOL[i], 0, POOL2[i], 0, height);</a>
<span class="sourceLineNo">628</span><a id="line.628">            for (int j = 0; j &lt; height + yIncrease; j++) {</a>
<span class="sourceLineNo">629</span><a id="line.629">                if(POOL2[i][j] == null) POOL2[i][j] = new Coord(i - 3, j - 3);</a>
<span class="sourceLineNo">630</span><a id="line.630">            }</a>
<span class="sourceLineNo">631</span><a id="line.631">        }</a>
<span class="sourceLineNo">632</span><a id="line.632">        for (int i = width; i &lt; width + xIncrease; i++) {</a>
<span class="sourceLineNo">633</span><a id="line.633">            POOL2[i] = new Coord[height + yIncrease];</a>
<span class="sourceLineNo">634</span><a id="line.634">            for (int j = 0; j &lt; height + yIncrease; j++) {</a>
<span class="sourceLineNo">635</span><a id="line.635">                POOL2[i][j] = new Coord(i - 3, j - 3);</a>
<span class="sourceLineNo">636</span><a id="line.636">            }</a>
<span class="sourceLineNo">637</span><a id="line.637">        }</a>
<span class="sourceLineNo">638</span><a id="line.638">        POOL = POOL2;</a>
<span class="sourceLineNo">639</span><a id="line.639">    }</a>
<span class="sourceLineNo">640</span><a id="line.640"></a>
<span class="sourceLineNo">641</span><a id="line.641">    public Coord interpolate(Coord end, float amountTraveled) {</a>
<span class="sourceLineNo">642</span><a id="line.642">        return Coord.get(x + Math.round((end.x - x) * amountTraveled),</a>
<span class="sourceLineNo">643</span><a id="line.643">                y + Math.round((end.y - y) * amountTraveled));</a>
<span class="sourceLineNo">644</span><a id="line.644">    }</a>
<span class="sourceLineNo">645</span><a id="line.645">}</a>




























































</pre>
</div>
</main>
</body>
</html>
