package squidpony.squidmath;

import squidpony.annotation.Beta;

import java.io.Serializable;

import static squidpony.squidmath.Noise.HastyPointHash.*;
import static squidpony.squidmath.Noise.fastFloor;

/**
 * Another experimental noise class. Extends PerlinNoise and should have similar quality, but can be faster and has less
 * periodic results. This is still considered experimental because the exact output may change in future versions, along
 * with the scale (potentially) and the parameters it takes. In general, {@link #noise(double, double)} and
 * {@link #noise(double, double, double)} should have similar appearance to {@link PerlinNoise#noise(double, double)},
 * {@link PerlinNoise#noise(double, double, double)}, and {@link PerlinNoise#noise(double, double, double, double)}, but
 * are not forced to a zoomed-in scale like PerlinNoise makes its results, have a lower chance of forming shapes with
 * multiple octaves that appear "non-natural" (such as long straight lines, axis-aligned shapes, and hard angles), and
 * the 3D and 4D noise variants tend to be faster due to a more efficient method for hashing points. WhirlingNoise is
 * preferred to other related {@link Noise.Noise3D} or {@link Noise.Noise4D} implementations for most world map
 * generation (usually using {@link squidpony.squidgrid.mapping.WorldMapGenerator}) because it is less likely to produce
 * artificial-seeming shapes, which are out-of-place in a world map.
 * <br>
 * Created by Tommy Ettinger on 12/14/2016. The technique for point hashing here is based closely on
 * <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.3594&rep=rep1&type=pdf">this paper</a>,
 * with credit to Andrew Kensler, Aaron Knoll and Peter Shirley.
 */
@Beta
public class WhirlingNoise extends PerlinNoise implements Noise.Noise2D, Noise.Noise3D, Noise.Noise4D, Serializable {

    private static final long serialVersionUID = 5L;
    public long seed;
    public static final WhirlingNoise instance = new WhirlingNoise();
    public WhirlingNoise()
    {
        this(123456789);
    }
    public WhirlingNoise(long seed) {
        this.seed = seed;
//        System.out.println("{");
//        for (int i = 0; i < grad3f.length; i++) {
//            System.out.printf("{% 2.15ff, % 2.15ff, % 2.15ff},\n", grad3f[i][0], grad3f[i][1], grad3f[i][2]);
//        }
//        System.out.println("}");
    }

    protected static final float
            //root2 = 1.4142135f,
            root3 = 1.7320508f,
            F2f = 0.5f * (root3 - 1f),
            G2f = (3f - root3) * 0.16666667f,
            F3f = 0.33333334f,
            G3f = 0.16666667f;
    /*
            root5 = 2.236068f,
            F4f = (root5 - 1f) * 0.25f,
            G4f = (5f - root5) * 0.05f,
            unit1_4f =  0.70710678118f, unit1_8f = 0.38268343236f, unit3_8f = 0.92387953251f;
    */
    /*
    protected static final float[][] grad2f = {
            {1f, 0f}, {-1f, 0f}, {0f, 1f}, {0f, -1f},
            {unit3_8f, unit1_8f}, {unit3_8f, -unit1_8f}, {-unit3_8f, unit1_8f}, {-unit3_8f, -unit1_8f},
            {unit1_4f, unit1_4f}, {unit1_4f, -unit1_4f}, {-unit1_4f, unit1_4f}, {-unit1_4f, -unit1_4f},
            {unit1_8f, unit3_8f}, {unit1_8f, -unit3_8f}, {-unit1_8f, unit3_8f}, {-unit1_8f, -unit3_8f}};
    */
    protected static final float[][] phiGrad2f = {

            {0.8150192046878179f, 0.5794339444578966f},
            {0.3285126080199264f, 0.9444995851624003f},
            {-0.27953103565117526f, 0.9601366569961702f},
            {-0.7841589327438924f, 0.6205600439908774f},
            {-0.9986781437763752f, 0.05140005003279401f},
            {-0.8437248002155627f, -0.5367759881935933f},
            {-0.37662568751777636f, -0.9263655280189145f},
            {0.22981046360408072f, -0.9732354035987786f},
            {0.7512255700688496f, -0.6600455612112939f},
            {0.9947160697132525f, -0.10266421311352707f},
            {0.8701998299869244f, 0.49269895056791824f},
            {0.4237430769975827f, 0.9057824267983017f},
            {-0.17948233877384698f, 0.983761195650789f},
            {-0.7163061830035246f, 0.6977861077657832f},
            {-0.9881242523951498f, 0.15365696153616482f},
            {-0.894374301636155f, -0.44731935859387983f},
            {-0.4697402116302938f, -0.8828046973014625f},
            {0.12867971425053623f, -0.991686205984736f},
            {0.6794930883661505f, -0.7336819085016549f},
            {0.9789201186915606f, -0.20424348513698282f},
            {0.9161843048116499f, 0.4007571828636311f},
            {0.5144954882185442f, 0.857493086037877f},
            {-0.07753689756495279f, 0.9969894831521554f},
            {-0.6408836093932414f, 0.7676380652437f},
            {-0.9671280016853234f, 0.25429004769387453f},
            {-0.9355721801365401f, -0.3531355203807194f},
            {-0.5578905866805359f, -0.8299145096293036f},
            {0.026189095618157535f, -0.9996570068131884f},
            {0.6005798184449439f, -0.7995648076776756f},
            {0.9527790763429471f, -0.30366434048646623f},
            {0.9524866716435015f, 0.30458026912701447f},
            {0.5998107828543199f, 0.8001418779014681f},
            {0.025227942766709196f, 0.9996817248023291f},
            {-0.5586882671550536f, 0.8293777306772129f},
            {-0.9359112770969633f, 0.35223583208232967f},
            {-0.9668830622808007f, -0.25521979522462845f},
            {-0.6401452517954772f, -0.7682539011314586f},
            {-0.07657828572526153f, -0.997063571772322f},
            {0.5153197047391562f, -0.8569980174466851f},
            {0.9165691975581982f, -0.39987611342454643f},
            {0.9787232921313124f, 0.20518459357282604f},
            {0.6787873607664123f, 0.7343348819603821f},
            {0.12772617771665648f, 0.9918094693669208f},
            {-0.4705887852055238f, 0.8823526478901672f},
            {-0.8948039726230813f, 0.44645923730834813f},
            {-0.987976059032004f, -0.1546069428570078f},
            {-0.7156349511426562f, -0.6984744925214149f},
            {-0.17853639842218227f, -0.9839333079220541f},
            {0.42461376424291053f, -0.9053745916555567f},
            {0.8706731432876941f, -0.49186205134928496f},
            {0.9946169013278476f, 0.10362055584193075f},
            {0.7505906084908771f, 0.6607675373724824f},
            {0.22887462022891217f, 0.9734559097437702f},
            {-0.37751618658649483f, 0.926002985343563f},
            {-0.8442405045259113f, 0.53596452356274f},
            {-0.998628262541406f, -0.052360225873583494f},
            {-0.7835619201046374f, -0.6213137028602651f},
            {-0.27860776335327647f, -0.9604049740600497f},
            {0.32942056468855896f, -0.9441832934130274f},
            {0.815575936633839f, -0.5786500596939711f},
            {0.9999995377871086f, 9.614705243498993E-4f},
            {0.8144617193170308f, 0.5802172935781439f},
            {0.32760434766577023f, 0.9448150037920043f},
            {-0.2804540495433758f, 0.9598674523572105f},
            {-0.7847552204864104f, 0.6198058114597872f},
            {-0.9987271018075193f, 0.05043982667647658f},
            {-0.8432083159442574f, -0.5375869566148805f},
            {-0.37573484028656684f, -0.9267272143380857f},
            {0.23074609453653327f, -0.9730139977698868f},
            {0.7518598371945376f, -0.6593229748869694f},
            {0.9948143185574757f, -0.10170777547968135f},
            {0.8697257122509974f, 0.4935353943229353f},
            {0.4228719980332324f, 0.9061894246124161f},
            {-0.18042811320741017f, 0.9835881739653105f},
            {-0.7169767526924914f, 0.69709707795868f},
            {-0.9882715323107604f, 0.15270683817086136f},
            {-0.8939438038665631f, -0.44817906636586646f},
            {-0.4688912038150978f, -0.883255930625336f},
            {0.1296331318295739f, -0.9915620258622535f},
            {0.6801981878249586f, -0.7330282568084551f},
            {0.9791160403128117f, -0.20330218789319596f},
            {0.9157985651207083f, 0.40163788183244326f},
            {0.5136707960850377f, 0.8579873619403514f},
            {-0.07849543772753681f, 0.9969144728892054f},
            {-0.6416213745416761f, 0.7670215197315198f},
            {-0.9673720470517861f, 0.2533600650908442f},
            {-0.9352322183090706f, -0.3540348822315325f},
            {-0.5570923904775789f, -0.8304505213870221f},
            {0.0271502242597271f, -0.9996313647153368f},
            {0.6013482988440962f, -0.7989869983155617f},
            {0.9530706002688482f, -0.30274813113077575f},
            {0.9521933864408199f, 0.3054959162057056f},
            {0.5990411927831463f, 0.8007182084534767f},
            {0.02426676659390367f, 0.9997055186599086f},
            {-0.5594854311637297f, 0.8288401850269662f},
            {-0.9362495088768715f, 0.3513358181680552f},
            {-0.9666372290646448f, -0.2561493068236286f},
            {-0.639406302430932f, -0.7688690268255078f},
            {-0.07561960309462855f, -0.9971367386812156f},
            {0.5161434448849468f, -0.8565021566244302f},
            {0.9169532430045485f, -0.39899467432967256f},
            {0.9785255608140186f, 0.20612551233074072f},
            {0.6780810056781368f, 0.7349871765810113f},
            {0.1267725231094102f, 0.9919318158948598f},
            {-0.4714369237563429f, 0.8818997828093372f},
            {-0.8952328164301424f, 0.4455987033043912f},
            {-0.9878269523583152f, -0.15555678125521535f},
            {-0.7149630577303816f, -0.6991622315892235f},
            {-0.1775902930268572f, -0.9841045106200027f},
            {0.42548405896433017f, -0.9049659195611945f},
            {0.8711456517157633f, -0.4910246974406867f},
            {0.9945168134929346f, 0.10457680278082451f},
            {0.7499549530475861f, 0.6614889027031315f},
            {0.2279385652761324f, 0.973675516001023f},
            {-0.37840633666951456f, 0.9256395866471777f},
            {-0.8447554283985693f, 0.535152563472464f},
            {-0.9985774581487236f, -0.05332035331122841f},
            {-0.782964183120542f, -0.6220667873712457f},
            {-0.27768423350317883f, -0.9606724033008089f},
            {0.3303282168323275f, -0.9438661288362745f},
            {0.8161319146404362f, -0.5778656400110114f},
            {0.9999981511488616f, 0.0019229401598916565f},
            {0.8139034810368312f, 0.5810001063305656f},
            {0.3266957844657079f, 0.945129549010259f},
            {-0.281376804176623f, 0.9595973603920294f},
            {-0.7853507827809703f, 0.6190510059642236f},
            {-0.9987751365895806f, 0.04947955669228112f},
            {-0.8426910521894434f, -0.538397428076926f},
            {-0.3748436457163809f, -0.9270880439667272f},
            {0.23168151216134933f, -0.9727916924617678f},
            {0.7524934092816089f, -0.6585997790674858f},
            {0.994911647769694f, -0.10075124382454212f},
            {0.8692507905181963f, 0.49437138184111223f},
            {0.42200052815510103f, 0.906595584721664f},
            {-0.18137372084857706f, 0.9834142430255637f},
            {-0.7176466595896562f, 0.6964074037370712f},
            {-0.9884178986426848f, 0.15175657363942827f},
            {-0.8935124797122745f, -0.4490383598295609f},
            {-0.46804176254479146f, -0.8837063474446503f},
            {0.1305864295723934f, -0.9914369291142702f},
            {0.6809026584910192f, -0.7323739274850399f},
            {0.9793110568139495f, -0.20236070271163187f},
            {0.9154119788419642f, 0.40251820951683553f},
            {0.5128456291010095f, 0.8584808446971836f},
            {-0.07945390532690727f, 0.9968385410528141f},
            {-0.6423585465587638f, 0.7664042651648753f},
            {-0.9676151981545856f, 0.2524298482752425f},
            {-0.934891391928828f, -0.35493391680336583f},
            {-0.5562936792840555f, -0.8309857654548652f},
            {0.028111327802940005f, -0.9996047985324779f},
            {0.6021162233413851f, -0.7984084503492602f},
            {0.9533612431517168f, -0.30183164190689693f},
            {0.9518992210060183f, 0.30641128087610536f},
            {0.5982710489428404f, 0.8012937988009351f},
            {0.023305567988262783f, 0.9997283883639319f},
            {-0.5602820779696569f, 0.8283018731754765f},
            {-0.9365868751635984f, 0.350435479469882f},
            {-0.9663905022641126f, -0.25707858163160174f},
            {-0.6386667619827179f, -0.7694834417572027f},
            {-0.07466085055928477f, -0.997208983811199f},
            {0.5169667078944292f, -0.8560055040294986f},
            {0.9173364407956793f, -0.3981128663938346f},
            {0.9783269249224673f, 0.2070662405409173f},
            {0.6773740237542967f, 0.7356387917605443f},
            {0.12581875131036094f, 0.9920532454554551f},
            {-0.47228462649872727f, 0.8814461024776034f},
            {-0.8956608326609128f, 0.44473775737749144f},
            {-0.9876769325119248f, -0.1565064758527096f},
            {-0.7142905033878327f, -0.6998493243334286f},
            {-0.17664402346250044f, -0.9842748035863661f},
            {0.4263539603573059f, -0.9045564108930083f},
            {0.8716173548343263f, -0.4901868896162075f},
            {0.994415806301039f, 0.1055329530462149f},
            {0.7493186043266098f, 0.6622096565363733f},
            {0.22700229961107984f, 0.9738942221675214f},
            {-0.37929613694395364f, 0.9252753322656957f},
            {-0.8452695713575256f, 0.5343401086733665f},
            {-0.998525730645293f, -0.054280431458156884f},
            {-0.7823657223441729f, -0.6228192968276437f},
            {-0.2767604469546231f, -0.9609389444712277f},
            {0.3312355636121689f, -0.943548091725339f},
            {0.8166871381936452f, -0.5770806861341607f},
            {0.999995840086541f, 0.0028844080178108454f},
            {0.8133444903632729f, 0.5817823819915036f},
            {0.325786919259646f, 0.9454432205263883f},
            {-0.28229929869789083f, 0.9593263813503092f},
            {-0.7859456190770135f, 0.6182956282019548f},
            {-0.998822248078154f, 0.04851924096791483f},
            {-0.8421730094292976f, -0.5392074018305016f},
            {-0.373952104631071f, -0.9274480165712753f},
            {0.23261671561379524f, -0.9725684878799286f},
            {0.7531262857443665f, -0.6578759744213911f},
            {0.9950080572599341f, -0.09979461903234838f},
            {0.8687750652275492f, 0.49520691234964365f},
            {0.42112866816879463f, 0.9070009067505816f},
            {-0.18231916082320707f, 0.9832394029923341f},
            {-0.7183159030757559f, 0.6957170857384928f},
            {-0.9885633512556217f, 0.15080616882029174f},
            {-0.893080329572006f, -0.44989723819063077f},
            {-0.46719188860459987f, -0.8841559473430393f},
            {0.1315396065977646f, -0.9913109158564256f},
            {0.681606499713117f, -0.7317189211362739f},
            {0.9795051680146997f, -0.20141903046260284f},
            {0.9150245463327793f, 0.40339816510302995f},
            {0.512019988029247f, 0.858973533852196f},
            {-0.08041229947705328f, 0.9967616877131729f},
            {-0.6430951247630602f, 0.7657863021143588f},
            {-0.9678574547689481f, 0.2514993981069807f},
            {-0.9345497013108786f, -0.35583262326513526f},
            {-0.5554944538383123f, -0.8315202413380417f},
            {0.02907240535928829f, -0.9995773082891715f},
            {0.6028835912268903f, -0.7978291643136192f},
            {0.9536510047228631f, -0.3009148736620934f},
            {0.9516041756110342f, 0.307326362292017f},
            {0.5975003520453519f, 0.8018686484117461f},
            {0.022344347838353967f, 0.9997503338932568f},
            {-0.5610782068363855f, 0.8277627956203795f},
            {-0.93692337564527f, 0.34953481682011633f},
            {-0.966142882107282f, -0.2580076187895127f},
            {-0.6379266311344768f, -0.7700971453585691f},
            {-0.0737020290055187f, -0.9972803070954874f},
            {0.5177894930065641f, -0.8555080601210051f},
            {0.9177187905773555f, -0.3972306904321919f},
            {0.978127384640281f, 0.20800677733372933f},
            {0.6766664156484392f, 0.7362897268966162f},
            {0.12486486320121397f, 0.9921737579364525f},
            {-0.47313189264902605f, 0.8809916073143662f},
            {-0.8960880209197166f, 0.4438764003235422f},
            {-0.9875259996315107f, -0.15745602577159645f},
            {-0.713617288736716f, -0.7005357701188843f},
            {-0.17569759060384005f, -0.9844441866637262f},
            {0.4272234676177009f, -0.9041460660295477f},
            {0.8720882522073408f, -0.48934862865031664f},
            {0.9943138798455315f, 0.1064890057542367f},
            {0.7486815629161868f, 0.6629297982059457f},
            {0.22606582409923492f, 0.9741120280410943f},
            {-0.3801855865872776f, 0.9249102225358349f},
            {-0.8457829329275041f, 0.5335271599164837f},
            {-0.9984730800789315f, -0.055240459426869205f},
            {-0.7817665383287496f, -0.6235712305338369f},
            {-0.2758364045615609f, -0.9612045973249145f},
            {0.3321426041893285f, -0.9432291823742155f},
            {0.8172416067802154f, -0.5762951987890336f},
            {0.9999926046022829f, 0.003845873209323106f},
            {0.8127847478130893f, 0.582564119837819f},
            {0.3248777528877428f, 0.9457560180504329f},
            {-0.2832215322544221f, 0.9590545154825441f},
            {-0.7865397288246715f, 0.6175396788712546f},
            {-0.9988684362296896f, 0.04755888039109703f},
            {-0.8416541881427008f, -0.5400168771268647f},
            {-0.37306021785478083f, -0.92780713181897f},
            {0.23355170402936554f, -0.9723443842307002f},
            {0.7537584659977772f, -0.6571515616177731f},
            {0.9951035469390707f, -0.09883790198744995f},
            {0.8682985368188393f, 0.4960419850761251f},
            {0.4202564188803024f, 0.90740539032447f}
    };
    /**
     * The 32 3D vertices of a rhombic triacontahedron. These were modified from values taken from Vladimir Bulatov's
     * stellation applet, which has available source but is unlicensed, and is
     * <a href="http://www.bulatov.org/polyhedra/stellation_applet/index.html">available here</a>, but the vertices are
     * mathematical constants so copyright isn't an issue.
     */
    protected static final float[][] grad3f =
            {
                    {-0.448549002408981f,  1.174316525459290f,  0.000000000000001f},
                    { 0.000000000000001f,  1.069324374198914f,  0.660878777503967f},
                    { 0.448549002408981f,  1.174316525459290f,  0.000000000000001f},
                    { 0.000000000000001f,  1.069324374198914f, -0.660878777503967f},
                    {-0.725767493247986f,  0.725767493247986f, -0.725767493247986f},
                    {-1.069324374198914f,  0.660878777503967f,  0.000000000000001f},
                    {-0.725767493247986f,  0.725767493247986f,  0.725767493247986f},
                    { 0.725767493247986f,  0.725767493247986f,  0.725767493247986f},
                    { 1.069324374198914f,  0.660878777503967f,  0.000000000000000f},
                    { 0.725767493247986f,  0.725767493247986f, -0.725767493247986f},
                    {-0.660878777503967f,  0.000000000000003f, -1.069324374198914f},
                    {-1.174316525459290f,  0.000000000000003f, -0.448549002408981f},
                    { 0.000000000000000f,  0.448549002408981f, -1.174316525459290f},
                    {-0.660878777503967f,  0.000000000000001f,  1.069324374198914f},
                    { 0.000000000000001f,  0.448549002408981f,  1.174316525459290f},
                    {-1.174316525459290f,  0.000000000000001f,  0.448549002408981f},
                    { 0.660878777503967f,  0.000000000000001f,  1.069324374198914f},
                    { 1.174316525459290f,  0.000000000000001f,  0.448549002408981f},
                    { 0.660878777503967f,  0.000000000000001f, -1.069324374198914f},
                    { 1.174316525459290f,  0.000000000000001f, -0.448549002408981f},
                    {-0.725767493247986f, -0.725767493247986f, -0.725767493247986f},
                    {-1.069324374198914f, -0.660878777503967f, -0.000000000000001f},
                    {-0.000000000000001f, -0.448549002408981f, -1.174316525459290f},
                    {-0.000000000000001f, -0.448549002408981f,  1.174316525459290f},
                    {-0.725767493247986f, -0.725767493247986f,  0.725767493247986f},
                    { 0.725767493247986f, -0.725767493247986f,  0.725767493247986f},
                    { 1.069324374198914f, -0.660878777503967f,  0.000000000000001f},
                    { 0.725767493247986f, -0.725767493247986f, -0.725767493247986f},
                    {-0.000000000000004f, -1.069324374198914f, -0.660878777503967f},
                    {-0.448549002408981f, -1.174316525459290f, -0.000000000000003f},
                    {-0.000000000000003f, -1.069324374198914f,  0.660878777503967f},
                    { 0.448549002408981f, -1.174316525459290f,  0.000000000000003f},
            };
    // these are the exact vertex positions, before scaling has been applied
//            {
//            {-0.324919696232904f,  0.850650808352036f,  0.000000000000001f },
//            { 0.000000000000001f,  0.850650808352035f,  0.525731112119131f },
//            { 0.324919696232906f,  0.850650808352036f,  0.000000000000001f },
//            { 0.000000000000001f,  0.850650808352036f, -0.525731112119131f },
//            {-0.525731112119131f,  0.525731112119132f, -0.525731112119130f },
//            {-0.850650808352035f,  0.525731112119132f,  0.000000000000001f },
//            {-0.525731112119130f,  0.525731112119131f,  0.525731112119132f },
//            { 0.525731112119132f,  0.525731112119131f,  0.525731112119131f },
//            { 0.850650808352036f,  0.525731112119132f,  0.000000000000000f },
//            { 0.525731112119132f,  0.525731112119132f, -0.525731112119131f },
//            {-0.525731112119132f,  0.000000000000002f, -0.850650808352036f },
//            {-0.850650808352036f,  0.000000000000002f, -0.324919696232905f },
//            { 0.000000000000000f,  0.324919696232906f, -0.850650808352037f },
//            {-0.525731112119131f,  0.000000000000001f,  0.850650808352037f },
//            { 0.000000000000001f,  0.324919696232905f,  0.850650808352037f },
//            {-0.850650808352037f,  0.000000000000001f,  0.324919696232905f },
//            { 0.525731112119133f,  0.000000000000001f,  0.850650808352036f },
//            { 0.850650808352037f,  0.000000000000001f,  0.324919696232905f },
//            { 0.525731112119132f,  0.000000000000001f, -0.850650808352038f },
//            { 0.850650808352038f,  0.000000000000001f, -0.324919696232906f },
//            {-0.525731112119134f, -0.525731112119130f, -0.525731112119133f },
//            {-0.850650808352038f, -0.525731112119130f, -0.000000000000001f },
//            {-0.000000000000001f, -0.324919696232905f, -0.850650808352038f },
//            {-0.000000000000001f, -0.324919696232905f,  0.850650808352038f },
//            {-0.525731112119132f, -0.525731112119131f,  0.525731112119133f },
//            { 0.525731112119133f, -0.525731112119131f,  0.525731112119134f },
//            { 0.850650808352039f, -0.525731112119130f,  0.000000000000001f },
//            { 0.525731112119132f, -0.525731112119134f, -0.525731112119133f },
//            {-0.000000000000003f, -0.850650808352038f, -0.525731112119134f },
//            {-0.324919696232908f, -0.850650808352038f, -0.000000000000002f },
//            {-0.000000000000002f, -0.850650808352042f,  0.525731112119130f },
//            { 0.324919696232902f, -0.850650808352041f,  0.000000000000002f }
//    };
    protected static final float[] grad3d =
            {
                    -0.448549002408981f,  1.174316525459290f,  0.000000000000001f,
                     0.000000000000001f,  1.069324374198914f,  0.660878777503967f,
                     0.448549002408981f,  1.174316525459290f,  0.000000000000001f,
                     0.000000000000001f,  1.069324374198914f, -0.660878777503967f,
                    -0.725767493247986f,  0.725767493247986f, -0.725767493247986f,
                    -1.069324374198914f,  0.660878777503967f,  0.000000000000001f,
                    -0.725767493247986f,  0.725767493247986f,  0.725767493247986f,
                     0.725767493247986f,  0.725767493247986f,  0.725767493247986f,
                     1.069324374198914f,  0.660878777503967f,  0.000000000000000f,
                     0.725767493247986f,  0.725767493247986f, -0.725767493247986f,
                    -0.660878777503967f,  0.000000000000003f, -1.069324374198914f,
                    -1.174316525459290f,  0.000000000000003f, -0.448549002408981f,
                     0.000000000000000f,  0.448549002408981f, -1.174316525459290f,
                    -0.660878777503967f,  0.000000000000001f,  1.069324374198914f,
                     0.000000000000001f,  0.448549002408981f,  1.174316525459290f,
                    -1.174316525459290f,  0.000000000000001f,  0.448549002408981f,
                     0.660878777503967f,  0.000000000000001f,  1.069324374198914f,
                     1.174316525459290f,  0.000000000000001f,  0.448549002408981f,
                     0.660878777503967f,  0.000000000000001f, -1.069324374198914f,
                     1.174316525459290f,  0.000000000000001f, -0.448549002408981f,
                    -0.725767493247986f, -0.725767493247986f, -0.725767493247986f,
                    -1.069324374198914f, -0.660878777503967f, -0.000000000000001f,
                    -0.000000000000001f, -0.448549002408981f, -1.174316525459290f,
                    -0.000000000000001f, -0.448549002408981f,  1.174316525459290f,
                    -0.725767493247986f, -0.725767493247986f,  0.725767493247986f,
                     0.725767493247986f, -0.725767493247986f,  0.725767493247986f,
                     1.069324374198914f, -0.660878777503967f,  0.000000000000001f,
                     0.725767493247986f, -0.725767493247986f, -0.725767493247986f,
                    -0.000000000000004f, -1.069324374198914f, -0.660878777503967f,
                    -0.448549002408981f, -1.174316525459290f, -0.000000000000003f,
                    -0.000000000000003f, -1.069324374198914f,  0.660878777503967f,
                     0.448549002408981f, -1.174316525459290f,  0.000000000000003f,
            };

    protected static final double[] grad4 =
            {
                    -0.5875167, 1.4183908, 1.4183908, 1.4183908,
                    -0.5875167, 1.4183908, 1.4183908, -1.4183908,
                    -0.5875167, 1.4183908, -1.4183908, 1.4183908,
                    -0.5875167, 1.4183908, -1.4183908, -1.4183908,
                    -0.5875167, -1.4183908, 1.4183908, 1.4183908,
                    -0.5875167, -1.4183908, 1.4183908, -1.4183908,
                    -0.5875167, -1.4183908, -1.4183908, 1.4183908,
                    -0.5875167, -1.4183908, -1.4183908, -1.4183908,
                    1.4183908, -0.5875167, 1.4183908, 1.4183908,
                    1.4183908, -0.5875167, 1.4183908, -1.4183908,
                    1.4183908, -0.5875167, -1.4183908, 1.4183908,
                    1.4183908, -0.5875167, -1.4183908, -1.4183908,
                    -1.4183908, -0.5875167, 1.4183908, 1.4183908,
                    -1.4183908, -0.5875167, 1.4183908, -1.4183908,
                    -1.4183908, -0.5875167, -1.4183908, 1.4183908,
                    -1.4183908, -0.5875167, -1.4183908, -1.4183908,
                    1.4183908, 1.4183908, -0.5875167, 1.4183908,
                    1.4183908, 1.4183908, -0.5875167, -1.4183908,
                    1.4183908, -1.4183908, -0.5875167, 1.4183908,
                    1.4183908, -1.4183908, -0.5875167, -1.4183908,
                    -1.4183908, 1.4183908, -0.5875167, 1.4183908,
                    -1.4183908, 1.4183908, -0.5875167, -1.4183908,
                    -1.4183908, -1.4183908, -0.5875167, 1.4183908,
                    -1.4183908, -1.4183908, -0.5875167, -1.4183908,
                    1.4183908, 1.4183908, 1.4183908, -0.5875167,
                    1.4183908, 1.4183908, -1.4183908, -0.5875167,
                    1.4183908, -1.4183908, 1.4183908, -0.5875167,
                    1.4183908, -1.4183908, -1.4183908, -0.5875167,
                    -1.4183908, 1.4183908, 1.4183908, -0.5875167,
                    -1.4183908, 1.4183908, -1.4183908, -0.5875167,
                    -1.4183908, -1.4183908, 1.4183908, -0.5875167,
                    -1.4183908, -1.4183908, -1.4183908, -0.5875167,
                    0.5875167, 1.4183908, 1.4183908, 1.4183908,
                    0.5875167, 1.4183908, 1.4183908, -1.4183908,
                    0.5875167, 1.4183908, -1.4183908, 1.4183908,
                    0.5875167, 1.4183908, -1.4183908, -1.4183908,
                    0.5875167, -1.4183908, 1.4183908, 1.4183908,
                    0.5875167, -1.4183908, 1.4183908, -1.4183908,
                    0.5875167, -1.4183908, -1.4183908, 1.4183908,
                    0.5875167, -1.4183908, -1.4183908, -1.4183908,
                    1.4183908, 0.5875167, 1.4183908, 1.4183908,
                    1.4183908, 0.5875167, 1.4183908, -1.4183908,
                    1.4183908, 0.5875167, -1.4183908, 1.4183908,
                    1.4183908, 0.5875167, -1.4183908, -1.4183908,
                    -1.4183908, 0.5875167, 1.4183908, 1.4183908,
                    -1.4183908, 0.5875167, 1.4183908, -1.4183908,
                    -1.4183908, 0.5875167, -1.4183908, 1.4183908,
                    -1.4183908, 0.5875167, -1.4183908, -1.4183908,
                    1.4183908, 1.4183908, 0.5875167, 1.4183908,
                    1.4183908, 1.4183908, 0.5875167, -1.4183908,
                    1.4183908, -1.4183908, 0.5875167, 1.4183908,
                    1.4183908, -1.4183908, 0.5875167, -1.4183908,
                    -1.4183908, 1.4183908, 0.5875167, 1.4183908,
                    -1.4183908, 1.4183908, 0.5875167, -1.4183908,
                    -1.4183908, -1.4183908, 0.5875167, 1.4183908,
                    -1.4183908, -1.4183908, 0.5875167, -1.4183908,
                    1.4183908, 1.4183908, 1.4183908, 0.5875167,
                    1.4183908, 1.4183908, -1.4183908, 0.5875167,
                    1.4183908, -1.4183908, 1.4183908, 0.5875167,
                    1.4183908, -1.4183908, -1.4183908, 0.5875167,
                    -1.4183908, 1.4183908, 1.4183908, 0.5875167,
                    -1.4183908, 1.4183908, -1.4183908, 0.5875167,
                    -1.4183908, -1.4183908, 1.4183908, 0.5875167,
                    -1.4183908, -1.4183908, -1.4183908, 0.5875167,
            };
//            {
//                    {-0.5875167f, 1.4183908f, 1.4183908f, 1.4183908f},
//                    {-0.5875167f, 1.4183908f, 1.4183908f, -1.4183908f},
//                    {-0.5875167f, 1.4183908f, -1.4183908f, 1.4183908f},
//                    {-0.5875167f, 1.4183908f, -1.4183908f, -1.4183908f},
//                    {-0.5875167f, -1.4183908f, 1.4183908f, 1.4183908f},
//                    {-0.5875167f, -1.4183908f, 1.4183908f, -1.4183908f},
//                    {-0.5875167f, -1.4183908f, -1.4183908f, 1.4183908f},
//                    {-0.5875167f, -1.4183908f, -1.4183908f, -1.4183908f},
//                    {1.4183908f, -0.5875167f, 1.4183908f, 1.4183908f},
//                    {1.4183908f, -0.5875167f, 1.4183908f, -1.4183908f},
//                    {1.4183908f, -0.5875167f, -1.4183908f, 1.4183908f},
//                    {1.4183908f, -0.5875167f, -1.4183908f, -1.4183908f},
//                    {-1.4183908f, -0.5875167f, 1.4183908f, 1.4183908f},
//                    {-1.4183908f, -0.5875167f, 1.4183908f, -1.4183908f},
//                    {-1.4183908f, -0.5875167f, -1.4183908f, 1.4183908f},
//                    {-1.4183908f, -0.5875167f, -1.4183908f, -1.4183908f},
//                    {1.4183908f, 1.4183908f, -0.5875167f, 1.4183908f},
//                    {1.4183908f, 1.4183908f, -0.5875167f, -1.4183908f},
//                    {1.4183908f, -1.4183908f, -0.5875167f, 1.4183908f},
//                    {1.4183908f, -1.4183908f, -0.5875167f, -1.4183908f},
//                    {-1.4183908f, 1.4183908f, -0.5875167f, 1.4183908f},
//                    {-1.4183908f, 1.4183908f, -0.5875167f, -1.4183908f},
//                    {-1.4183908f, -1.4183908f, -0.5875167f, 1.4183908f},
//                    {-1.4183908f, -1.4183908f, -0.5875167f, -1.4183908f},
//                    {1.4183908f, 1.4183908f, 1.4183908f, -0.5875167f},
//                    {1.4183908f, 1.4183908f, -1.4183908f, -0.5875167f},
//                    {1.4183908f, -1.4183908f, 1.4183908f, -0.5875167f},
//                    {1.4183908f, -1.4183908f, -1.4183908f, -0.5875167f},
//                    {-1.4183908f, 1.4183908f, 1.4183908f, -0.5875167f},
//                    {-1.4183908f, 1.4183908f, -1.4183908f, -0.5875167f},
//                    {-1.4183908f, -1.4183908f, 1.4183908f, -0.5875167f},
//                    {-1.4183908f, -1.4183908f, -1.4183908f, -0.5875167f},
//                    {0.5875167f, 1.4183908f, 1.4183908f, 1.4183908f},
//                    {0.5875167f, 1.4183908f, 1.4183908f, -1.4183908f},
//                    {0.5875167f, 1.4183908f, -1.4183908f, 1.4183908f},
//                    {0.5875167f, 1.4183908f, -1.4183908f, -1.4183908f},
//                    {0.5875167f, -1.4183908f, 1.4183908f, 1.4183908f},
//                    {0.5875167f, -1.4183908f, 1.4183908f, -1.4183908f},
//                    {0.5875167f, -1.4183908f, -1.4183908f, 1.4183908f},
//                    {0.5875167f, -1.4183908f, -1.4183908f, -1.4183908f},
//                    {1.4183908f, 0.5875167f, 1.4183908f, 1.4183908f},
//                    {1.4183908f, 0.5875167f, 1.4183908f, -1.4183908f},
//                    {1.4183908f, 0.5875167f, -1.4183908f, 1.4183908f},
//                    {1.4183908f, 0.5875167f, -1.4183908f, -1.4183908f},
//                    {-1.4183908f, 0.5875167f, 1.4183908f, 1.4183908f},
//                    {-1.4183908f, 0.5875167f, 1.4183908f, -1.4183908f},
//                    {-1.4183908f, 0.5875167f, -1.4183908f, 1.4183908f},
//                    {-1.4183908f, 0.5875167f, -1.4183908f, -1.4183908f},
//                    {1.4183908f, 1.4183908f, 0.5875167f, 1.4183908f},
//                    {1.4183908f, 1.4183908f, 0.5875167f, -1.4183908f},
//                    {1.4183908f, -1.4183908f, 0.5875167f, 1.4183908f},
//                    {1.4183908f, -1.4183908f, 0.5875167f, -1.4183908f},
//                    {-1.4183908f, 1.4183908f, 0.5875167f, 1.4183908f},
//                    {-1.4183908f, 1.4183908f, 0.5875167f, -1.4183908f},
//                    {-1.4183908f, -1.4183908f, 0.5875167f, 1.4183908f},
//                    {-1.4183908f, -1.4183908f, 0.5875167f, -1.4183908f},
//                    {1.4183908f, 1.4183908f, 1.4183908f, 0.5875167f},
//                    {1.4183908f, 1.4183908f, -1.4183908f, 0.5875167f},
//                    {1.4183908f, -1.4183908f, 1.4183908f, 0.5875167f},
//                    {1.4183908f, -1.4183908f, -1.4183908f, 0.5875167f},
//                    {-1.4183908f, 1.4183908f, 1.4183908f, 0.5875167f},
//                    {-1.4183908f, 1.4183908f, -1.4183908f, 0.5875167f},
//                    {-1.4183908f, -1.4183908f, 1.4183908f, 0.5875167f},
//                    {-1.4183908f, -1.4183908f, -1.4183908f, 0.5875167f},
//            };

//            {
//            {0.30521256f, -0.57729936f, 0.74470073f, -0.1378101f},
//            {-0.5383342f, 0.3682797f, -0.23693705f, 0.72001886f},
//            {0.31043372f, -0.5214427f, 0.7939059f, -0.037971545f},
//            {-0.34612554f, -0.7475893f, -0.14619884f, -0.5476616f},
//            {0.110175654f, -0.16491795f, 0.98012143f, -0.0050395187f},
//            {-0.49306902f, 0.4408067f, -0.14981277f, 0.7349344f},
//            {0.2921113f, -0.32707158f, -0.8987039f, 0.0051501133f},
//            {-0.24382289f, -0.54576886f, 0.71103907f, -0.3702839f},
//            {0.42851725f, -0.3674791f, 0.8249214f, 0.028925087f},
//            {0.6411811f, -0.6337662f, -0.070845254f, -0.42685845f},
//            {-0.85398096f, -0.1840277f, 0.4859245f, 0.026975961f},
//            {-0.37726673f, 0.4666541f, -0.096711665f, 0.79407215f},
//            {0.16541202f, 0.60646987f, -0.3924725f, -0.67141527f},
//            {-0.2106679f, 0.30791336f, 0.799212f, 0.4712416f},
//            {0.4371983f, -0.26759f, 0.8468081f, 0.1420189f},
//            {-0.20061846f, 0.31516862f, -0.85302573f, -0.3643735f},
//            {-0.43534753f, -0.06332874f, 0.8964169f, 0.05384f},
//            {-0.3837288f, 0.6487092f, -0.0042441157f, -0.657199f},
//            {0.19373763f, -0.061797444f, -0.9769146f, 0.06545838f},
//            {-0.7183736f, 0.23978147f, 0.6111837f, -0.2299971f},
//            {0.2960002f, -0.08083333f, -0.45766684f, -0.8345004f},
//            {-0.25097045f, -0.80887955f, 0.026866198f, -0.5310422f},
//            {-0.53422993f, 0.7232398f, 0.4211347f, 0.11903002f},
//            {0.55193734f, -0.36371425f, -0.61939865f, 0.42358282f},
//            {-0.43355975f, 0.63322467f, -0.30332342f, -0.5648428f},
//            {0.71517783f, 0.38801393f, 0.060850836f, 0.5781548f},
//            {0.2987888f, -0.82676244f, 0.45530754f, 0.14101125f},
//            {-0.13143522f, 0.43352097f, -0.8460369f, -0.28107986f},
//            {0.27406123f, -0.0061683212f, 0.43692502f, 0.85670817f},
//            {-0.17194793f, 0.82895166f, 0.16079327f, -0.5073643f},
//            {0.26733503f, 0.0014139203f, -0.9508974f, 0.15596196f},
//            {-0.063544184f, -0.33980247f, 0.7871041f, 0.51084584f},
//            {0.45355868f, 0.013269774f, -0.39320785f, -0.79968494f},
//            {-0.14271542f, -0.84682304f, 0.2664987f, -0.43760887f},
//            {-0.631048f, 0.06282108f, 0.7201872f, 0.28135782f},
//            {0.6872453f, -0.33575317f, -0.6214131f, -0.16973351f},
//            {-0.7943215f, 0.09599423f, -0.46707594f, 0.3764021f},
//            {-0.02583059f, 0.5708325f, 0.1725252f, 0.8023204f},
//            {0.36104593f, -0.7183975f, -0.2417964f, -0.54321754f},
//            {-0.62640476f, -0.24817976f, 0.727577f, -0.12905663f},
//            {0.5240908f, 0.09631077f, 0.77270806f, 0.344928f},
//            {-0.004417861f, -0.43781736f, -0.8712169f, -0.2219855f},
//            {-0.52296543f, 0.10600555f, 0.76990277f, 0.35002825f},
//            {0.014057253f, -0.8063729f, 0.4908759f, -0.32955426f},
//            {0.5829141f, 0.15523833f, -0.3080137f, -0.73569f},
//            {0.013204535f, -0.28376737f, 0.9523351f, -0.1111738f},
//            {-0.720573f, 0.23616794f, -0.3689131f, 0.5374964f},
//            {0.060347114f, 0.64367414f, -0.7508531f, -0.13513494f},
//            {-0.28348896f, 0.7306394f, 0.4869968f, -0.38553104f},
//            {0.060365494f, -0.2707644f, -0.6018939f, 0.7488434f},
//            {-0.5243532f, 0.22156887f, -0.27637747f, -0.7743232f},
//            {-0.5711214f, 0.43126655f, 0.19044453f, -0.67198247f},
//            {-0.31680956f, -0.62567914f, 0.6342563f, 0.32538632f},
//            {0.06309463f, 0.48411465f, -0.46944404f, -0.73571354f},
//            {-0.25846493f, 0.1508792f, -0.108005695f, 0.94803274f},
//            {0.29359144f, -0.6216346f, 0.7143707f, -0.13057186f},
//            {0.30669925f, 0.11621855f, -0.5659279f, -0.7564089f},
//            {-0.4579672f, -0.12977019f, 0.71692353f, 0.5093588f},
//            {0.72682136f, 0.2829506f, -0.16092123f, -0.60479254f},
//            {0.094798625f, -0.14094533f, -0.9851869f, -0.023545148f},
//            {-0.19733784f, 0.7687776f, 0.5319371f, 0.2950961f},
//            {0.8743509f, -0.1656985f, -0.45611945f, 0.0030883756f},
//            {-0.33973676f, -0.7613095f, -0.12979484f, 0.5367868f},
//            {-0.66581863f, 0.66475755f, 0.33856988f, 0.012382605f},
//            {0.6316928f, -0.62325597f, -0.06916507f, 0.4557767f},
//            {-0.86808014f, -0.18651712f, 0.45919082f, 0.028143227f},
//            {0.7435046f, 0.33720765f, -0.069088265f, 0.57334f},
//            {0.17722823f, -0.89015186f, -0.41887683f, 0.02760538f},
//            {-0.40754265f, 0.54529834f, -0.09077789f, -0.7268549f},
//            {0.4377619f, -0.26609203f, 0.8468283f, 0.14297345f},
//            {-0.2980038f, -0.7838384f, -0.05605936f, -0.5418934f},
//            {0.41718817f, -0.22535361f, -0.86789536f, 0.14807884f},
//            {-0.31047124f, 0.52717996f, -0.0025840108f, 0.7910008f},
//            {0.48056296f, -0.20454551f, -0.8370399f, 0.16304804f},
//            {-0.1726224f, -0.48157752f, 0.80440617f, -0.30201873f},
//            {-0.80258685f, -0.09523491f, 0.5749053f, 0.12754847f},
//            {0.82261246f, 0.421295f, 0.019977508f, -0.38133997f},
//            {-0.7746771f, -0.08136189f, 0.6119533f, 0.13699931f},
//            {-0.2080354f, 0.53238916f, 0.038112316f, 0.8196527f},
//            {0.3244066f, -0.060978226f, -0.44636208f, -0.8317469f},
//            {-0.22975878f, -0.8135528f, 0.10953062f, -0.5228248f},
//            {-0.7301818f, -0.05867752f, 0.65011483f, 0.20184688f},
//            {-0.08505362f, 0.28215852f, -0.54953223f, -0.78177154f},
//            {-0.7179047f, -0.009138507f, 0.6623404f, 0.21409011f},
//            {-0.2239077f, 0.8207485f, 0.16006742f, -0.5006153f},
//            {0.26869303f, 0.0018523374f, -0.9537537f, 0.13473849f},
//            {-0.6122548f, 0.2766686f, 0.6212354f, 0.40331778f},
//            {0.85527843f, 0.008107095f, -0.22845533f, -0.46501747f},
//            {-0.13990346f, -0.83571506f, 0.20660898f, -0.4892035f},
//            {-0.43144038f, 0.7503387f, 0.46641788f, 0.18249781f},
//            {0.6109145f, -0.29784846f, -0.5516091f, 0.48352572f},
//            {-0.5537214f, 0.034945432f, -0.35802394f, -0.75099283f},
//            {-0.05817811f, 0.5701312f, 0.17276435f, 0.80107313f},
//            {0.37052378f, -0.7357565f, 0.5243631f, 0.21544799f},
//            {-0.029430708f, 0.3613586f, -0.5237315f, -0.77088195f},
//            {0.33915582f, 0.06269238f, -0.21377106f, 0.9139721f},
//            {-0.0069569536f, -0.8187294f, 0.3973037f, -0.41446778f},
//            {0.73752713f, 0.1494311f, -0.4386642f, 0.49122077f},
//            {0.007840344f, -0.41011772f, 0.25074953f, 0.8768504f},
//            {0.5866233f, 0.12097919f, -0.3089065f, -0.7387922f},
//            {0.038346753f, -0.7936974f, 0.5219132f, -0.31012994f},
//            {-0.48829433f, 0.1609236f, 0.77598804f, 0.36539677f},
//            {0.77487123f, -0.27046844f, -0.56236655f, -0.100822724f},
//            {-0.43294445f, -0.8055559f, -0.21639013f, 0.3417808f},
//            {0.06327453f, 0.57862145f, 0.23459785f, 0.7785611f},
//            {0.47261932f, -0.6973982f, -0.18080638f, -0.50751925f},
//            {-0.57226986f, -0.19045952f, 0.79454595f, -0.07020757f},
//            {0.75739795f, 0.24353026f, -0.2703368f, 0.5421802f},
//            {0.09329002f, 0.71155983f, -0.6887454f, -0.10300197f},
//            {-0.3835674f, 0.19288845f, 0.80135345f, 0.4165366f},
//            {0.22881314f, -0.63167685f, 0.72891444f, -0.13157767f},
//            {0.69621545f, 0.26425454f, -0.20363748f, -0.6355984f},
//            {-0.5298094f, -0.16983661f, 0.83038956f, -0.030177508f},
//            {-0.5203182f, 0.35296547f, -0.19933324f, -0.751632f},
//            {0.22063582f, -0.3258306f, -0.9177535f, -0.053691696f},
//            {-0.27172714f, -0.5687724f, 0.6676368f, -0.39613563f},
//            {0.1415665f, -0.18683445f, -0.5152346f, 0.82436955f},
//            {-0.46999532f, 0.40541205f, -0.17897326f, -0.7633571f},
//            {-0.6798877f, 0.65324455f, 0.33296168f, 0.012679209f},
//            {0.6305932f, -0.6210434f, -0.09748693f, 0.4551413f},
//            {0.13408749f, 0.5705748f, -0.41801533f, -0.6940664f},
//            {-0.18411608f, 0.20425196f, -0.04136734f, 0.9605577f},
//            {0.44455504f, -0.36305627f, 0.8158576f, 0.07026641f},
//            {0.36841255f, 0.17022495f, -0.5395205f, -0.73770815f},
//            {-0.39160624f, -0.07530158f, 0.74071103f, 0.5406676f},
//            {0.7973144f, 0.3746133f, -0.04808778f, -0.47078887f},
//            {0.16265045f, -0.087234035f, -0.9821154f, 0.03720781f},
//            {-0.6909652f, -0.34583774f, 0.5445337f, 0.32626122f},
//            {0.920368f, -0.09085865f, -0.37323156f, 0.073250644f},
//            {-0.28366125f, -0.7928303f, 0.012259258f, -0.53926444f},
//            {-0.56178755f, 0.7167111f, 0.4032907f, 0.08986991f},
//            {0.55126f, -0.41108644f, -0.6798098f, -0.25490978f},
//            {-0.79137385f, -0.08246414f, 0.5891518f, 0.1408093f},
//            {0.7238841f, 0.3756506f, 0.027417112f, 0.57803696f},
//            {0.27134395f, -0.8808191f, -0.37211046f, 0.10983609f},
//            {-0.26500604f, 0.7478573f, 0.07171241f, -0.60443246f},
//            {0.4955693f, -0.073575415f, 0.82634485f, 0.25720012f},
//            {-0.21931332f, -0.8208177f, 0.08023434f, -0.52127004f},
//            {0.59726536f, -0.06780095f, -0.7328664f, 0.3187223f},
//            {-0.15090077f, -0.5983029f, 0.1091213f, 0.77932996f},
//            {0.34171078f, 0.84924453f, -0.36408985f, 0.17162769f},
//            {-0.09574758f, -0.4046576f, 0.8811375f, -0.22512527f},
//            {-0.689211f, 0.016008975f, 0.68412775f, 0.23811999f},
//            {-0.07317587f, 0.4764447f, -0.8375025f, -0.25736237f},
//            {-0.51277226f, 0.021356434f, 0.5554851f, -0.6542513f},
//            {-0.07586732f, -0.5166669f, 0.14364976f, 0.8406332f},
//            {0.4579639f, 0.038025483f, -0.38191295f, -0.8018514f},
//            {-0.103942715f, -0.82185036f, 0.3132923f, -0.4643337f},
//            {-0.5998191f, 0.051231254f, 0.73843443f, 0.30382064f},
//            {-0.029040387f, 0.3618993f, -0.5235325f, -0.77077836f},
//            {-0.2932128f, -0.50995934f, 0.3741883f, 0.7169036f},
//            {0.88662016f, -0.3880005f, 0.17477578f, -0.18114574f},
//            {0.34472477f, 0.070200406f, -0.9129205f, 0.20691285f},
//            {-0.5353782f, 0.31744298f, 0.6480155f, 0.43894878f},
//            {0.5632882f, 0.12426364f, -0.31476036f, -0.75378436f},
//            {0.020805571f, -0.4152704f, -0.88762134f, -0.19810592f},
//            {-0.33548284f, 0.76334757f, 0.49935544f, 0.23536326f},
//            {0.65878147f, -0.22940378f, -0.47741848f, 0.5342775f},
//            {-0.53736955f, 0.15640032f, -0.30673102f, -0.76986295f},
//            {0.055417743f, 0.91139966f, 0.37004194f, -0.17131379f},
//            {0.5169996f, -0.7614511f, -0.19698289f, 0.33778897f},
//            {-0.56972605f, 0.4115734f, 0.17101042f, -0.69048893f},
//            {0.75742745f, 0.24410513f, -0.26921594f, 0.5424381f},
//            {0.069828235f, -0.97122616f, 0.2145969f, -0.0761047f},
//            {0.67210144f, 0.22488956f, -0.2223229f, -0.6695348f},
//            {0.10232841f, -0.2801582f, 0.32462245f, 0.897586f},
//            {-0.51016176f, 0.27948615f, -0.24764954f, -0.7747852f},
//            {0.15745331f, -0.37653404f, -0.91052145f, -0.06619125f},
//            {-0.35133055f, 0.23934884f, 0.79895335f, 0.42538512f},
//            {0.84832406f, -0.19804582f, -0.4902316f, -0.028233642f},
//            {-0.3739194f, -0.7834053f, -0.13593386f, 0.47747502f},
//            {0.19779265f, 0.8825428f, 0.42543244f, -0.03167734f},
//            {0.7468733f, 0.30633524f, -0.1342039f, -0.57474196f},
//            {-0.88764054f, -0.2259622f, 0.4009076f, -0.017564435f},
//            {-0.45524576f, 0.4243537f, -0.16282937f, 0.76561207f},
//            {0.18682976f, 0.7929761f, -0.5798725f, -0.0056133526f},
//            {-0.22737576f, -0.53136384f, 0.70865744f, 0.4046694f},
//            {0.39352816f, -0.37106863f, 0.8378966f, 0.073300704f},
//            {-0.22612447f, 0.27001774f, -0.8536839f, -0.38364306f},
//            {-0.84863514f, -0.19870402f, 0.48731726f, 0.053450614f},
//            {-0.43688715f, 0.5594756f, -0.07066281f, -0.700802f},
//            {0.40344277f, -0.2148357f, -0.88454413f, 0.09306541f},
//            {-0.19478711f, -0.48726425f, 0.73013085f, 0.43765336f},
//            {0.9219448f, -0.09051001f, -0.37322578f, 0.05028156f},
//            {-0.36481073f, 0.61899686f, -0.03775136f, -0.6945004f},
//            {-0.81090957f, -0.12670651f, 0.5574955f, 0.12477961f},
//            {0.68599266f, -0.51061195f, -0.010075784f, 0.51825476f},
//            {0.2066314f, 0.65144634f, -0.35600528f, -0.6373236f},
//            {-0.11573376f, 0.24965633f, 0.01856937f, 0.9612141f},
//            {0.51501304f, -0.14515176f, 0.81852716f, 0.20905946f},
//            {-0.106857784f, 0.24998063f, -0.55821455f, -0.78389263f},
//            {-0.4754182f, -0.035513934f, -0.31372645f, 0.82115287f},
//            {-0.24548152f, 0.7675945f, 0.09130737f, -0.584979f},
//            {0.3544801f, -0.039527472f, -0.43353555f, -0.8275436f},
//            {-0.63865834f, -0.29244968f, 0.6007099f, 0.3817543f},
//            {0.8324249f, -0.017320063f, -0.2546005f, -0.4918815f},
//            {-0.19354364f, -0.8212621f, 0.17127427f, -0.50865954f},
//            {-0.45606834f, 0.7491067f, 0.45366144f, 0.1582155f},
//            {0.6473732f, -0.36053053f, -0.6419752f, -0.1969605f},
//            {-0.51058674f, 0.021834841f, 0.5262477f, -0.6796233f},
//            {0.70401603f, 0.4015401f, 0.09906377f, 0.5773329f},
//            {0.37328795f, -0.85070235f, -0.31028062f, 0.20171149f},
//            {-0.87026936f, 0.43279198f, 0.1133502f, -0.20609237f},
//            {0.7032974f, 0.07507336f, -0.5531491f, 0.44018495f},
//            {-0.07064539f, 0.89369893f, 0.23307832f, -0.37681022f},
//            {0.7119635f, 0.09115333f, -0.5296553f, 0.45195612f},
//            {-0.038092706f, -0.4684961f, 0.21205f, 0.8567935f},
//            {0.52836746f, 0.10814144f, -0.34704006f, -0.76726556f},
//            {-0.047906272f, -0.83101475f, 0.4072192f, -0.3758883f},
//            {-0.7631498f, 0.16756177f, -0.42105612f, 0.46069202f},
//            {0.019005984f, 0.5960935f, -0.78351843f, -0.17438526f},
//            {-0.44480333f, 0.1093444f, 0.66349167f, -0.5915848f},
//            {0.031733893f, -0.3822001f, 0.23787121f, 0.8923751f},
//            {0.5928739f, 0.15020806f, -0.29245773f, -0.7351235f},
//            {-0.709945f, -0.25679013f, 0.1963655f, 0.6256816f},
//            {0.77101755f, 0.1949857f, -0.33680996f, 0.5040551f},
//            {0.034284342f, 0.44709295f, -0.48786792f, -0.7489442f},
//            {-0.23434283f, -0.446607f, 0.41925618f, 0.754884f},
//            {0.9220484f, -0.28314397f, 0.248978f, -0.087556966f},
//            {0.39542305f, 0.13259506f, -0.8086393f, -0.41492364f},
//            {-0.48490062f, -0.17072529f, 0.70224714f, 0.4925172f},
//            {0.6847746f, 0.23774141f, -0.20929065f, -0.65632325f},
//            {0.15174845f, -0.36007288f, -0.91447014f, -0.10518683f},
//            {-0.66364074f, 0.5920555f, 0.40352282f, 0.2149897f},
//            {0.8487449f, -0.19755904f, -0.48972642f, -0.027757192f},
//            {-0.2725929f, -0.57164645f, 0.64824593f, -0.42271817f},
//            {-0.7204641f, 0.62428117f, 0.30120832f, -0.021864176f},
//            {0.42192665f, -0.46847096f, -0.71710336f, 0.29711226f},
//            {-0.5278077f, 0.48799595f, 0.23897435f, -0.65281713f},
//            {-0.4915112f, 0.415481f, -0.15813626f, 0.74885595f},
//            {0.14896473f, -0.9420127f, 0.30067563f, -0.0039662635f},
//            {0.40879646f, 0.17541802f, -0.05796071f, -0.8937307f},
//            {0.17770523f, -0.16647717f, 0.37773693f, 0.8933202f},
//            {-0.44056776f, 0.47730166f, -0.13542879f, -0.7481592f},
//            {0.18475258f, -0.15509109f, -0.49493393f, -0.8347776f},
//            {-0.23192436f, 0.29824346f, 0.80051947f, 0.4652209f},
//            {0.7728951f, 0.5276986f, -0.35039353f, 0.037305843f},
//            {-0.2907823f, -0.728466f, -0.036409806f, 0.6192393f},
//            {-0.8384365f, -0.14058013f, 0.520564f, 0.0792124f},
//            {0.54468423f, 0.26451725f, -0.73881125f, -0.29581678f},
//            {-0.8132668f, -0.12647997f, -0.56083083f, 0.08982565f},
//            {-0.27625933f, 0.5097125f, -0.01496917f, 0.8146471f},
//            {0.27182457f, -0.097434245f, -0.46669307f, -0.83595186f},
//            {-0.266864f, -0.8014467f, -6.421754E-4f, -0.5352255f},
//            {0.4766369f, -0.14767133f, 0.83947283f, 0.2151646f},
//            {-0.16173786f, 0.380226f, -0.8472566f, -0.33380434f},
//            {-0.46358418f, -0.056809172f, 0.3725527f, 0.8019145f},
//            {0.8303505f, 0.44172588f, 0.05310078f, -0.33552432f},
//            {0.5844279f, -0.063998416f, -0.7663617f, 0.25891706f},
//            {-0.11677986f, -0.3966828f, 0.76837516f, 0.48847187f},
//            {0.6264683f, -0.04814682f, -0.722762f, 0.28780982f},
//            {-0.109266914f, 0.42441288f, -0.851426f, -0.28811142f},
//            {-0.70631105f, -0.019139754f, 0.668031f, 0.23343737f},
//            {0.71994025f, -0.4001531f, 0.068379015f, 0.5629279f},
//            {-0.5569895f, -0.006145278f, -0.37386537f, -0.7415859f},
//            {-0.17033575f, -0.846144f, 0.22243054f, -0.45337692f},
//    };
//    public static void randomUnitVector4(long seed, final float[] vector)
//    {
//        double mag = 0.0;
//        float t;
//        vector[0] = (t = NumberTools.formCurvedFloat(seed += 0xCB72F6C7));
//        mag += t * t;
//        vector[1] = (t = NumberTools.formCurvedFloat(seed += 0xCB72F6C7));
//        mag += t * t;
//        vector[2] = (t = NumberTools.formCurvedFloat(seed += 0xCB72F6C7));
//        mag += t * t;
//        vector[3] = (t = NumberTools.formCurvedFloat(seed + 0xCB72F6C7));
//        mag += t * t;
//
//        if(mag == 0)
//        {
//            vector[0] = 1f;
//            mag = 1.0;
//        }
//        else
//            mag = Math.sqrt(mag);
//        vector[0] /= mag;
//        vector[1] /= mag;
//        vector[2] /= mag;
//        vector[3] /= mag;
//    }

//    static {
//        final float len = (float) (1.7861513777574233 / Math.sqrt(3.0));
//        for (int i = 0; i < 64; i++) {
////            float x = grad4f[i][0], y = grad4f[i][1], z = grad4f[i][2], w = grad4f[i][3];
////            final float len = 1.4142135623730951f / (float)Math.sqrt(x * x + y * y + z * z + w * w);
//            //final float len = 2f / Math.max(Math.abs(x), Math.max(Math.abs(y), Math.abs(z))), len3 = len * 1.5f;
//            grad4f[i][0] *= len;
//            grad4f[i][1] *= len;
//            grad4f[i][2] *= len;
//            grad4f[i][3] *= len;
//            System.out.println("{" + squidpony.StringKit.join(", ", grad4f[i]) + "},");
//        }
//    }

//    protected static final float[][] phiGrad3f = new float[96][3];
//
//    static {
//        final float root2 = 1.2599211f;
//        int i = 0;
//        for (; i < 16; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][0] * root2;
//            phiGrad3f[i][1] = phiGrad2f[i & 15][1] * root2;
//        }
//        for (; i < 32; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][1] * root2;
//            phiGrad3f[i][1] = phiGrad2f[i & 15][0] * root2;
//        }
//        for (; i < 48; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][0] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][1] * root2;
//        }
//        for (; i < 64; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][1] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][0] * root2;
//        }
//        for (; i < 80; i++) {
//            phiGrad3f[i][1] = phiGrad2f[i & 15][0] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][1] * root2;
//        }
//        for (; i < 96; i++) {
//            phiGrad3f[i][1] = phiGrad2f[i & 15][1] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][0] * root2;
//        }
//    }

//    public static final int[]
//            perm_x = {59, 146, 27, 99, 226, 210, 44, 129, 102, 237, 2, 107, 157, 173, 159, 16, 128, 41, 228, 114, 63, 105, 241, 144, 187, 116, 223, 122, 234, 52, 96, 35, 213, 176, 177, 141, 132, 240, 194, 163, 0, 3, 168, 133, 55, 203, 53, 50, 42, 79, 130, 156, 209, 135, 151, 178, 85, 154, 117, 148, 140, 82, 6, 69, 127, 214, 95, 175, 46, 30, 104, 197, 170, 33, 70, 167, 217, 233, 219, 84, 196, 109, 40, 190, 123, 165, 61, 212, 255, 184, 19, 182, 38, 112, 172, 103, 25, 244, 245, 201, 192, 60, 14, 231, 68, 71, 236, 193, 115, 7, 113, 118, 110, 131, 198, 216, 29, 195, 211, 246, 153, 222, 185, 208, 200, 158, 66, 137, 179, 26, 147, 235, 106, 90, 164, 9, 238, 101, 138, 227, 21, 37, 23, 152, 8, 161, 108, 250, 183, 225, 121, 24, 51, 252, 87, 242, 98, 188, 232, 171, 93, 56, 57, 5, 12, 120, 74, 43, 136, 139, 32, 13, 191, 67, 189, 186, 162, 199, 10, 20, 89, 15, 31, 58, 221, 18, 253, 28, 4, 218, 142, 205, 247, 94, 215, 39, 166, 150, 224, 77, 34, 169, 206, 47, 81, 97, 83, 220, 76, 229, 160, 54, 243, 45, 181, 92, 119, 48, 155, 62, 174, 248, 36, 239, 145, 124, 125, 65, 72, 180, 134, 111, 204, 207, 100, 73, 251, 143, 249, 254, 230, 11, 78, 80, 149, 75, 91, 126, 17, 86, 49, 88, 64, 22, 202, 1},
//            perm_y = {189, 111, 17, 214, 57, 208, 191, 225, 241, 152, 145, 71, 2, 141, 183, 218, 66, 178, 34, 161, 198, 47, 200, 180, 134, 239, 162, 18, 155, 216, 192, 173, 219, 9, 51, 124, 95, 122, 217, 135, 31, 50, 179, 237, 32, 39, 209, 112, 96, 92, 68, 79, 228, 193, 234, 90, 164, 137, 196, 184, 185, 114, 226, 67, 249, 163, 85, 26, 125, 28, 251, 45, 61, 220, 213, 139, 70, 201, 243, 22, 142, 246, 102, 229, 10, 107, 4, 240, 194, 35, 230, 86, 223, 20, 12, 233, 23, 77, 119, 176, 147, 182, 21, 195, 91, 118, 247, 33, 100, 99, 29, 188, 172, 144, 136, 131, 40, 13, 38, 150, 224, 205, 8, 252, 253, 190, 46, 143, 53, 231, 153, 94, 177, 88, 55, 105, 121, 16, 25, 207, 138, 5, 63, 82, 202, 58, 170, 41, 78, 167, 64, 60, 14, 103, 42, 154, 19, 80, 72, 37, 83, 129, 187, 244, 215, 242, 81, 15, 151, 186, 59, 101, 168, 175, 89, 248, 232, 212, 204, 199, 108, 73, 98, 210, 44, 1, 76, 48, 49, 250, 106, 203, 113, 43, 221, 146, 245, 148, 115, 165, 181, 84, 93, 3, 206, 65, 123, 158, 6, 126, 238, 109, 130, 227, 140, 120, 74, 171, 110, 222, 87, 156, 132, 97, 159, 197, 255, 56, 27, 62, 157, 75, 211, 254, 127, 169, 236, 235, 149, 52, 36, 24, 0, 11, 160, 133, 174, 30, 104, 69, 128, 116, 117, 54, 166, 7},
//            perm_z = {253, 212, 4, 237, 36, 182, 213, 233, 147, 239, 226, 41, 74, 65, 68, 165, 70, 231, 217, 116, 113, 193, 162, 112, 228, 254, 183, 176, 151, 80, 17, 60, 155, 246, 174, 3, 202, 208, 127, 7, 57, 1, 132, 79, 224, 99, 238, 195, 236, 9, 115, 154, 23, 227, 76, 158, 130, 16, 89, 214, 61, 114, 187, 90, 49, 24, 64, 33, 96, 242, 25, 37, 215, 35, 46, 109, 134, 141, 136, 225, 138, 43, 21, 184, 189, 13, 230, 188, 40, 50, 243, 244, 211, 156, 85, 120, 223, 58, 234, 71, 6, 28, 179, 67, 125, 69, 192, 131, 44, 175, 34, 15, 32, 77, 191, 222, 83, 47, 128, 218, 198, 84, 149, 26, 121, 190, 255, 150, 117, 92, 140, 101, 172, 62, 93, 97, 27, 103, 106, 161, 194, 201, 204, 45, 206, 111, 81, 252, 249, 73, 42, 248, 108, 118, 63, 56, 31, 216, 153, 180, 19, 126, 38, 139, 66, 88, 247, 143, 177, 137, 12, 199, 104, 235, 102, 75, 100, 129, 251, 18, 159, 107, 196, 22, 10, 152, 209, 94, 181, 250, 51, 210, 185, 144, 200, 169, 232, 122, 145, 173, 95, 171, 166, 229, 14, 5, 0, 105, 2, 163, 157, 48, 53, 133, 110, 52, 160, 186, 123, 124, 91, 20, 221, 240, 87, 178, 98, 207, 142, 148, 59, 203, 245, 205, 72, 11, 164, 39, 170, 135, 168, 197, 55, 86, 219, 167, 8, 82, 78, 220, 29, 146, 241, 54, 119, 30},
//            perm_w = {57, 1, 140, 48, 61, 156, 230, 173, 2, 231, 12, 214, 142, 242, 255, 195, 198, 220, 157, 139, 194, 99, 247, 248, 155, 178, 29, 41, 23, 193, 0, 30, 95, 171, 174, 222, 91, 54, 8, 67, 32, 129, 46, 124, 172, 148, 17, 105, 228, 118, 191, 33, 224, 5, 25, 158, 185, 92, 63, 199, 53, 107, 34, 180, 125, 69, 200, 116, 121, 216, 42, 233, 70, 43, 72, 26, 202, 62, 51, 15, 10, 16, 217, 207, 14, 175, 59, 52, 223, 246, 89, 109, 83, 13, 68, 90, 147, 239, 234, 18, 151, 114, 76, 143, 100, 197, 106, 176, 232, 208, 85, 165, 40, 186, 251, 101, 44, 65, 93, 218, 253, 144, 123, 11, 113, 167, 102, 240, 177, 137, 4, 184, 181, 20, 110, 37, 138, 111, 132, 94, 6, 122, 119, 75, 78, 84, 21, 3, 74, 235, 127, 112, 19, 58, 149, 161, 159, 73, 136, 150, 215, 35, 38, 86, 211, 190, 128, 203, 168, 9, 166, 244, 36, 28, 153, 225, 108, 254, 55, 169, 104, 141, 145, 22, 49, 212, 183, 79, 189, 227, 170, 60, 245, 205, 64, 252, 241, 80, 162, 97, 206, 163, 192, 146, 66, 182, 187, 135, 130, 152, 81, 71, 134, 39, 179, 188, 87, 126, 209, 229, 219, 133, 204, 210, 27, 103, 98, 154, 31, 250, 196, 7, 236, 77, 226, 56, 96, 88, 221, 45, 160, 50, 115, 237, 164, 201, 213, 82, 117, 24, 243, 131, 249, 47, 238, 120},
//            perm_u = {132, 148, 19, 244, 162, 163, 194, 37, 4, 250, 198, 154, 170, 137, 6, 60, 123, 73, 138, 41, 145, 92, 61, 82, 251, 175, 57, 207, 153, 50, 113, 105, 106, 242, 253, 94, 128, 9, 164, 143, 234, 80, 160, 252, 136, 239, 232, 150, 89, 167, 100, 131, 127, 178, 31, 188, 217, 5, 27, 33, 119, 152, 83, 195, 72, 88, 223, 176, 110, 111, 134, 233, 200, 190, 130, 86, 102, 69, 202, 240, 63, 13, 70, 229, 93, 24, 241, 22, 191, 99, 245, 139, 85, 254, 53, 45, 46, 182, 185, 26, 76, 197, 104, 67, 174, 20, 108, 184, 68, 171, 172, 90, 29, 107, 32, 79, 59, 126, 211, 112, 157, 201, 215, 237, 51, 84, 23, 135, 12, 28, 155, 124, 42, 43, 74, 173, 140, 114, 78, 18, 34, 1, 142, 180, 243, 193, 2, 161, 25, 212, 181, 218, 115, 39, 177, 71, 17, 186, 249, 225, 226, 122, 117, 214, 8, 129, 44, 7, 98, 216, 40, 116, 0, 103, 96, 30, 209, 47, 236, 11, 247, 58, 151, 52, 81, 141, 147, 169, 255, 16, 219, 75, 192, 208, 87, 56, 230, 231, 14, 97, 64, 54, 10, 222, 238, 205, 66, 120, 183, 133, 206, 109, 213, 144, 121, 158, 55, 235, 125, 3, 221, 118, 189, 165, 166, 62, 49, 146, 196, 77, 224, 203, 38, 156, 228, 48, 204, 35, 36, 210, 149, 227, 168, 199, 179, 246, 91, 248, 21, 65, 95, 101, 187, 220, 159, 15},
//            perm_v = {2, 9, 4, 237, 219, 73, 247, 203, 228, 220, 46, 229, 61, 156, 170, 75, 223, 144, 81, 252, 172, 208, 76, 218, 177, 103, 123, 244, 14, 39, 255, 90, 168, 43, 174, 3, 113, 107, 145, 233, 130, 254, 192, 11, 211, 190, 68, 105, 117, 178, 251, 18, 66, 242, 230, 248, 95, 137, 29, 26, 164, 65, 153, 120, 70, 77, 64, 33, 23, 133, 59, 7, 40, 16, 106, 41, 121, 216, 238, 135, 19, 212, 157, 48, 232, 28, 128, 22, 245, 171, 183, 56, 74, 99, 51, 150, 236, 111, 234, 71, 189, 167, 213, 37, 198, 50, 12, 79, 31, 250, 136, 165, 185, 246, 55, 86, 142, 62, 42, 52, 147, 205, 89, 94, 224, 141, 221, 180, 138, 129, 140, 101, 83, 193, 127, 67, 108, 84, 166, 109, 181, 20, 34, 195, 87, 24, 217, 116, 36, 88, 196, 82, 57, 239, 243, 124, 134, 175, 119, 210, 32, 163, 38, 139, 249, 227, 25, 97, 10, 118, 72, 131, 91, 54, 204, 225, 253, 58, 115, 154, 202, 122, 110, 112, 215, 1, 149, 146, 44, 201, 17, 240, 206, 197, 200, 169, 159, 13, 179, 143, 160, 152, 226, 161, 241, 80, 102, 15, 155, 92, 21, 184, 96, 148, 8, 158, 125, 35, 63, 176, 194, 235, 187, 30, 100, 231, 98, 207, 53, 47, 93, 173, 78, 186, 132, 199, 151, 114, 0, 45, 49, 126, 191, 222, 6, 182, 162, 188, 27, 69, 209, 214, 104, 5, 85, 60};

    protected static float dotf(final float g[], final float x, final float y) {
        return g[0] * x + g[1] * y;
    }

    protected static float dotf(final int g[], final float x, final float y, final float z) {
        return g[0] * x + g[1] * y + g[2] * z;
    }
    protected static float dotf(final float g[], final float x, final float y, final float z) {
        return g[0] * x + g[1] * y + g[2] * z;
    }

    protected static double dot(final float g[], final double x, final double y, final double z) {
        return g[0] * x + g[1] * y + g[2] * z;
    }
    protected static double dot(final float g[], final double x, final double y, final double z, final double w) {
        return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
    }

    /**
     * Computes the hashing for an integer point and its dot product with a double point as one step.
     * This code is largely drawn from Jordan Peck's MIT-licensed code, https://github.com/Auburns/FastNoise_Java ,
     * present in SquidLib as {@link FastNoise}.
     * @param seed
     * @param x
     * @param y
     * @param z
     * @param xd
     * @param yd
     * @param zd
     * @return a double between -1.25 and 1.25, I think
     */
    private static double gradCoord3D(int seed, int x, int y, int z, double xd, double yd, double zd) {
//        seed ^= 0xB4C4D * x ^ 0xEE2C1 * y ^ 0xA7E07 * z;
//        seed = seed * seed * seed * 60493L;
//        seed ^= (seed >>> 13);
//        final int hash = (int)(seed & 31) * 3;
        final int hash =
                (((seed ^= 0xB4C4D * x ^ 0xEE2C1 * y ^ 0xA7E07 * z) ^ seed >>> 13) * ((seed & 0xFFFF8) ^ 0x277B5)
                       >>> 27) * 3;
        return xd * grad3d[hash] + yd * grad3d[hash + 1] + zd * grad3d[hash + 2];
    }


    /*
    public static double interpolate(double t, double low, double high)
    {
        //debug
        //return 0;
        //linear
        //return t;
        //hermite
        //return t * t * (3 - 2 * t);
        //quintic
        //return t * t * t * (t * (t * 6 - 15) + 10);

        //t = (t + low + 0.5 - high) * 0.5;
        //t = (t < 0.5) ? t * low : 1.0 - ((1.0 - t) * high);
        //t = Math.pow(t, 1.0 + high - low);

        //return (t + 0.5 + high - low) * 0.5;
        return t * t * t * (t * (t * 6 - 15) + 10);
    }
    */

    /**
     * 2D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method. Roughly
     * 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks because
     * it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good distribution
     * and is fast) instead of a number chosen by hash from a single 256-element array.
     *
     * @param x X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param y Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoise(final double x, final double y) {
        return noise(x, y, seed);
    }

    /**
     * Identical to {@link #getNoise(double, double)}; ignores seed.
     * @param x X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param y Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @param seed ignored entirely.
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoiseWithSeed(final double x, final double y, final long seed) {
        return noise(x, y, seed);
    }
    /**
     * 3D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good
     * distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoise(final double x, final double y, final double z) {
        return noise(x, y, z, seed);
    }
    /**
     * Identical to {@link #getNoise(double, double, double)}; ignores seed.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param seed ignored entirely.
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoiseWithSeed(final double x, final double y, final double z, final long seed) {
        return noise(x, y, z, seed);
    }

    /**
     * 4D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good
     * distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimension)
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoise(final double x, final double y, final double z, final double w) {
        return noise(x, y, z, w, seed);
    }
    /**
     * Identical to {@link #getNoise(double, double, double, double)}; ignores seed.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimension)
     * @param seed ignored entirely.
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoiseWithSeed(final double x, final double y, final double z, final double w, final long seed) {
        return noise(x, y, z, w, seed);
    }


    /**
     * 2D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method. Roughly
     * 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks because
     * it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good distribution
     * and is fast) instead of a number chosen by hash from a single 256-element array.
     *
     * @param xin X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param yin Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin){
        return noise(xin, yin, 123456789);
    }

    /**
     * 2D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method. Roughly
     * 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks because
     * it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good distribution
     * and is fast) instead of a number chosen by hash from a single 256-element array.
     *
     * @param xin X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param yin Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin, final long seed) {
        //xin *= epi;
        //yin *= epi;
        double noise0, noise1, noise2; // from the three corners
        // Skew the input space to figure out which simplex cell we're in
        double skew = (xin + yin) * F2; // Hairy factor for 2D
        int i = fastFloor(xin + skew);
        int j = fastFloor(yin + skew);
        double t = (i + j) * G2;
        double X0 = i - t; // Unskew the cell origin back to (x,y) space
        double Y0 = j - t;
        double x0 = xin - X0; // The x,y distances from the cell origin
        double y0 = yin - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // determine which simplex we are in.
        int i1, j1; // Offsets for second (middle) corner of simplex in (i,j)
        // coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y),
        // where
        // c = (3-sqrt(3))/6
        double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y)
        // unskewed coords
        double y1 = y0 - j1 + G2;
        double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y)
        // unskewed coords
        double y2 = y0 - 1.0 + 2.0 * G2;
        // Work out the hashed gradient indices of the three simplex corners
        /*
        int ii = i & 255;
        int jj = j & 255;
        int gi0 = perm[ii + perm[jj]] & 15;
        int gi1 = perm[ii + i1 + perm[jj + j1]] & 15;
        int gi2 = perm[ii + 1 + perm[jj + 1]] & 15;
        */
        /*
        int hash = (int) rawNoise(i + (j * 0x9E3779B9),
                i + i1 + ((j + j1) * 0x9E3779B9),
                i + 1 + ((j + 1) * 0x9E3779B9),
                seed);
        int gi0 = hash & 15;
        int gi1 = (hash >>>= 4) & 15;
        int gi2 = (hash >>> 4) & 15;
        */
//        int gi0 = determine256(seed + i + determine(j));
//        int gi1 = determine256(seed + i + i1 + determine(j + j1));
//        int gi2 = determine256(seed + i + 1 + determine(j + 1));
        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63);
        final int gi0 = perm_x[i + s0 & 255] ^ perm_y[j + s1 & 255];
        final int gi1 = perm_x[i + i1 + s0 & 255] ^ perm_y[j + j1 + s1 & 255];
        final int gi2 = perm_x[i + 1 + s0 & 255] ^ perm_y[j + 1 + s1 & 255];

        // Calculate the contribution from the three corners
        double t0 = 0.75 - x0 * x0 - y0 * y0;
        if (t0 < 0) {
            noise0 = 0.0;
        } else {
            t0 *= t0;
            noise0 = t0 * t0 * dot(phiGrad2[gi0], x0, y0);
            // for 2D gradient
        }
        double t1 = 0.75 - x1 * x1 - y1 * y1;
        if (t1 < 0) {
            noise1 = 0.0;
        } else {
            t1 *= t1;
            noise1 = t1 * t1 * dot(phiGrad2[gi1], x1, y1);
        }
        double t2 = 0.75 - x2 * x2 - y2 * y2;
        if (t2 < 0) {
            noise2 = 0.0;
        } else {
            t2 *= t2;
            noise2 = t2 * t2 * dot(phiGrad2[gi2], x2, y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return  9.125 * (noise0 + noise1 + noise2);
    }



    /**
     * 3D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very
     * good distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param xin X input
     * @param yin Y input
     * @param zin Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin, final double zin){
        return noise(xin, yin, zin, 123456789);
    }

    /**
     * 3D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very
     * good distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param xin X input
     * @param yin Y input
     * @param zin Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin, final double zin, final long seed){
        final int seed2 = (int) (seed ^ seed >>> 32);
        double n = 0.0; // Noise contributions are added here
        // Skew the input space to figure out which simplex cell we're in
        double s = (xin + yin + zin) * F3; // Very nice and simple skew
        // factor for 3D
        int i = fastFloor(xin + s);
        int j = fastFloor(yin + s);
        int k = fastFloor(zin + s);
        double t = (i + j + k) * G3;
        double X0 = i - t; // Unskew the cell origin back to (x,y,z) space
        double Y0 = j - t;
        double Z0 = k - t;
        double x0 = xin - X0; // The x,y,z distances from the cell origin
        double y0 = yin - Y0;
        double z0 = zin - Z0;
        // For the 3D case, the simplex shape is a slightly irregular
        // tetrahedron.
        // determine which simplex we are in.
        int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
        int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // X Y Z order
            else if (x0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // X Z Y order
            else {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // Z X Y order
        } else { // x0<y0
            if (y0 < z0) {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Z Y X order
            else if (x0 < z0) {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Y Z X order
            else {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // Y X Z order
        }
        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in
        // (x,y,z),
        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in
        // (x,y,z), and
        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in
        // (x,y,z), where
        // c = 1/6.
        double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
        double y1 = y0 - j1 + G3;
        double z1 = z0 - k1 + G3;
        double x2 = x0 - i2 + F3; // Offsets for third corner in (x,y,z) coords
        double y2 = y0 - j2 + F3;
        double z2 = z0 - k2 + F3;
        double x3 = x0 - 0.5; // Offsets for last corner in (x,y,z) coords
        double y3 = y0 - 0.5;
        double z3 = z0 - 0.5;

        // Work out the hashed gradient indices of the four simplex corners

        /*
        int ii = i & 255;
        int jj = j & 255;
        int kk = k & 255;

        int gi0 = perm[ii + perm[jj + perm[kk]]] % 12;
        int gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]] % 12;
        int gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]] % 12;
        int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]] % 12;
        */
//        int gi0 = determine32(seed + i + determine(j + determine(k)));
//        int gi1 = determine32(seed + i + i1 + determine(j + j1 + determine(k + k1)));
//        int gi2 = determine32(seed + i + i2 + determine(j + j2 + determine(k + k2)));
//        int gi3 = determine32(seed + i + 1 + determine(j + 1 + determine(k + 1)));


//        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63), s2 = (int)(seed >>> 12 & 63);
//        final int gi0 = (perm_x[(i) + s0 & 255] ^ perm_y[(j) + s1 & 255]           ^ perm_z[(k) + s2 & 255]) & 31;
//        final int gi1 = (perm_x[(i + i1) + s0 & 255] ^ perm_y[(j + j1) + s1 & 255] ^ perm_z[(k + k1) + s2 & 255]) & 31;
//        final int gi2 = (perm_x[(i + i2) + s0 & 255] ^ perm_y[(j + j2) + s1 & 255] ^ perm_z[(k + k2) + s2 & 255]) & 31;
//        final int gi3 = (perm_x[(i + 1) + s0 & 255] ^ perm_y[(j + 1) + s1 & 255]   ^ perm_z[(k + 1) + s2  & 255]) & 31;

        /*
        int hash = (int) rawNoise(i + ((j + k * 0x632BE5AB) * 0x9E3779B9),
                i + i1 + ((j + j1 + (k + k1) * 0x632BE5AB) * 0x9E3779B9),
                i + i2 + ((j + j2 + (k + k2) * 0x632BE5AB) * 0x9E3779B9),
                i + 1 + ((j + 1 + ((k + 1) * 0x632BE5AB)) * 0x9E3779B9),
                seed);
        int gi0 = (hash >>>= 4) % 12;
        int gi1 = (hash >>>= 4) % 12;
        int gi2 = (hash >>>= 4) % 12;
        int gi3 = (hash >>> 4) % 12;
        */

        //int hash = (int) rawNoise(i, j, k, seed);
        //int gi0 = (hash >>>= 4) % 12, gi1 = (hash >>>= 4) % 12, gi2 = (hash >>>= 4) % 12, gi3 = (hash >>>= 4) % 12;
        // Calculate the contribution from the four corners
        double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 > 0) {
            t0 *= t0;
            n += t0 * t0 * gradCoord3D(seed2, i, j, k, x0, y0, z0);//dot(grad3f[gi0], x0, y0, z0);
        }
        double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 > 0) {
            t1 *= t1;
            n += t1 * t1 * gradCoord3D(seed2, i + i1, j + j1, k + k1, x1, y1, z1);//dot(grad3f[gi1], x1, y1, z1);
        }
        double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 > 0) {
            t2 *= t2;
            n += t2 * t2 * gradCoord3D(seed2, i + i2, j + j2, k + k2, x2, y2, z2);//dot(grad3f[gi2], x2, y2, z2);
        }
        double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 > 0) {
            t3 *= t3;
            n += t3 * t3 * gradCoord3D(seed2, i + 1, j + 1, k + 1, x3, y3, z3);//dot(grad3f[gi3], x3, y3, z3);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to stay just inside [-1,1]
        return 31.5 * n;

    }

    /**
     * 4D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double, double)} and this
     * method. Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in
     * chunks because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very
     * good distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimensional)
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double x, final double y, final double z, final double w) {
        return noise(x, y, z, w, 123456789);
    }

    /**
     * Used by {@link #noise(double, double, double, double, long)} to look up the vertices of the 4D triangle analogue.
     */
    protected static final int[] SIMPLEX = {0, 1, 3, 7, 0, 1, 7, 3,
            0, 0, 0, 0, 0, 3, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 1, 3, 7, 0, 0, 3, 1, 7, 0, 0, 0, 0,
            0, 7, 1, 3, 0, 7, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 1, 7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 7, 0, 0, 0, 0,
            1, 7, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            3, 7, 0, 1, 3, 7, 1, 0, 1, 0, 3, 7, 1, 0, 7, 3,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 1,
            0, 0, 0, 0, 3, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 7, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 1, 3, 7, 0, 3, 1,
            0, 0, 0, 0, 7, 1, 3, 0, 3, 1, 0, 7, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 0, 3, 0, 0, 0, 0,
            7, 3, 0, 1, 7, 3, 1, 0};

    /**
     * 4D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double, double)} and this
     * method. Roughly 20-25% faster than the equivalent method in PerlinNoise.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimensional)
     * @param seed any int; will be used to completely alter the noise
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double x, final double y, final double z, final double w, final long seed) {
        double n = 0.0;
        final double s = (x + y + z + w) * F4;
        final int i = fastFloor(x + s), j = fastFloor(y + s), k = fastFloor(z + s), l = fastFloor(w + s);
        final double[] gradient4DLUT = grad4;
        final double t = (i + j + k + l) * G4,
                X0 = i - t,
                Y0 = j - t,
                Z0 = k - t,
                W0 = l - t,
                x0 = x - X0,
                y0 = y - Y0,
                z0 = z - Z0,
                w0 = w - W0;
        final int c = (x0 > y0 ? 128 : 0) | (x0 > z0 ? 64 : 0) | (y0 > z0 ? 32 : 0) | (x0 > w0 ? 16 : 0) | (y0 > w0 ? 8 : 0) | (z0 > w0 ? 4 : 0);
        final int i1 = SIMPLEX[c] >>> 2,
                j1 = SIMPLEX[c | 1] >>> 2,
                k1 = SIMPLEX[c | 2] >>> 2,
                l1 = SIMPLEX[c | 3] >>> 2,
                i2 = SIMPLEX[c] >>> 1 & 1,
                j2 = SIMPLEX[c | 1] >>> 1 & 1,
                k2 = SIMPLEX[c | 2] >>> 1 & 1,
                l2 = SIMPLEX[c | 3] >>> 1 & 1,
                i3 = SIMPLEX[c] & 1,
                j3 = SIMPLEX[c | 1] & 1,
                k3 = SIMPLEX[c | 2] & 1,
                l3 = SIMPLEX[c | 3] & 1;
        final double x1 = x0 - i1 + G4,
                y1 = y0 - j1 + G4,
                z1 = z0 - k1 + G4,
                w1 = w0 - l1 + G4,
                x2 = x0 - i2 + 2 * G4,
                y2 = y0 - j2 + 2 * G4,
                z2 = z0 - k2 + 2 * G4,
                w2 = w0 - l2 + 2 * G4,
                x3 = x0 - i3 + 3 * G4,
                y3 = y0 - j3 + 3 * G4,
                z3 = z0 - k3 + 3 * G4,
                w3 = w0 - l3 + 3 * G4,
                x4 = x0 - 1 + 4 * G4,
                y4 = y0 - 1 + 4 * G4,
                z4 = z0 - 1 + 4 * G4,
                w4 = w0 - 1 + 4 * G4;
        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63), s2 = (int)(seed >>> 12 & 63), s3 = (int)(seed >>> 18 & 63);
        final int h0 = (perm_x[(i) + s0 & 255] ^ perm_y[(j) + s1 & 255]           ^ perm_z[(k) + s2 & 255]      ^ perm_w[(l) + s3 & 255]) & 252;
        final int h1 = (perm_x[(i + i1) + s0 & 255] ^ perm_y[(j + j1) + s1 & 255] ^ perm_z[(k + k1) + s2 & 255] ^ perm_w[(l + l1) + s3 & 255]) & 252;
        final int h2 = (perm_x[(i + i2) + s0 & 255] ^ perm_y[(j + j2) + s1 & 255] ^ perm_z[(k + k2) + s2 & 255] ^ perm_w[(l + l2) + s3 & 255]) & 252;
        final int h3 = (perm_x[(i + i3) + s0 & 255] ^ perm_y[(j + j3) + s1 & 255] ^ perm_z[(k + k3) + s2 & 255] ^ perm_w[(l + l3) + s3 & 255]) & 252;
        final int h4 = (perm_x[(i + 1) + s0 & 255] ^ perm_y[(j + 1) + s1 & 255]   ^ perm_z[(k + 1) + s2  & 255] ^ perm_w[(l + 1) + s3 & 255]) & 252;
//        final int h0 = hash256_alt(i, j, k, l, seed) & 252;
//        final int h1 = hash256_alt(i + i1, j + j1, k + k1, l + l1, seed) & 252;
//        final int h2 = hash256_alt(i + i2, j + j2, k + k2, l + l2, seed) & 252;
//        final int h3 = hash256_alt(i + i3, j + j3, k + k3, l + l3, seed) & 252;
//        final int h4 = hash256_alt(i + 1, j + 1, k + 1, l + 1, seed) & 252;
        double t0 = 0.62 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
        if(t0 > 0) {
            t0 *= t0;
            n += t0 * t0 * (x0 * gradient4DLUT[h0] + y0 * gradient4DLUT[h0 | 1] + z0 * gradient4DLUT[h0 | 2] + w0 * gradient4DLUT[h0 | 3]);
        }
        double t1 = 0.62 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
        if (t1 > 0) {
            t1 *= t1;
            n += t1 * t1 * (x1 * gradient4DLUT[h1] + y1 * gradient4DLUT[h1 | 1] + z1 * gradient4DLUT[h1 | 2] + w1 * gradient4DLUT[h1 | 3]);
        }
        double t2 = 0.62 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
        if (t2 > 0) {
            t2 *= t2;
            n += t2 * t2 * (x2 * gradient4DLUT[h2] + y2 * gradient4DLUT[h2 | 1] + z2 * gradient4DLUT[h2 | 2] + w2 * gradient4DLUT[h2 | 3]);
        }
        double t3 = 0.62 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
        if (t3 > 0) {
            t3 *= t3;
            n += t3 * t3 * (x3 * gradient4DLUT[h3] + y3 * gradient4DLUT[h3 | 1] + z3 * gradient4DLUT[h3 | 2] + w3 * gradient4DLUT[h3 | 3]);
        }
        double t4 = 0.62 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
        if (t4 > 0) {
            t4 *= t4;
            n += t4 * t4 * (x4 * gradient4DLUT[h4] + y4 * gradient4DLUT[h4 | 1] + z4 * gradient4DLUT[h4 | 2] + w4 * gradient4DLUT[h4 | 3]);
        }
        //n *= 14.75;
        //if(n > 1.0 || n < -1.0) System.out.printf("x: %f, y: %f, z: %f, w: %f, n is %f\n", x, y, z, w, n);
        //return NumberTools.bounce(5.0 + 41.0 * n);
        return n * 14.75;//NumberTools.sway(0.5 + 12.75 * n);
    }


//    public static double noise(final double x, final double y, final double z, final double w, final long seed)
//    {
//        // The skewing and unskewing factors are hairy again for the 4D case
//
//        // Skew the (x,y,z,w) space to figure out which cell of 24 simplices
//        // we're in
//        double s = (x + y + z + w) * F4; // Factor for 4D skewing
//        int i = fastFloor(x + s);
//        int j = fastFloor(y + s);
//        int k = fastFloor(z + s);
//        int l = fastFloor(w + s);
//        double t = (i + j + k + l) * G4; // Factor for 4D unskewing
//        double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
//        double Y0 = j - t;
//        double Z0 = k - t;
//        double W0 = l - t;
//        double x0 = x - X0; // The x,y,z,w distances from the cell origin
//        double y0 = y - Y0;
//        double z0 = z - Z0;
//        double w0 = w - W0;
//        // For the 4D case, the simplex is a 4D shape I won't even try to
//        // describe.
//        // To find out which of the 24 possible simplices we're in, we need
//        // to figure out the magnitude ordering of x0, y0, z0 and w0.
//        // The method below is a good way of finding the ordering of x,y,z,w
//        // and
//        // then find the correct traversal order for the simplex were in.
//        // First, six pair-wise comparisons are performed between each
//        // possible pair
//        // of the four coordinates, and the results are used to add up binary
//        // bits
//        // for an integer index.
//        int c = (x0 > y0 ? 32 : 0) | (x0 > z0 ? 16 : 0) | (y0 > z0 ? 8 : 0) |
//                (x0 > w0 ? 4 : 0) | (y0 > w0 ? 2 : 0) | (z0 > w0 ? 1 : 0);
//
//        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some
//        // order.
//        // Many values of c will never occur, since e.g. x>y>z>w makes x<z,
//        // y<w and x<w
//        // impossible. Only the 24 indices which have non-zero entries make
//        // any sense.
//        // We use a thresholding to set the coordinates in turn from the
//        // largest magnitude.
//        // The number 3 in the "simplex" array is at the position of the
//        // largest coordinate.
//
//        // The integer offsets for the second simplex corner
//        int i1 = simplex[c][0] >= 3 ? 1 : 0;
//        int j1 = simplex[c][1] >= 3 ? 1 : 0;
//        int k1 = simplex[c][2] >= 3 ? 1 : 0;
//        int l1 = simplex[c][3] >= 3 ? 1 : 0;
//        // The number 2 in the "simplex" array is at the second largest
//        // coordinate.
//
//        // The integer offsets for the third simplex corner
//        int i2 = simplex[c][0] >= 2 ? 1 : 0;
//        int j2 = simplex[c][1] >= 2 ? 1 : 0;
//        int k2 = simplex[c][2] >= 2 ? 1 : 0;
//        int l2 = simplex[c][3] >= 2 ? 1 : 0;
//        // The number 1 in the "simplex" array is at the second smallest
//        // coordinate.
//
//        // The integer offsets for the fourth simplex corner
//        int i3 = simplex[c][0] >= 1 ? 1 : 0;
//        int j3 = simplex[c][1] >= 1 ? 1 : 0;
//        int k3 = simplex[c][2] >= 1 ? 1 : 0;
//        int l3 = simplex[c][3] >= 1 ? 1 : 0;
//        // The fifth corner has all coordinate offsets = 1, so no need to
//        // look that up.
//        double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
//        double y1 = y0 - j1 + G4;
//        double z1 = z0 - k1 + G4;
//        double w1 = w0 - l1 + G4;
//        double x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
//        double y2 = y0 - j2 + 2.0 * G4;
//        double z2 = z0 - k2 + 2.0 * G4;
//        double w2 = w0 - l2 + 2.0 * G4;
//        double x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
//        double y3 = y0 - j3 + 3.0 * G4;
//        double z3 = z0 - k3 + 3.0 * G4;
//        double w3 = w0 - l3 + 3.0 * G4;
//        double x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
//        double y4 = y0 - 1.0 + 4.0 * G4;
//        double z4 = z0 - 1.0 + 4.0 * G4;
//        double w4 = w0 - 1.0 + 4.0 * G4;
//
//        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63), s2 = (int)(seed >>> 12 & 63), s3 = (int)(seed >>> 18 & 63);
//        final int gi0 = (perm_x[(i) + s0 & 255] ^ perm_y[(j) + s1 & 255]           ^ perm_z[(k) + s2 & 255]      ^ perm_w[(l) + s3 & 255]) & 63;
//        final int gi1 = (perm_x[(i + i1) + s0 & 255] ^ perm_y[(j + j1) + s1 & 255] ^ perm_z[(k + k1) + s2 & 255] ^ perm_w[(l + l1) + s3 & 255]) & 63;
//        final int gi2 = (perm_x[(i + i2) + s0 & 255] ^ perm_y[(j + j2) + s1 & 255] ^ perm_z[(k + k2) + s2 & 255] ^ perm_w[(l + l2) + s3 & 255]) & 63;
//        final int gi3 = (perm_x[(i + i3) + s0 & 255] ^ perm_y[(j + j3) + s1 & 255] ^ perm_z[(k + k3) + s2 & 255] ^ perm_w[(l + l3) + s3 & 255]) & 63;
//        final int gi4 = (perm_x[(i + 1) + s0 & 255] ^ perm_y[(j + 1) + s1 & 255]   ^ perm_z[(k + 1) + s2  & 255] ^ perm_w[(l + 1) + s3 & 255]) & 63;
//        // Noise contributions from the five corners are n0 to n4
//
//        // Calculate the contribution from the five corners
//        double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0, n0;
//        if (t0 < 0) {
//            n0 = 0.0;
//        } else {
//            t0 *= t0;
//            n0 = t0 * t0 * dot(grad4f[gi0], x0, y0, z0, w0);
//        }
//        double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1, n1;
//        if (t1 < 0) {
//            n1 = 0.0;
//        } else {
//            t1 *= t1;
//            n1 = t1 * t1 * dot(grad4f[gi1], x1, y1, z1, w1);
//        }
//        double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2,  n2;
//        if (t2 < 0) {
//            n2 = 0.0;
//        } else {
//            t2 *= t2;
//            n2 = t2 * t2 * dot(grad4f[gi2], x2, y2, z2, w2);
//        }
//        double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3, n3;
//        if (t3 < 0) {
//            n3 = 0.0;
//        } else {
//            t3 *= t3;
//            n3 = t3 * t3 * dot(grad4f[gi3], x3, y3, z3, w3);
//        }
//        double t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4, n4;
//        if (t4 < 0) {
//            n4 = 0.0;
//        } else {
//            t4 *= t4;
//            n4 = t4 * t4 * dot(grad4f[gi4], x4, y4, z4, w4);
//        }
//        // Sum up and scale the result to cover the range [-1,1]
//        return 17.0 * (n0 + n1 + n2 + n3 + n4);
//    }

    /**
     * 2D simplex noise returning a float; extremely similar to {@link #noise(double, double)}, but this may be slightly
     * faster or slightly slower. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result
     * will be different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method.
     *
     * @param x x input; works well if between 0.0 and 1.0, but anything is accepted
     * @param y y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static float noiseAlt(double x, double y) {
        //xin *= epi;
        //yin *= epi;
        float noise0, noise1, noise2; // from the three corners
        float xin = (float)x, yin = (float)y;
        // Skew the input space to figure out which simplex cell we're in
        float skew = (xin + yin) * F2f; // Hairy factor for 2D
        int i = fastFloor(xin + skew);
        int j = fastFloor(yin + skew);
        float t = (i + j) * G2f;
        float X0 = i - t; // Unskew the cell origin back to (x,y) space
        float Y0 = j - t;
        float x0 = xin - X0; // The x,y distances from the cell origin
        float y0 = yin - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // determine which simplex we are in.
        int i1, j1; // Offsets for second (middle) corner of simplex in (i,j)
        // coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y),
        // where: c = (3-sqrt(3))/6
        float x1 = x0 - i1 + G2f; // Offsets for middle corner in (x,y)
        // unskewed coords
        float y1 = y0 - j1 + G2f;
        float x2 = x0 - 1f + 2f * G2f; // Offsets for last corner in (x,y)
        // unskewed coords
        float y2 = y0 - 1f + 2f * G2f;
        // Work out the hashed gradient indices of the three simplex corners
//        int gi0 = determine256(i + determine(j));
//        int gi1 = determine256(i + i1 + determine(j + j1));
//        int gi2 = determine256(i + 1 + determine(j + 1));
        final int gi0 = perm_x[i & 255] ^ perm_y[j & 255];
        final int gi1 = perm_x[i + i1 & 255] ^ perm_y[j + j1 & 255];
        final int gi2 = perm_x[i + 1 & 255] ^ perm_y[j + 1 & 255];

        // Calculate the contribution from the three corners
        float t0 = 0.75f - x0 * x0 - y0 * y0;
        if (t0 < 0) {
            noise0 = 0.0f;
        } else {
            t0 *= t0;
            noise0 = t0 * t0 * dotf(phiGrad2f[gi0], x0, y0);
            // for 2D gradient
        }
        float t1 = 0.75f - x1 * x1 - y1 * y1;
        if (t1 < 0) {
            noise1 = 0.0f;
        } else {
            t1 *= t1;
            noise1 = t1 * t1 * dotf(phiGrad2f[gi1], x1, y1);
        }
        float t2 = 0.75f - x2 * x2 - y2 * y2;
        if (t2 < 0) {
            noise2 = 0.0f;
        } else {
            t2 *= t2;
            noise2 = t2 * t2 * dotf(phiGrad2f[gi2], x2, y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return 9.125f * (noise0 + noise1 + noise2);
    }

    /**
     * 3D simplex noise returning a float; extremely similar to {@link #noise(double, double, double)}, but this may
     * be slightly faster or slightly slower. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of
     * the result will be different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)}
     * and this method.
     *
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static float noiseAlt(double x, double y, double z) {
        //xin *= epi;
        //yin *= epi;
        //zin *= epi;
        float xin = (float)x, yin = (float)y, zin = (float)z;
        float n0, n1, n2, n3; // Noise contributions from the four corners
        // Skew the input space to figure out which simplex cell we're in
        float s = (xin + yin + zin) * F3f; // Very nice and simple skew
        // factor for 3D
        int i = fastFloor(xin + s);
        int j = fastFloor(yin + s);
        int k = fastFloor(zin + s);
        float t = (i + j + k) * G3f;
        float X0 = i - t; // Unskew the cell origin back to (x,y,z) space
        float Y0 = j - t;
        float Z0 = k - t;
        float x0 = xin - X0; // The x,y,z distances from the cell origin
        float y0 = yin - Y0;
        float z0 = zin - Z0;
        // For the 3D case, the simplex shape is a slightly irregular
        // tetrahedron.
        // determine which simplex we are in.
        int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k)
        // coords
        int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k)
        // coords
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // X Y Z order
            else if (x0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // X Z Y order
            else {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // Z X Y order
        } else { // x0<y0
            if (y0 < z0) {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Z Y X order
            else if (x0 < z0) {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Y Z X order
            else {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // Y X Z order
        }
        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in
        // (x,y,z),
        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in
        // (x,y,z), and
        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in
        // (x,y,z), where
        // c = 1/6.
        float x1 = x0 - i1 + G3f; // Offsets for second corner in (x,y,z)
        // coords
        float y1 = y0 - j1 + G3f;
        float z1 = z0 - k1 + G3f;
        float x2 = x0 - i2 + F3f; // Offsets for third corner in
        // (x,y,z) coords
        float y2 = y0 - j2 + F3f;
        float z2 = z0 - k2 + F3f;
        float x3 = x0 - 0.5f; // Offsets for last corner in
        // (x,y,z) coords
        float y3 = y0 - 0.5f;
        float z3 = z0 - 0.5f;
        // Work out the hashed gradient indices of the four simplex corners

        /*
        int ii = i & 255;
        int jj = j & 255;
        int kk = k & 255;

        int gi0 = perm[ii + perm[jj + perm[kk]]] % 12;
        int gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]] % 12;
        int gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]] % 12;
        int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]] % 12;
        */
//        int gi0 = determine32(i + determine(j + determine(k)));
//        int gi1 = determine32(i + i1 + determine(j + j1 + determine(k + k1)));
//        int gi2 = determine32(i + i2 + determine(j + j2 + determine(k + k2)));
//        int gi3 = determine32(i + 1 + determine(j + 1 + determine(k + 1)));
        final int gi0 = (perm_x[(i) & 255] ^ perm_y[(j) & 255]           ^ perm_z[(k) + 67 & 255]) & 31;
        final int gi1 = (perm_x[(i + i1) & 255] ^ perm_y[(j + j1) & 255] ^ perm_z[(k + k1) + 67 & 255]) & 31;
        final int gi2 = (perm_x[(i + i2) & 255] ^ perm_y[(j + j2) & 255] ^ perm_z[(k + k2) + 67 & 255]) & 31;
        final int gi3 = (perm_x[(i + 1) & 255] ^ perm_y[(j + 1) & 255]   ^ perm_z[(k + 1) + 67  & 255]) & 31;


//        int gi0 = determineBounded(i + determine(j + determine(k)), 92);
//        int gi1 = determineBounded(i + i1 + determine(j + j1 + determine(k + k1)), 92);
//        int gi2 = determineBounded(i + i2 + determine(j + j2 + determine(k + k2)), 92);
//        int gi3 = determineBounded(i + 1 + determine(j + 1 + determine(k + 1)), 92);

        /*
        int hash = (int) rawNoise(i + ((j + k * 0x632BE5AB) * 0x9E3779B9),
                i + i1 + ((j + j1 + (k + k1) * 0x632BE5AB) * 0x9E3779B9),
                i + i2 + ((j + j2 + (k + k2) * 0x632BE5AB) * 0x9E3779B9),
                i + 1 + ((j + 1 + ((k + 1) * 0x632BE5AB)) * 0x9E3779B9),
                seed);
        int gi0 = (hash >>>= 4) % 12;
        int gi1 = (hash >>>= 4) % 12;
        int gi2 = (hash >>>= 4) % 12;
        int gi3 = (hash >>> 4) % 12;
        */

        //int hash = (int) rawNoise(i, j, k, seed);
        //int gi0 = (hash >>>= 4) % 12, gi1 = (hash >>>= 4) % 12, gi2 = (hash >>>= 4) % 12, gi3 = (hash >>>= 4) % 12;
        // Calculate the contribution from the four corners
        float t0 = 0.6f - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 < 0) {
            n0 = 0f;
        } else {
            t0 *= t0;
            n0 = t0 * t0 * dotf(grad3f[gi0], x0, y0, z0);
        }
        float t1 = 0.6f - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 < 0) {
            n1 = 0f;
        } else {
            t1 *= t1;
            n1 = t1 * t1 * dotf(grad3f[gi1], x1, y1, z1);
        }
        float t2 = 0.6f - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 < 0) {
            n2 = 0f;
        } else {
            t2 *= t2;
            n2 = t2 * t2 * dotf(grad3f[gi2], x2, y2, z2);
        }
        float t3 = 0.6f - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 < 0) {
            n3 = 0f;
        } else {
            t3 *= t3;
            n3 = t3 * t3 * dotf(grad3f[gi3], x3, y3, z3);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to stay just inside [-1,1]
        return  31.5f * (n0 + n1 + n2 + n3);
    }

}
