package squidpony.squidmath;

import squidpony.annotation.Beta;

import java.io.Serializable;

import static squidpony.squidmath.Noise.HastyPointHash.perm_x;
import static squidpony.squidmath.Noise.HastyPointHash.perm_y;
import static squidpony.squidmath.Noise.HastyPointHash.perm_z;
import static squidpony.squidmath.Noise.HastyPointHash.perm_w;
import static squidpony.squidmath.Noise.fastFloor;

/**
 * Another experimental noise class. Extends PerlinNoise and should have similar quality, but can be faster and has less
 * periodic results. This is still considered experimental because the exact output may change in future versions, along
 * with the scale (potentially) and the parameters it takes. In general, {@link #noise(double, double)} and
 * {@link #noise(double, double, double)} should have similar appearance to {@link PerlinNoise#noise(double, double)},
 * {@link PerlinNoise#noise(double, double, double)}, and {@link PerlinNoise#noise(double, double, double, double)}, but
 * are not forced to a zoomed-in scale like PerlinNoise makes its results, have a lower chance of forming shapes with
 * multiple octaves that appear "non-natural" (such as long straight lines, axis-aligned shapes, and hard angles), and
 * the 3D and 4D noise variants tend to be faster due to a more efficient method for hashing points. WhirlingNoise is
 * preferred to other related {@link Noise.Noise3D} or {@link Noise.Noise4D} implementations for most world map
 * generation (usually using {@link squidpony.squidgrid.mapping.WorldMapGenerator}) because it is less likely to produce
 * artificial-seeming shapes, which are out-of-place in a world map.
 * <br>
 * Created by Tommy Ettinger on 12/14/2016. The technique for point hashing here is based closely on
 * <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.3594&rep=rep1&type=pdf">this paper</a>,
 * with credit to Andrew Kensler, Aaron Knoll and Peter Shirley.
 */
@Beta
public class WhirlingNoise extends PerlinNoise implements Noise.Noise2D, Noise.Noise3D, Noise.Noise4D, Serializable {

    private static final long serialVersionUID = 5L;
    public long seed;
    public static final WhirlingNoise instance = new WhirlingNoise();
    public WhirlingNoise()
    {
        this(123456789);
    }
    public WhirlingNoise(long seed) {
        this.seed = seed;
//        System.out.println("{");
//        for (int i = 0; i < grad3f.length; i++) {
//            System.out.printf("{% 2.15ff, % 2.15ff, % 2.15ff},\n", grad3f[i][0], grad3f[i][1], grad3f[i][2]);
//        }
//        System.out.println("}");
    }

    protected static final float
            //root2 = 1.4142135f,
            root3 = 1.7320508f,
            F2f = 0.5f * (root3 - 1f),
            G2f = (3f - root3) * 0.16666667f,
            F3f = 0.33333334f,
            G3f = 0.16666667f;
    /*
            root5 = 2.236068f,
            F4f = (root5 - 1f) * 0.25f,
            G4f = (5f - root5) * 0.05f,
            unit1_4f =  0.70710678118f, unit1_8f = 0.38268343236f, unit3_8f = 0.92387953251f;
    */
    /*
    protected static final float[][] grad2f = {
            {1f, 0f}, {-1f, 0f}, {0f, 1f}, {0f, -1f},
            {unit3_8f, unit1_8f}, {unit3_8f, -unit1_8f}, {-unit3_8f, unit1_8f}, {-unit3_8f, -unit1_8f},
            {unit1_4f, unit1_4f}, {unit1_4f, -unit1_4f}, {-unit1_4f, unit1_4f}, {-unit1_4f, -unit1_4f},
            {unit1_8f, unit3_8f}, {unit1_8f, -unit3_8f}, {-unit1_8f, unit3_8f}, {-unit1_8f, -unit3_8f}};
    */
    protected static final float[][] phiGrad2f = {
            {0.6499429579167653f, 0.759982994187637f},
            {-0.1551483029088119f, 0.9878911904175052f},
            {-0.8516180517334043f, 0.5241628506120981f},
            {-0.9518580082090311f, -0.30653928330368374f},
            {-0.38568876701087174f, -0.9226289476282616f},
            {0.4505066120763985f, -0.8927730912586049f},
            {0.9712959670388622f, -0.23787421973396244f},
            {0.8120673355833279f, 0.5835637432865366f},
            {0.08429892519436613f, 0.9964405106232257f},
            {-0.702488350003267f, 0.7116952424385647f},
            {-0.9974536374007479f, -0.07131788861160528f},
            {-0.5940875849508908f, -0.804400361391775f},
            {0.2252075529515288f, -0.9743108118529653f},
            {0.8868317111719171f, -0.4620925405802277f},
            {0.9275724981153959f, 0.373643226540993f},
            {0.3189067150428103f, 0.9477861083074618f},
            {-0.5130301507665112f, 0.8583705868705491f},
            {-0.9857873824221494f, 0.1679977281313266f},
            {-0.7683809836504446f, -0.6399927061806058f},
            {-0.013020236219374872f, -0.9999152331316848f},
            {0.7514561619680513f, -0.6597830223946701f},
            {0.9898275175279653f, 0.14227257481477412f},
            {0.5352066871710182f, 0.8447211386057674f},
            {-0.29411988281443646f, 0.9557685360657266f},
            {-0.9175289804081126f, 0.39766892022290273f},
            {-0.8985631161871687f, -0.43884430750324743f},
            {-0.2505005588110731f, -0.968116454790094f},
            {0.5729409678802212f, -0.8195966369650838f},
            {0.9952584535626074f, -0.09726567026534665f},
            {0.7207814785200723f, 0.6931623620930514f},
            {-0.05832476124070039f, 0.998297662136006f},
            {-0.7965970142012075f, 0.6045107087270838f},
            {-0.977160478114496f, -0.21250270589112422f},
            {-0.4736001288089817f, -0.8807399831914728f},
            {0.36153434093875386f, -0.9323587937709286f},
            {0.9435535266854258f, -0.3312200813348966f},
            {0.8649775992346886f, 0.5018104750024599f},
            {0.1808186720712497f, 0.9835164502083277f},
            {-0.6299339540895539f, 0.7766487066139361f},
            {-0.9996609468975833f, 0.02603826506945166f},
            {-0.6695112313914258f, -0.7428019325774111f},
            {0.12937272671950842f, -0.9915960354807594f},
            {0.8376810167470904f, -0.5461597881403947f},
            {0.959517028911149f, 0.28165061908243916f},
            {0.4095816551369482f, 0.9122734610714476f},
            {-0.42710760401484793f, 0.9042008043530463f},
            {-0.9647728141412515f, 0.2630844295924223f},
            {-0.8269869890664444f, -0.562221059650754f},
            {-0.11021592552380209f, -0.9939076666174438f},
            {0.6837188597775012f, -0.72974551782423f},
            {0.998972441738333f, 0.04532174585508431f},
            {0.6148313475439905f, 0.7886586169422362f},
            {-0.1997618324529528f, 0.9798444827088829f},
            {-0.8744989400706802f, 0.48502742583822706f},
            {-0.9369870231562731f, -0.3493641630687752f},
            {-0.3434772946489506f, -0.9391609809082988f},
            {0.4905057254335028f, -0.8714379687143274f},
            {0.9810787787756657f, -0.1936089611460388f},
            {0.7847847614201463f, 0.6197684069414349f},
            {0.03905187955516296f, 0.9992371844077906f},
            {-0.7340217731995672f, 0.6791259356474049f},
            {-0.9931964444524306f, -0.1164509455824639f},
            {-0.5570202966000876f, -0.830498879695542f},
            {0.2691336060685578f, -0.9631028512493016f},
            {0.9068632806061f, -0.4214249521425399f},
            {0.9096851999779008f, 0.4152984913783901f},
            {0.27562369868737335f, 0.9612656119522284f},
            {-0.5514058359842319f, 0.8342371389734039f},
            {-0.9923883787916933f, 0.12314749546456379f},
            {-0.7385858406439617f, -0.6741594440488484f},
            {0.032311046904542805f, -0.9994778618098213f},
            {0.7805865154410089f, -0.6250477517051506f},
            {0.9823623706068018f, 0.18698709264487903f},
            {0.49637249435561115f, 0.8681096398768929f},
            {-0.3371347561867868f, 0.9414564016304079f},
            {-0.9346092156607797f, 0.35567627697379833f},
            {-0.877750600058892f, -0.47911781859606817f},
            {-0.20636642697019966f, -0.9784747813917093f},
            {0.6094977881394418f, -0.7927877687333024f},
            {0.998644017504346f, -0.052058873429796634f},
            {0.6886255051458764f, 0.7251171723677399f},
            {-0.10350942208147358f, 0.9946284731196666f},
            {-0.8231759450656516f, 0.567786371327519f},
            {-0.9665253951623188f, -0.2565709658288005f},
            {-0.43319680340129196f, -0.9012993562201753f},
            {0.4034189716368784f, -0.9150153732716426f},
            {0.9575954428121146f, -0.28811624026678895f},
            {0.8413458575409575f, 0.5404971304259356f},
            {0.13605818775026976f, 0.9907008476558967f},
            {-0.664485735550556f, 0.7473009482463117f},
            {-0.999813836664718f, -0.01929487014147803f},
            {-0.6351581891853917f, -0.7723820781910558f},
            {0.17418065221630152f, -0.984713714941304f},
            {0.8615731658120597f, -0.5076334109892543f},
            {0.945766171482902f, 0.32484819358982736f},
            {0.3678149601703667f, 0.9298990026206456f},
            {-0.4676486851245607f, 0.883914423064399f},
            {-0.9757048995218635f, 0.2190889067228882f},
            {-0.8006563717736747f, -0.5991238388999518f},
            {-0.06505704156910719f, -0.9978815467490495f},
            {0.716089639712196f, -0.6980083293893113f},
            {0.9958918787052943f, 0.09055035024139549f},
            {0.5784561871098056f, 0.8157134543418942f},
            {-0.24396482815448167f, 0.9697840804135497f},
            {-0.8955826311865743f, 0.4448952131872543f},
            {-0.9201904205900768f, -0.39147105876968413f},
            {-0.3005599364234082f, -0.9537629289384008f},
            {0.5294967923694863f, -0.84831193960148f},
            {0.9888453593035162f, -0.1489458135829932f},
            {0.7558893631265085f, 0.6546993743025888f},
            {-0.006275422246980369f, 0.9999803093439501f},
            {-0.764046696121276f, 0.6451609459244744f},
            {-0.9868981170802014f, -0.16134468229090512f},
            {-0.5188082666339063f, -0.8548906260290385f},
            {0.31250655826478446f, -0.9499156020623616f},
            {0.9250311403279032f, -0.3798912863223621f},
            {0.889928392754896f, 0.45610026942404636f},
            {0.2317742435145519f, 0.9727696027545563f},
            {-0.5886483179573486f, 0.8083892365475831f},
            {-0.996949901406418f, 0.0780441803450664f},
            {-0.707272817672466f, -0.7069407057042696f},
            {0.07757592706207364f, -0.9969864470194466f},
            {0.8081126726681943f, -0.5890279350532263f},
            {0.9728783545459001f, 0.23131733021125322f},
            {0.4565181982253288f, 0.8897140746830408f},
            {-0.3794567783511009f, 0.9252094645881026f},
            {-0.9497687200714887f, 0.31295267753091066f},
            {-0.8551342041690687f, -0.5184066867432686f},
            {-0.16180818807538452f, -0.9868222283024238f},
            {0.6448020194233159f, -0.7643496292585048f},
            {0.9999772516247822f, -0.006745089543285545f},
            {0.6550543261176665f, 0.7555817823601425f},
            {-0.14848135899860646f, 0.9889152066936411f},
            {-0.848063153443784f, 0.5298951667745091f},
            {-0.9539039899003245f, -0.300111942535184f},
            {-0.3919032080850608f, -0.9200064540494471f},
            {0.44447452934057863f, -0.8957914895596358f},
            {0.9696693887216105f, -0.24442028675267172f},
            {0.8159850520735595f, 0.5780730012658526f},
            {0.0910180879994953f, 0.9958492394217692f},
            {-0.6976719213969089f, 0.7164173993520435f},
            {-0.9979119924958648f, -0.06458835214597858f},
            {-0.5994998228898376f, -0.8003748886334786f},
            {0.2186306161766729f, -0.9758076929755208f},
            {0.8836946816279001f, -0.46806378802740584f},
            {0.9300716543684309f, 0.36737816720699407f},
            {0.32529236260160294f, 0.9456134933645286f},
            {-0.5072286936943775f, 0.8618114946396893f},
            {-0.9846317976415725f, 0.17464313062106204f},
            {-0.7726803123417516f, -0.6347953488483143f},
            {-0.019764457813331488f, -0.9998046640256011f},
            {0.7469887719961158f, -0.6648366525032559f},
            {0.9907646418168752f, 0.13559286310672486f},
            {0.5408922318074902f, 0.8410919055432124f},
            {-0.2876664477065717f, 0.9577306588304888f},
            {-0.9148257956391065f, 0.40384868903250853f},
            {-0.9015027194859215f, -0.4327734358292892f},
            {-0.2570248925062563f, -0.9664047830139022f},
            {0.5673996816983953f, -0.8234425306046317f},
            {0.9945797473944409f, -0.10397656501736473f},
            {0.7254405241129018f, 0.6882848581617921f},
            {-0.05158982732517303f, 0.9986683582233687f},
            {-0.7925014140531963f, 0.609870075281354f},
            {-0.9785715990807187f, -0.20590683687679034f},
            {-0.47953002522651733f, -0.8775254725113429f},
            {0.35523727306945746f, -0.9347761656258549f},
            {0.9412979532686209f, -0.33757689964259285f},
            {0.868342678987353f, 0.4959647082697184f},
            {0.18744846526420056f, 0.9822744386728669f},
            {-0.6246810590458048f, 0.7808800000444446f},
            {-0.9994625758058275f, 0.03278047534097766f},
            {-0.674506266646887f, -0.738269121834361f},
            {0.12268137965007223f, -0.9924461089082646f},
            {0.8339780641890598f, -0.5517975973592748f},
            {0.9613949601033843f, 0.2751721837101493f},
            {0.41572570400265835f, 0.9094900433932711f},
            {-0.42099897262033487f, 0.907061114287578f},
            {-0.9629763390922247f, 0.2695859238694348f},
            {-0.8307604078465821f, -0.5566301687427484f},
            {-0.11691741449967302f, -0.9931416405461567f},
            {0.6787811074228051f, -0.7343406622310046f},
            {0.999255415972447f, 0.03858255628819732f},
            {0.6201369341201711f, 0.7844935837468874f},
            {-0.19314814942146824f, 0.9811696042861612f},
            {-0.8712074932224428f, 0.4909149659086258f},
            {-0.9393222007870077f, -0.34303615422962713f},
            {-0.3498042060103595f, -0.9368228314134226f},
            {0.4846166400948296f, -0.8747266499559725f},
            {0.9797505510481769f, -0.20022202106859724f},
            {0.7889473022428521f, 0.6144608647291752f},
            {0.045790935472179155f, 0.9989510449609544f},
            {-0.7294243101497431f, 0.684061529222753f},
            {-0.9939593229024027f, -0.10974909756074072f},
            {-0.562609414602539f, -0.8267228354174018f},
            {0.26263126874523307f, -0.9648962724963078f},
            {0.9040001019019392f, -0.4275322394408211f},
            {0.9124657316291773f, 0.4091531358824348f},
            {0.28210125132356934f, 0.9593846381935018f},
            {-0.5457662881946498f, 0.8379374431723614f},
            {-0.9915351626845509f, 0.12983844253579577f},
            {-0.7431163048326799f, -0.6691622803863227f},
            {0.02556874420628532f, -0.9996730662170076f},
            {0.7763527553119807f, -0.6302986588273021f},
            {0.9836012681423212f, 0.1803567168386515f},
            {0.5022166799422209f, 0.8647418148718223f},
            {-0.330776879188771f, 0.9437089891455613f},
            {-0.9321888864830543f, 0.3619722087639923f},
            {-0.8809623252471085f, -0.47318641305008735f},
            {-0.21296163248563432f, -0.9770605626515961f},
            {0.604136498566135f, -0.7968808512571063f},
            {0.9982701582127194f, -0.05879363249495786f},
            {0.6935008202914851f, 0.7204558364362367f},
            {-0.09679820929680796f, 0.9953040272584711f},
            {-0.8193274492343137f, 0.5733258505694586f},
            {-0.9682340024187017f, -0.25004582891994304f},
            {-0.4392662937408502f, -0.8983569018954422f},
            {0.39723793388455464f, -0.9177156552457467f},
            {0.9556302892322005f, -0.2945687530984589f},
            {0.8449724198323217f, 0.5348098818484104f},
            {0.14273745857559722f, 0.9897605861618151f},
            {-0.6594300077680133f, 0.7517659641504648f},
            {-0.9999212381512442f, -0.01255059735959867f},
            {-0.6403535266476091f, -0.768080308893523f},
            {0.16753470770767478f, -0.9858661784001437f},
            {0.8581295336101056f, -0.5134332513054668f},
            {0.9479357869928937f, 0.31846152630759517f},
            {0.37407884501651706f, 0.9273969040875156f},
            {-0.461675964944643f, 0.8870486477034012f},
            {-0.9742049295269273f, 0.22566513972130173f},
            {-0.8046793020829978f, -0.5937097108850584f},
            {-0.07178636201352963f, -0.9974200309943962f},
            {0.7113652211526822f, -0.7028225395748172f},
            {0.9964799940037152f, 0.08383091047075403f},
            {0.5839450884626246f, 0.8117931594072332f},
            {-0.23741799789097484f, 0.9714075840127259f},
            {-0.8925614000865144f, 0.45092587758477687f},
            {-0.9228099950981292f, -0.38525538665538556f},
            {-0.30698631553196837f, -0.95171392869712f},
            {0.5237628071845146f, -0.8518641451605984f},
            {0.9878182118285335f, -0.15561227580071732f},
            {0.7602881737752754f, 0.6495859395164404f},
            {4.6967723669845613E-4f, 0.9999998897016406f},
            {-0.7596776469502666f, 0.6502998329417794f},
            {-0.9879639510809196f, -0.15468429579171308f},
            {-0.5245627784110601f, -0.8513717704420726f},
            {0.3060921834538644f, -0.9520018777441807f},
            {0.9224476966294768f, -0.3861220622846781f},
            {0.8929845854878761f, 0.45008724718774934f},
            {0.23833038910266038f, 0.9711841358002995f},
            {-0.5831822693781987f, 0.8123413326200348f},
            {-0.9964008074312266f, 0.0847669213219385f},
            {-0.712025106726807f, -0.7021540054650968f},
            {0.07084939947717452f, -0.9974870237721009f},
            {0.8041212432524677f, -0.5944653279629567f},
            {0.9744164792492415f, 0.22474991650168097f},
            {0.462509014279733f, 0.8866145790082576f},
    };
    /**
     * The 32 3D vertices of a rhombic triacontahedron. These were modified from values taken from Vladimir Bulatov's
     * stellation applet, which has available source but is unlicensed, and is
     * <a href="http://www.bulatov.org/polyhedra/stellation_applet/index.html">available here</a>, but the vertices are
     * mathematical constants so copyright isn't an issue.
     */
    protected static final float[][] grad3f =
            {
                    {-0.448549002408981f,  1.174316525459290f,  0.000000000000001f},
                    { 0.000000000000001f,  1.069324374198914f,  0.660878777503967f},
                    { 0.448549002408981f,  1.174316525459290f,  0.000000000000001f},
                    { 0.000000000000001f,  1.069324374198914f, -0.660878777503967f},
                    {-0.725767493247986f,  0.725767493247986f, -0.725767493247986f},
                    {-1.069324374198914f,  0.660878777503967f,  0.000000000000001f},
                    {-0.725767493247986f,  0.725767493247986f,  0.725767493247986f},
                    { 0.725767493247986f,  0.725767493247986f,  0.725767493247986f},
                    { 1.069324374198914f,  0.660878777503967f,  0.000000000000000f},
                    { 0.725767493247986f,  0.725767493247986f, -0.725767493247986f},
                    {-0.660878777503967f,  0.000000000000003f, -1.069324374198914f},
                    {-1.174316525459290f,  0.000000000000003f, -0.448549002408981f},
                    { 0.000000000000000f,  0.448549002408981f, -1.174316525459290f},
                    {-0.660878777503967f,  0.000000000000001f,  1.069324374198914f},
                    { 0.000000000000001f,  0.448549002408981f,  1.174316525459290f},
                    {-1.174316525459290f,  0.000000000000001f,  0.448549002408981f},
                    { 0.660878777503967f,  0.000000000000001f,  1.069324374198914f},
                    { 1.174316525459290f,  0.000000000000001f,  0.448549002408981f},
                    { 0.660878777503967f,  0.000000000000001f, -1.069324374198914f},
                    { 1.174316525459290f,  0.000000000000001f, -0.448549002408981f},
                    {-0.725767493247986f, -0.725767493247986f, -0.725767493247986f},
                    {-1.069324374198914f, -0.660878777503967f, -0.000000000000001f},
                    {-0.000000000000001f, -0.448549002408981f, -1.174316525459290f},
                    {-0.000000000000001f, -0.448549002408981f,  1.174316525459290f},
                    {-0.725767493247986f, -0.725767493247986f,  0.725767493247986f},
                    { 0.725767493247986f, -0.725767493247986f,  0.725767493247986f},
                    { 1.069324374198914f, -0.660878777503967f,  0.000000000000001f},
                    { 0.725767493247986f, -0.725767493247986f, -0.725767493247986f},
                    {-0.000000000000004f, -1.069324374198914f, -0.660878777503967f},
                    {-0.448549002408981f, -1.174316525459290f, -0.000000000000003f},
                    {-0.000000000000003f, -1.069324374198914f,  0.660878777503967f},
                    { 0.448549002408981f, -1.174316525459290f,  0.000000000000003f},
            };
    // these are the exact vertex positions, before scaling has been applied
//            {
//            {-0.324919696232904f,  0.850650808352036f,  0.000000000000001f },
//            { 0.000000000000001f,  0.850650808352035f,  0.525731112119131f },
//            { 0.324919696232906f,  0.850650808352036f,  0.000000000000001f },
//            { 0.000000000000001f,  0.850650808352036f, -0.525731112119131f },
//            {-0.525731112119131f,  0.525731112119132f, -0.525731112119130f },
//            {-0.850650808352035f,  0.525731112119132f,  0.000000000000001f },
//            {-0.525731112119130f,  0.525731112119131f,  0.525731112119132f },
//            { 0.525731112119132f,  0.525731112119131f,  0.525731112119131f },
//            { 0.850650808352036f,  0.525731112119132f,  0.000000000000000f },
//            { 0.525731112119132f,  0.525731112119132f, -0.525731112119131f },
//            {-0.525731112119132f,  0.000000000000002f, -0.850650808352036f },
//            {-0.850650808352036f,  0.000000000000002f, -0.324919696232905f },
//            { 0.000000000000000f,  0.324919696232906f, -0.850650808352037f },
//            {-0.525731112119131f,  0.000000000000001f,  0.850650808352037f },
//            { 0.000000000000001f,  0.324919696232905f,  0.850650808352037f },
//            {-0.850650808352037f,  0.000000000000001f,  0.324919696232905f },
//            { 0.525731112119133f,  0.000000000000001f,  0.850650808352036f },
//            { 0.850650808352037f,  0.000000000000001f,  0.324919696232905f },
//            { 0.525731112119132f,  0.000000000000001f, -0.850650808352038f },
//            { 0.850650808352038f,  0.000000000000001f, -0.324919696232906f },
//            {-0.525731112119134f, -0.525731112119130f, -0.525731112119133f },
//            {-0.850650808352038f, -0.525731112119130f, -0.000000000000001f },
//            {-0.000000000000001f, -0.324919696232905f, -0.850650808352038f },
//            {-0.000000000000001f, -0.324919696232905f,  0.850650808352038f },
//            {-0.525731112119132f, -0.525731112119131f,  0.525731112119133f },
//            { 0.525731112119133f, -0.525731112119131f,  0.525731112119134f },
//            { 0.850650808352039f, -0.525731112119130f,  0.000000000000001f },
//            { 0.525731112119132f, -0.525731112119134f, -0.525731112119133f },
//            {-0.000000000000003f, -0.850650808352038f, -0.525731112119134f },
//            {-0.324919696232908f, -0.850650808352038f, -0.000000000000002f },
//            {-0.000000000000002f, -0.850650808352042f,  0.525731112119130f },
//            { 0.324919696232902f, -0.850650808352041f,  0.000000000000002f }
//    };
    protected static final float[] grad3d =
            {
                    -0.448549002408981f,  1.174316525459290f,  0.000000000000001f,
                     0.000000000000001f,  1.069324374198914f,  0.660878777503967f,
                     0.448549002408981f,  1.174316525459290f,  0.000000000000001f,
                     0.000000000000001f,  1.069324374198914f, -0.660878777503967f,
                    -0.725767493247986f,  0.725767493247986f, -0.725767493247986f,
                    -1.069324374198914f,  0.660878777503967f,  0.000000000000001f,
                    -0.725767493247986f,  0.725767493247986f,  0.725767493247986f,
                     0.725767493247986f,  0.725767493247986f,  0.725767493247986f,
                     1.069324374198914f,  0.660878777503967f,  0.000000000000000f,
                     0.725767493247986f,  0.725767493247986f, -0.725767493247986f,
                    -0.660878777503967f,  0.000000000000003f, -1.069324374198914f,
                    -1.174316525459290f,  0.000000000000003f, -0.448549002408981f,
                     0.000000000000000f,  0.448549002408981f, -1.174316525459290f,
                    -0.660878777503967f,  0.000000000000001f,  1.069324374198914f,
                     0.000000000000001f,  0.448549002408981f,  1.174316525459290f,
                    -1.174316525459290f,  0.000000000000001f,  0.448549002408981f,
                     0.660878777503967f,  0.000000000000001f,  1.069324374198914f,
                     1.174316525459290f,  0.000000000000001f,  0.448549002408981f,
                     0.660878777503967f,  0.000000000000001f, -1.069324374198914f,
                     1.174316525459290f,  0.000000000000001f, -0.448549002408981f,
                    -0.725767493247986f, -0.725767493247986f, -0.725767493247986f,
                    -1.069324374198914f, -0.660878777503967f, -0.000000000000001f,
                    -0.000000000000001f, -0.448549002408981f, -1.174316525459290f,
                    -0.000000000000001f, -0.448549002408981f,  1.174316525459290f,
                    -0.725767493247986f, -0.725767493247986f,  0.725767493247986f,
                     0.725767493247986f, -0.725767493247986f,  0.725767493247986f,
                     1.069324374198914f, -0.660878777503967f,  0.000000000000001f,
                     0.725767493247986f, -0.725767493247986f, -0.725767493247986f,
                    -0.000000000000004f, -1.069324374198914f, -0.660878777503967f,
                    -0.448549002408981f, -1.174316525459290f, -0.000000000000003f,
                    -0.000000000000003f, -1.069324374198914f,  0.660878777503967f,
                     0.448549002408981f, -1.174316525459290f,  0.000000000000003f,
            };

    protected static final double[] grad4 =
            {
                    -0.5875167, 1.4183908, 1.4183908, 1.4183908,
                    -0.5875167, 1.4183908, 1.4183908, -1.4183908,
                    -0.5875167, 1.4183908, -1.4183908, 1.4183908,
                    -0.5875167, 1.4183908, -1.4183908, -1.4183908,
                    -0.5875167, -1.4183908, 1.4183908, 1.4183908,
                    -0.5875167, -1.4183908, 1.4183908, -1.4183908,
                    -0.5875167, -1.4183908, -1.4183908, 1.4183908,
                    -0.5875167, -1.4183908, -1.4183908, -1.4183908,
                    1.4183908, -0.5875167, 1.4183908, 1.4183908,
                    1.4183908, -0.5875167, 1.4183908, -1.4183908,
                    1.4183908, -0.5875167, -1.4183908, 1.4183908,
                    1.4183908, -0.5875167, -1.4183908, -1.4183908,
                    -1.4183908, -0.5875167, 1.4183908, 1.4183908,
                    -1.4183908, -0.5875167, 1.4183908, -1.4183908,
                    -1.4183908, -0.5875167, -1.4183908, 1.4183908,
                    -1.4183908, -0.5875167, -1.4183908, -1.4183908,
                    1.4183908, 1.4183908, -0.5875167, 1.4183908,
                    1.4183908, 1.4183908, -0.5875167, -1.4183908,
                    1.4183908, -1.4183908, -0.5875167, 1.4183908,
                    1.4183908, -1.4183908, -0.5875167, -1.4183908,
                    -1.4183908, 1.4183908, -0.5875167, 1.4183908,
                    -1.4183908, 1.4183908, -0.5875167, -1.4183908,
                    -1.4183908, -1.4183908, -0.5875167, 1.4183908,
                    -1.4183908, -1.4183908, -0.5875167, -1.4183908,
                    1.4183908, 1.4183908, 1.4183908, -0.5875167,
                    1.4183908, 1.4183908, -1.4183908, -0.5875167,
                    1.4183908, -1.4183908, 1.4183908, -0.5875167,
                    1.4183908, -1.4183908, -1.4183908, -0.5875167,
                    -1.4183908, 1.4183908, 1.4183908, -0.5875167,
                    -1.4183908, 1.4183908, -1.4183908, -0.5875167,
                    -1.4183908, -1.4183908, 1.4183908, -0.5875167,
                    -1.4183908, -1.4183908, -1.4183908, -0.5875167,
                    0.5875167, 1.4183908, 1.4183908, 1.4183908,
                    0.5875167, 1.4183908, 1.4183908, -1.4183908,
                    0.5875167, 1.4183908, -1.4183908, 1.4183908,
                    0.5875167, 1.4183908, -1.4183908, -1.4183908,
                    0.5875167, -1.4183908, 1.4183908, 1.4183908,
                    0.5875167, -1.4183908, 1.4183908, -1.4183908,
                    0.5875167, -1.4183908, -1.4183908, 1.4183908,
                    0.5875167, -1.4183908, -1.4183908, -1.4183908,
                    1.4183908, 0.5875167, 1.4183908, 1.4183908,
                    1.4183908, 0.5875167, 1.4183908, -1.4183908,
                    1.4183908, 0.5875167, -1.4183908, 1.4183908,
                    1.4183908, 0.5875167, -1.4183908, -1.4183908,
                    -1.4183908, 0.5875167, 1.4183908, 1.4183908,
                    -1.4183908, 0.5875167, 1.4183908, -1.4183908,
                    -1.4183908, 0.5875167, -1.4183908, 1.4183908,
                    -1.4183908, 0.5875167, -1.4183908, -1.4183908,
                    1.4183908, 1.4183908, 0.5875167, 1.4183908,
                    1.4183908, 1.4183908, 0.5875167, -1.4183908,
                    1.4183908, -1.4183908, 0.5875167, 1.4183908,
                    1.4183908, -1.4183908, 0.5875167, -1.4183908,
                    -1.4183908, 1.4183908, 0.5875167, 1.4183908,
                    -1.4183908, 1.4183908, 0.5875167, -1.4183908,
                    -1.4183908, -1.4183908, 0.5875167, 1.4183908,
                    -1.4183908, -1.4183908, 0.5875167, -1.4183908,
                    1.4183908, 1.4183908, 1.4183908, 0.5875167,
                    1.4183908, 1.4183908, -1.4183908, 0.5875167,
                    1.4183908, -1.4183908, 1.4183908, 0.5875167,
                    1.4183908, -1.4183908, -1.4183908, 0.5875167,
                    -1.4183908, 1.4183908, 1.4183908, 0.5875167,
                    -1.4183908, 1.4183908, -1.4183908, 0.5875167,
                    -1.4183908, -1.4183908, 1.4183908, 0.5875167,
                    -1.4183908, -1.4183908, -1.4183908, 0.5875167,
            };
//    public static void randomUnitVector4(long seed, final float[] vector)
//    {
//        double mag = 0.0;
//        float t;
//        vector[0] = (t = NumberTools.formCurvedFloat(seed += 0xCB72F6C7));
//        mag += t * t;
//        vector[1] = (t = NumberTools.formCurvedFloat(seed += 0xCB72F6C7));
//        mag += t * t;
//        vector[2] = (t = NumberTools.formCurvedFloat(seed += 0xCB72F6C7));
//        mag += t * t;
//        vector[3] = (t = NumberTools.formCurvedFloat(seed + 0xCB72F6C7));
//        mag += t * t;
//
//        if(mag == 0)
//        {
//            vector[0] = 1f;
//            mag = 1.0;
//        }
//        else
//            mag = Math.sqrt(mag);
//        vector[0] /= mag;
//        vector[1] /= mag;
//        vector[2] /= mag;
//        vector[3] /= mag;
//    }

//    static {
//        final float len = (float) (1.7861513777574233 / Math.sqrt(3.0));
//        for (int i = 0; i < 64; i++) {
////            float x = grad4f[i][0], y = grad4f[i][1], z = grad4f[i][2], w = grad4f[i][3];
////            final float len = 1.4142135623730951f / (float)Math.sqrt(x * x + y * y + z * z + w * w);
//            //final float len = 2f / Math.max(Math.abs(x), Math.max(Math.abs(y), Math.abs(z))), len3 = len * 1.5f;
//            grad4f[i][0] *= len;
//            grad4f[i][1] *= len;
//            grad4f[i][2] *= len;
//            grad4f[i][3] *= len;
//            System.out.println("{" + squidpony.StringKit.join(", ", grad4f[i]) + "},");
//        }
//    }

//    protected static final float[][] phiGrad3f = new float[96][3];
//
//    static {
//        final float root2 = 1.2599211f;
//        int i = 0;
//        for (; i < 16; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][0] * root2;
//            phiGrad3f[i][1] = phiGrad2f[i & 15][1] * root2;
//        }
//        for (; i < 32; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][1] * root2;
//            phiGrad3f[i][1] = phiGrad2f[i & 15][0] * root2;
//        }
//        for (; i < 48; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][0] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][1] * root2;
//        }
//        for (; i < 64; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][1] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][0] * root2;
//        }
//        for (; i < 80; i++) {
//            phiGrad3f[i][1] = phiGrad2f[i & 15][0] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][1] * root2;
//        }
//        for (; i < 96; i++) {
//            phiGrad3f[i][1] = phiGrad2f[i & 15][1] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][0] * root2;
//        }
//    }

//    public static final int[]
//            perm_x = {59, 146, 27, 99, 226, 210, 44, 129, 102, 237, 2, 107, 157, 173, 159, 16, 128, 41, 228, 114, 63, 105, 241, 144, 187, 116, 223, 122, 234, 52, 96, 35, 213, 176, 177, 141, 132, 240, 194, 163, 0, 3, 168, 133, 55, 203, 53, 50, 42, 79, 130, 156, 209, 135, 151, 178, 85, 154, 117, 148, 140, 82, 6, 69, 127, 214, 95, 175, 46, 30, 104, 197, 170, 33, 70, 167, 217, 233, 219, 84, 196, 109, 40, 190, 123, 165, 61, 212, 255, 184, 19, 182, 38, 112, 172, 103, 25, 244, 245, 201, 192, 60, 14, 231, 68, 71, 236, 193, 115, 7, 113, 118, 110, 131, 198, 216, 29, 195, 211, 246, 153, 222, 185, 208, 200, 158, 66, 137, 179, 26, 147, 235, 106, 90, 164, 9, 238, 101, 138, 227, 21, 37, 23, 152, 8, 161, 108, 250, 183, 225, 121, 24, 51, 252, 87, 242, 98, 188, 232, 171, 93, 56, 57, 5, 12, 120, 74, 43, 136, 139, 32, 13, 191, 67, 189, 186, 162, 199, 10, 20, 89, 15, 31, 58, 221, 18, 253, 28, 4, 218, 142, 205, 247, 94, 215, 39, 166, 150, 224, 77, 34, 169, 206, 47, 81, 97, 83, 220, 76, 229, 160, 54, 243, 45, 181, 92, 119, 48, 155, 62, 174, 248, 36, 239, 145, 124, 125, 65, 72, 180, 134, 111, 204, 207, 100, 73, 251, 143, 249, 254, 230, 11, 78, 80, 149, 75, 91, 126, 17, 86, 49, 88, 64, 22, 202, 1},
//            perm_y = {189, 111, 17, 214, 57, 208, 191, 225, 241, 152, 145, 71, 2, 141, 183, 218, 66, 178, 34, 161, 198, 47, 200, 180, 134, 239, 162, 18, 155, 216, 192, 173, 219, 9, 51, 124, 95, 122, 217, 135, 31, 50, 179, 237, 32, 39, 209, 112, 96, 92, 68, 79, 228, 193, 234, 90, 164, 137, 196, 184, 185, 114, 226, 67, 249, 163, 85, 26, 125, 28, 251, 45, 61, 220, 213, 139, 70, 201, 243, 22, 142, 246, 102, 229, 10, 107, 4, 240, 194, 35, 230, 86, 223, 20, 12, 233, 23, 77, 119, 176, 147, 182, 21, 195, 91, 118, 247, 33, 100, 99, 29, 188, 172, 144, 136, 131, 40, 13, 38, 150, 224, 205, 8, 252, 253, 190, 46, 143, 53, 231, 153, 94, 177, 88, 55, 105, 121, 16, 25, 207, 138, 5, 63, 82, 202, 58, 170, 41, 78, 167, 64, 60, 14, 103, 42, 154, 19, 80, 72, 37, 83, 129, 187, 244, 215, 242, 81, 15, 151, 186, 59, 101, 168, 175, 89, 248, 232, 212, 204, 199, 108, 73, 98, 210, 44, 1, 76, 48, 49, 250, 106, 203, 113, 43, 221, 146, 245, 148, 115, 165, 181, 84, 93, 3, 206, 65, 123, 158, 6, 126, 238, 109, 130, 227, 140, 120, 74, 171, 110, 222, 87, 156, 132, 97, 159, 197, 255, 56, 27, 62, 157, 75, 211, 254, 127, 169, 236, 235, 149, 52, 36, 24, 0, 11, 160, 133, 174, 30, 104, 69, 128, 116, 117, 54, 166, 7},
//            perm_z = {253, 212, 4, 237, 36, 182, 213, 233, 147, 239, 226, 41, 74, 65, 68, 165, 70, 231, 217, 116, 113, 193, 162, 112, 228, 254, 183, 176, 151, 80, 17, 60, 155, 246, 174, 3, 202, 208, 127, 7, 57, 1, 132, 79, 224, 99, 238, 195, 236, 9, 115, 154, 23, 227, 76, 158, 130, 16, 89, 214, 61, 114, 187, 90, 49, 24, 64, 33, 96, 242, 25, 37, 215, 35, 46, 109, 134, 141, 136, 225, 138, 43, 21, 184, 189, 13, 230, 188, 40, 50, 243, 244, 211, 156, 85, 120, 223, 58, 234, 71, 6, 28, 179, 67, 125, 69, 192, 131, 44, 175, 34, 15, 32, 77, 191, 222, 83, 47, 128, 218, 198, 84, 149, 26, 121, 190, 255, 150, 117, 92, 140, 101, 172, 62, 93, 97, 27, 103, 106, 161, 194, 201, 204, 45, 206, 111, 81, 252, 249, 73, 42, 248, 108, 118, 63, 56, 31, 216, 153, 180, 19, 126, 38, 139, 66, 88, 247, 143, 177, 137, 12, 199, 104, 235, 102, 75, 100, 129, 251, 18, 159, 107, 196, 22, 10, 152, 209, 94, 181, 250, 51, 210, 185, 144, 200, 169, 232, 122, 145, 173, 95, 171, 166, 229, 14, 5, 0, 105, 2, 163, 157, 48, 53, 133, 110, 52, 160, 186, 123, 124, 91, 20, 221, 240, 87, 178, 98, 207, 142, 148, 59, 203, 245, 205, 72, 11, 164, 39, 170, 135, 168, 197, 55, 86, 219, 167, 8, 82, 78, 220, 29, 146, 241, 54, 119, 30},
//            perm_w = {57, 1, 140, 48, 61, 156, 230, 173, 2, 231, 12, 214, 142, 242, 255, 195, 198, 220, 157, 139, 194, 99, 247, 248, 155, 178, 29, 41, 23, 193, 0, 30, 95, 171, 174, 222, 91, 54, 8, 67, 32, 129, 46, 124, 172, 148, 17, 105, 228, 118, 191, 33, 224, 5, 25, 158, 185, 92, 63, 199, 53, 107, 34, 180, 125, 69, 200, 116, 121, 216, 42, 233, 70, 43, 72, 26, 202, 62, 51, 15, 10, 16, 217, 207, 14, 175, 59, 52, 223, 246, 89, 109, 83, 13, 68, 90, 147, 239, 234, 18, 151, 114, 76, 143, 100, 197, 106, 176, 232, 208, 85, 165, 40, 186, 251, 101, 44, 65, 93, 218, 253, 144, 123, 11, 113, 167, 102, 240, 177, 137, 4, 184, 181, 20, 110, 37, 138, 111, 132, 94, 6, 122, 119, 75, 78, 84, 21, 3, 74, 235, 127, 112, 19, 58, 149, 161, 159, 73, 136, 150, 215, 35, 38, 86, 211, 190, 128, 203, 168, 9, 166, 244, 36, 28, 153, 225, 108, 254, 55, 169, 104, 141, 145, 22, 49, 212, 183, 79, 189, 227, 170, 60, 245, 205, 64, 252, 241, 80, 162, 97, 206, 163, 192, 146, 66, 182, 187, 135, 130, 152, 81, 71, 134, 39, 179, 188, 87, 126, 209, 229, 219, 133, 204, 210, 27, 103, 98, 154, 31, 250, 196, 7, 236, 77, 226, 56, 96, 88, 221, 45, 160, 50, 115, 237, 164, 201, 213, 82, 117, 24, 243, 131, 249, 47, 238, 120},
//            perm_u = {132, 148, 19, 244, 162, 163, 194, 37, 4, 250, 198, 154, 170, 137, 6, 60, 123, 73, 138, 41, 145, 92, 61, 82, 251, 175, 57, 207, 153, 50, 113, 105, 106, 242, 253, 94, 128, 9, 164, 143, 234, 80, 160, 252, 136, 239, 232, 150, 89, 167, 100, 131, 127, 178, 31, 188, 217, 5, 27, 33, 119, 152, 83, 195, 72, 88, 223, 176, 110, 111, 134, 233, 200, 190, 130, 86, 102, 69, 202, 240, 63, 13, 70, 229, 93, 24, 241, 22, 191, 99, 245, 139, 85, 254, 53, 45, 46, 182, 185, 26, 76, 197, 104, 67, 174, 20, 108, 184, 68, 171, 172, 90, 29, 107, 32, 79, 59, 126, 211, 112, 157, 201, 215, 237, 51, 84, 23, 135, 12, 28, 155, 124, 42, 43, 74, 173, 140, 114, 78, 18, 34, 1, 142, 180, 243, 193, 2, 161, 25, 212, 181, 218, 115, 39, 177, 71, 17, 186, 249, 225, 226, 122, 117, 214, 8, 129, 44, 7, 98, 216, 40, 116, 0, 103, 96, 30, 209, 47, 236, 11, 247, 58, 151, 52, 81, 141, 147, 169, 255, 16, 219, 75, 192, 208, 87, 56, 230, 231, 14, 97, 64, 54, 10, 222, 238, 205, 66, 120, 183, 133, 206, 109, 213, 144, 121, 158, 55, 235, 125, 3, 221, 118, 189, 165, 166, 62, 49, 146, 196, 77, 224, 203, 38, 156, 228, 48, 204, 35, 36, 210, 149, 227, 168, 199, 179, 246, 91, 248, 21, 65, 95, 101, 187, 220, 159, 15},
//            perm_v = {2, 9, 4, 237, 219, 73, 247, 203, 228, 220, 46, 229, 61, 156, 170, 75, 223, 144, 81, 252, 172, 208, 76, 218, 177, 103, 123, 244, 14, 39, 255, 90, 168, 43, 174, 3, 113, 107, 145, 233, 130, 254, 192, 11, 211, 190, 68, 105, 117, 178, 251, 18, 66, 242, 230, 248, 95, 137, 29, 26, 164, 65, 153, 120, 70, 77, 64, 33, 23, 133, 59, 7, 40, 16, 106, 41, 121, 216, 238, 135, 19, 212, 157, 48, 232, 28, 128, 22, 245, 171, 183, 56, 74, 99, 51, 150, 236, 111, 234, 71, 189, 167, 213, 37, 198, 50, 12, 79, 31, 250, 136, 165, 185, 246, 55, 86, 142, 62, 42, 52, 147, 205, 89, 94, 224, 141, 221, 180, 138, 129, 140, 101, 83, 193, 127, 67, 108, 84, 166, 109, 181, 20, 34, 195, 87, 24, 217, 116, 36, 88, 196, 82, 57, 239, 243, 124, 134, 175, 119, 210, 32, 163, 38, 139, 249, 227, 25, 97, 10, 118, 72, 131, 91, 54, 204, 225, 253, 58, 115, 154, 202, 122, 110, 112, 215, 1, 149, 146, 44, 201, 17, 240, 206, 197, 200, 169, 159, 13, 179, 143, 160, 152, 226, 161, 241, 80, 102, 15, 155, 92, 21, 184, 96, 148, 8, 158, 125, 35, 63, 176, 194, 235, 187, 30, 100, 231, 98, 207, 53, 47, 93, 173, 78, 186, 132, 199, 151, 114, 0, 45, 49, 126, 191, 222, 6, 182, 162, 188, 27, 69, 209, 214, 104, 5, 85, 60};

    protected static float dotf(final float g[], final float x, final float y) {
        return g[0] * x + g[1] * y;
    }

    protected static float dotf(final float g[], final float x, final float y, final float z) {
        return g[0] * x + g[1] * y + g[2] * z;
    }

//    protected static double dot(final float g[], final double x, final double y, final double z) {
//        return g[0] * x + g[1] * y + g[2] * z;
//    }
//    protected static double dot(final float g[], final double x, final double y, final double z, final double w) {
//        return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
//    }

    /**
     * Computes the hashing for an integer point and its dot product with a double point as one step.
     * This code is largely drawn from Jordan Peck's MIT-licensed code, https://github.com/Auburns/FastNoise_Java ,
     * present in SquidLib as {@link FastNoise}.
     * @param seed
     * @param x
     * @param y
     * @param z
     * @param xd
     * @param yd
     * @param zd
     * @return a double between -1.25 and 1.25, I think
     */
    protected static double gradCoord3D(long seed, int x, int y, int z, double xd, double yd, double zd) {
//        seed ^= 0xB4C4D * x ^ 0xEE2C1 * y ^ 0xA7E07 * z;
//        seed = seed * seed * seed * 60493L;
//        seed ^= (seed >>> 13);
//        final int hash = (int)(seed & 31) * 3;
        final int hash =
                ((int)(((seed ^= 0xB4C4D * x ^ 0xEE2C1 * y ^ 0xA7E07 * z) ^ seed >>> 13) * (seed))
                       >>> 27) * 3;
        return xd * grad3d[hash] + yd * grad3d[hash + 1] + zd * grad3d[hash + 2];
    }
    
    /**
     * 2D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method. Roughly
     * 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks because
     * it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good distribution
     * and is fast) instead of a number chosen by hash from a single 256-element array.
     *
     * @param x X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param y Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoise(final double x, final double y) {
        return noise(x, y, seed);
    }

    /**
     * Identical to {@link #getNoise(double, double)}; ignores seed.
     * @param x X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param y Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @param seed ignored entirely.
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoiseWithSeed(final double x, final double y, final long seed) {
        return noise(x, y, seed);
    }
    /**
     * 3D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good
     * distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoise(final double x, final double y, final double z) {
        return noise(x, y, z, seed);
    }
    /**
     * Identical to {@link #getNoise(double, double, double)}; ignores seed.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param seed ignored entirely.
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoiseWithSeed(final double x, final double y, final double z, final long seed) {
        return noise(x, y, z, seed);
    }

    /**
     * 4D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good
     * distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimension)
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoise(final double x, final double y, final double z, final double w) {
        return noise(x, y, z, w, seed);
    }
    /**
     * Identical to {@link #getNoise(double, double, double, double)}; ignores seed.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimension)
     * @param seed ignored entirely.
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoiseWithSeed(final double x, final double y, final double z, final double w, final long seed) {
        return noise(x, y, z, w, seed);
    }


    /**
     * 2D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method. Roughly
     * 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks because
     * it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good distribution
     * and is fast) instead of a number chosen by hash from a single 256-element array.
     *
     * @param xin X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param yin Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin){
        return noise(xin, yin, 123456789);
    }

    /**
     * 2D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method. Roughly
     * 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks because
     * it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good distribution
     * and is fast) instead of a number chosen by hash from a single 256-element array.
     *
     * @param xin X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param yin Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin, final long seed) {
        //xin *= epi;
        //yin *= epi;
        double noise0, noise1, noise2; // from the three corners
        // Skew the input space to figure out which simplex cell we're in
        double skew = (xin + yin) * F2; // Hairy factor for 2D
        int i = fastFloor(xin + skew);
        int j = fastFloor(yin + skew);
        double t = (i + j) * G2;
        double X0 = i - t; // Unskew the cell origin back to (x,y) space
        double Y0 = j - t;
        double x0 = xin - X0; // The x,y distances from the cell origin
        double y0 = yin - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // determine which simplex we are in.
        int i1, j1; // Offsets for second (middle) corner of simplex in (i,j)
        // coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y),
        // where
        // c = (3-sqrt(3))/6
        double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y)
        // unskewed coords
        double y1 = y0 - j1 + G2;
        double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y)
        // unskewed coords
        double y2 = y0 - 1.0 + 2.0 * G2;
        // Work out the hashed gradient indices of the three simplex corners
        /*
        int ii = i & 255;
        int jj = j & 255;
        int gi0 = perm[ii + perm[jj]] & 15;
        int gi1 = perm[ii + i1 + perm[jj + j1]] & 15;
        int gi2 = perm[ii + 1 + perm[jj + 1]] & 15;
        */
        /*
        int hash = (int) rawNoise(i + (j * 0x9E3779B9),
                i + i1 + ((j + j1) * 0x9E3779B9),
                i + 1 + ((j + 1) * 0x9E3779B9),
                seed);
        int gi0 = hash & 15;
        int gi1 = (hash >>>= 4) & 15;
        int gi2 = (hash >>> 4) & 15;
        */
//        int gi0 = determine256(seed + i + determine(j));
//        int gi1 = determine256(seed + i + i1 + determine(j + j1));
//        int gi2 = determine256(seed + i + 1 + determine(j + 1));
        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63);
        final int gi0 = perm_x[i + s0 & 255] ^ perm_y[j + s1 & 255];
        final int gi1 = perm_x[i + i1 + s0 & 255] ^ perm_y[j + j1 + s1 & 255];
        final int gi2 = perm_x[i + 1 + s0 & 255] ^ perm_y[j + 1 + s1 & 255];

        // Calculate the contribution from the three corners
        double t0 = 0.75 - x0 * x0 - y0 * y0;
        if (t0 < 0) {
            noise0 = 0.0;
        } else {
            t0 *= t0;
            noise0 = t0 * t0 * dot(phiGrad2[gi0], x0, y0);
            // for 2D gradient
        }
        double t1 = 0.75 - x1 * x1 - y1 * y1;
        if (t1 < 0) {
            noise1 = 0.0;
        } else {
            t1 *= t1;
            noise1 = t1 * t1 * dot(phiGrad2[gi1], x1, y1);
        }
        double t2 = 0.75 - x2 * x2 - y2 * y2;
        if (t2 < 0) {
            noise2 = 0.0;
        } else {
            t2 *= t2;
            noise2 = t2 * t2 * dot(phiGrad2[gi2], x2, y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return  9.125 * (noise0 + noise1 + noise2);
    }



    /**
     * 3D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very
     * good distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param xin X input
     * @param yin Y input
     * @param zin Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin, final double zin){
        return noise(xin, yin, zin, 123456789);
    }

    /**
     * 3D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very
     * good distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param xin X input
     * @param yin Y input
     * @param zin Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin, final double zin, final long seed){
        double n = 0.0; // Noise contributions are added here
        // Skew the input space to figure out which simplex cell we're in
        double s = (xin + yin + zin) * F3; // Very nice and simple skew
        // factor for 3D
        int i = fastFloor(xin + s);
        int j = fastFloor(yin + s);
        int k = fastFloor(zin + s);
        double t = (i + j + k) * G3;
        double X0 = i - t; // Unskew the cell origin back to (x,y,z) space
        double Y0 = j - t;
        double Z0 = k - t;
        double x0 = xin - X0; // The x,y,z distances from the cell origin
        double y0 = yin - Y0;
        double z0 = zin - Z0;
        // For the 3D case, the simplex shape is a slightly irregular
        // tetrahedron.
        // determine which simplex we are in.
        int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
        int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // X Y Z order
            else if (x0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // X Z Y order
            else {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // Z X Y order
        } else { // x0<y0
            if (y0 < z0) {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Z Y X order
            else if (x0 < z0) {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Y Z X order
            else {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // Y X Z order
        }
        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in
        // (x,y,z),
        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in
        // (x,y,z), and
        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in
        // (x,y,z), where
        // c = 1/6.
        double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
        double y1 = y0 - j1 + G3;
        double z1 = z0 - k1 + G3;
        double x2 = x0 - i2 + F3; // Offsets for third corner in (x,y,z) coords
        double y2 = y0 - j2 + F3;
        double z2 = z0 - k2 + F3;
        double x3 = x0 - 0.5; // Offsets for last corner in (x,y,z) coords
        double y3 = y0 - 0.5;
        double z3 = z0 - 0.5;

        // Work out the hashed gradient indices of the four simplex corners

        /*
        int ii = i & 255;
        int jj = j & 255;
        int kk = k & 255;

        int gi0 = perm[ii + perm[jj + perm[kk]]] % 12;
        int gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]] % 12;
        int gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]] % 12;
        int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]] % 12;
        */
//        int gi0 = determine32(seed + i + determine(j + determine(k)));
//        int gi1 = determine32(seed + i + i1 + determine(j + j1 + determine(k + k1)));
//        int gi2 = determine32(seed + i + i2 + determine(j + j2 + determine(k + k2)));
//        int gi3 = determine32(seed + i + 1 + determine(j + 1 + determine(k + 1)));


//        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63), s2 = (int)(seed >>> 12 & 63);
//        final int gi0 = (perm_x[(i) + s0 & 255] ^ perm_y[(j) + s1 & 255]           ^ perm_z[(k) + s2 & 255]) & 31;
//        final int gi1 = (perm_x[(i + i1) + s0 & 255] ^ perm_y[(j + j1) + s1 & 255] ^ perm_z[(k + k1) + s2 & 255]) & 31;
//        final int gi2 = (perm_x[(i + i2) + s0 & 255] ^ perm_y[(j + j2) + s1 & 255] ^ perm_z[(k + k2) + s2 & 255]) & 31;
//        final int gi3 = (perm_x[(i + 1) + s0 & 255] ^ perm_y[(j + 1) + s1 & 255]   ^ perm_z[(k + 1) + s2  & 255]) & 31;

        /*
        int hash = (int) rawNoise(i + ((j + k * 0x632BE5AB) * 0x9E3779B9),
                i + i1 + ((j + j1 + (k + k1) * 0x632BE5AB) * 0x9E3779B9),
                i + i2 + ((j + j2 + (k + k2) * 0x632BE5AB) * 0x9E3779B9),
                i + 1 + ((j + 1 + ((k + 1) * 0x632BE5AB)) * 0x9E3779B9),
                seed);
        int gi0 = (hash >>>= 4) % 12;
        int gi1 = (hash >>>= 4) % 12;
        int gi2 = (hash >>>= 4) % 12;
        int gi3 = (hash >>> 4) % 12;
        */

        //int hash = (int) rawNoise(i, j, k, seed);
        //int gi0 = (hash >>>= 4) % 12, gi1 = (hash >>>= 4) % 12, gi2 = (hash >>>= 4) % 12, gi3 = (hash >>>= 4) % 12;
        // Calculate the contribution from the four corners
        double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 > 0) {
            t0 *= t0;
            n += t0 * t0 * gradCoord3D(seed, i, j, k, x0, y0, z0);
        }
        double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 > 0) {
            t1 *= t1;
            n += t1 * t1 * gradCoord3D(seed, i + i1, j + j1, k + k1, x1, y1, z1);
        }
        double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 > 0) {
            t2 *= t2;
            n += t2 * t2 * gradCoord3D(seed, i + i2, j + j2, k + k2, x2, y2, z2);
        }
        double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 > 0) {
            t3 *= t3;
            n += t3 * t3 * gradCoord3D(seed, i + 1, j + 1, k + 1, x3, y3, z3);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to stay just inside [-1,1]
//        n *= 31.5;
//        if(n < -1 || n > 1) System.out.println(n);
        return n * 31.5;

    }

    /**
     * 4D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double, double)} and this
     * method. Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in
     * chunks because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very
     * good distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimensional)
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double x, final double y, final double z, final double w) {
        return noise(x, y, z, w, 123456789);
    }

    /**
     * Used by {@link #noise(double, double, double, double, long)} to look up the vertices of the 4D triangle analogue.
     */
    protected static final int[] SIMPLEX = {0, 1, 3, 7, 0, 1, 7, 3,
            0, 0, 0, 0, 0, 3, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 1, 3, 7, 0, 0, 3, 1, 7, 0, 0, 0, 0,
            0, 7, 1, 3, 0, 7, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 1, 7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 7, 0, 0, 0, 0,
            1, 7, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            3, 7, 0, 1, 3, 7, 1, 0, 1, 0, 3, 7, 1, 0, 7, 3,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 1,
            0, 0, 0, 0, 3, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 7, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 1, 3, 7, 0, 3, 1,
            0, 0, 0, 0, 7, 1, 3, 0, 3, 1, 0, 7, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 0, 3, 0, 0, 0, 0,
            7, 3, 0, 1, 7, 3, 1, 0};

    /**
     * 4D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double, double)} and this
     * method. Roughly 20-25% faster than the equivalent method in PerlinNoise.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimensional)
     * @param seed any int; will be used to completely alter the noise
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double x, final double y, final double z, final double w, final long seed) {
        double n = 0.0;
        final double s = (x + y + z + w) * F4;
        final int i = fastFloor(x + s), j = fastFloor(y + s), k = fastFloor(z + s), l = fastFloor(w + s);
        final double[] gradient4DLUT = grad4;
        final double t = (i + j + k + l) * G4,
                X0 = i - t,
                Y0 = j - t,
                Z0 = k - t,
                W0 = l - t,
                x0 = x - X0,
                y0 = y - Y0,
                z0 = z - Z0,
                w0 = w - W0;
        final int c = (x0 > y0 ? 128 : 0) | (x0 > z0 ? 64 : 0) | (y0 > z0 ? 32 : 0) | (x0 > w0 ? 16 : 0) | (y0 > w0 ? 8 : 0) | (z0 > w0 ? 4 : 0);
        final int i1 = SIMPLEX[c] >>> 2,
                j1 = SIMPLEX[c | 1] >>> 2,
                k1 = SIMPLEX[c | 2] >>> 2,
                l1 = SIMPLEX[c | 3] >>> 2,
                i2 = SIMPLEX[c] >>> 1 & 1,
                j2 = SIMPLEX[c | 1] >>> 1 & 1,
                k2 = SIMPLEX[c | 2] >>> 1 & 1,
                l2 = SIMPLEX[c | 3] >>> 1 & 1,
                i3 = SIMPLEX[c] & 1,
                j3 = SIMPLEX[c | 1] & 1,
                k3 = SIMPLEX[c | 2] & 1,
                l3 = SIMPLEX[c | 3] & 1;
        final double x1 = x0 - i1 + G4,
                y1 = y0 - j1 + G4,
                z1 = z0 - k1 + G4,
                w1 = w0 - l1 + G4,
                x2 = x0 - i2 + 2 * G4,
                y2 = y0 - j2 + 2 * G4,
                z2 = z0 - k2 + 2 * G4,
                w2 = w0 - l2 + 2 * G4,
                x3 = x0 - i3 + 3 * G4,
                y3 = y0 - j3 + 3 * G4,
                z3 = z0 - k3 + 3 * G4,
                w3 = w0 - l3 + 3 * G4,
                x4 = x0 - 1 + 4 * G4,
                y4 = y0 - 1 + 4 * G4,
                z4 = z0 - 1 + 4 * G4,
                w4 = w0 - 1 + 4 * G4;
        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63), s2 = (int)(seed >>> 12 & 63), s3 = (int)(seed >>> 18 & 63);
        final int h0 = (perm_x[(i) + s0 & 255] ^ perm_y[(j) + s1 & 255]           ^ perm_z[(k) + s2 & 255]      ^ perm_w[(l) + s3 & 255]) & 252;
        final int h1 = (perm_x[(i + i1) + s0 & 255] ^ perm_y[(j + j1) + s1 & 255] ^ perm_z[(k + k1) + s2 & 255] ^ perm_w[(l + l1) + s3 & 255]) & 252;
        final int h2 = (perm_x[(i + i2) + s0 & 255] ^ perm_y[(j + j2) + s1 & 255] ^ perm_z[(k + k2) + s2 & 255] ^ perm_w[(l + l2) + s3 & 255]) & 252;
        final int h3 = (perm_x[(i + i3) + s0 & 255] ^ perm_y[(j + j3) + s1 & 255] ^ perm_z[(k + k3) + s2 & 255] ^ perm_w[(l + l3) + s3 & 255]) & 252;
        final int h4 = (perm_x[(i + 1) + s0 & 255] ^ perm_y[(j + 1) + s1 & 255]   ^ perm_z[(k + 1) + s2  & 255] ^ perm_w[(l + 1) + s3 & 255]) & 252;
//        final int h0 = hash256_alt(i, j, k, l, seed) & 252;
//        final int h1 = hash256_alt(i + i1, j + j1, k + k1, l + l1, seed) & 252;
//        final int h2 = hash256_alt(i + i2, j + j2, k + k2, l + l2, seed) & 252;
//        final int h3 = hash256_alt(i + i3, j + j3, k + k3, l + l3, seed) & 252;
//        final int h4 = hash256_alt(i + 1, j + 1, k + 1, l + 1, seed) & 252;
        double t0 = 0.62 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
        if(t0 > 0) {
            t0 *= t0;
            n += t0 * t0 * (x0 * gradient4DLUT[h0] + y0 * gradient4DLUT[h0 | 1] + z0 * gradient4DLUT[h0 | 2] + w0 * gradient4DLUT[h0 | 3]);
        }
        double t1 = 0.62 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
        if (t1 > 0) {
            t1 *= t1;
            n += t1 * t1 * (x1 * gradient4DLUT[h1] + y1 * gradient4DLUT[h1 | 1] + z1 * gradient4DLUT[h1 | 2] + w1 * gradient4DLUT[h1 | 3]);
        }
        double t2 = 0.62 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
        if (t2 > 0) {
            t2 *= t2;
            n += t2 * t2 * (x2 * gradient4DLUT[h2] + y2 * gradient4DLUT[h2 | 1] + z2 * gradient4DLUT[h2 | 2] + w2 * gradient4DLUT[h2 | 3]);
        }
        double t3 = 0.62 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
        if (t3 > 0) {
            t3 *= t3;
            n += t3 * t3 * (x3 * gradient4DLUT[h3] + y3 * gradient4DLUT[h3 | 1] + z3 * gradient4DLUT[h3 | 2] + w3 * gradient4DLUT[h3 | 3]);
        }
        double t4 = 0.62 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
        if (t4 > 0) {
            t4 *= t4;
            n += t4 * t4 * (x4 * gradient4DLUT[h4] + y4 * gradient4DLUT[h4 | 1] + z4 * gradient4DLUT[h4 | 2] + w4 * gradient4DLUT[h4 | 3]);
        }
        //n *= 14.75;
        //if(n > 1.0 || n < -1.0) System.out.printf("x: %f, y: %f, z: %f, w: %f, n is %f\n", x, y, z, w, n);
        //return NumberTools.bounce(5.0 + 41.0 * n);
        return n * 14.75;//NumberTools.sway(0.5 + 12.75 * n);
    }


//    public static double noise(final double x, final double y, final double z, final double w, final long seed)
//    {
//        // The skewing and unskewing factors are hairy again for the 4D case
//
//        // Skew the (x,y,z,w) space to figure out which cell of 24 simplices
//        // we're in
//        double s = (x + y + z + w) * F4; // Factor for 4D skewing
//        int i = fastFloor(x + s);
//        int j = fastFloor(y + s);
//        int k = fastFloor(z + s);
//        int l = fastFloor(w + s);
//        double t = (i + j + k + l) * G4; // Factor for 4D unskewing
//        double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
//        double Y0 = j - t;
//        double Z0 = k - t;
//        double W0 = l - t;
//        double x0 = x - X0; // The x,y,z,w distances from the cell origin
//        double y0 = y - Y0;
//        double z0 = z - Z0;
//        double w0 = w - W0;
//        // For the 4D case, the simplex is a 4D shape I won't even try to
//        // describe.
//        // To find out which of the 24 possible simplices we're in, we need
//        // to figure out the magnitude ordering of x0, y0, z0 and w0.
//        // The method below is a good way of finding the ordering of x,y,z,w
//        // and
//        // then find the correct traversal order for the simplex were in.
//        // First, six pair-wise comparisons are performed between each
//        // possible pair
//        // of the four coordinates, and the results are used to add up binary
//        // bits
//        // for an integer index.
//        int c = (x0 > y0 ? 32 : 0) | (x0 > z0 ? 16 : 0) | (y0 > z0 ? 8 : 0) |
//                (x0 > w0 ? 4 : 0) | (y0 > w0 ? 2 : 0) | (z0 > w0 ? 1 : 0);
//
//        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some
//        // order.
//        // Many values of c will never occur, since e.g. x>y>z>w makes x<z,
//        // y<w and x<w
//        // impossible. Only the 24 indices which have non-zero entries make
//        // any sense.
//        // We use a thresholding to set the coordinates in turn from the
//        // largest magnitude.
//        // The number 3 in the "simplex" array is at the position of the
//        // largest coordinate.
//
//        // The integer offsets for the second simplex corner
//        int i1 = simplex[c][0] >= 3 ? 1 : 0;
//        int j1 = simplex[c][1] >= 3 ? 1 : 0;
//        int k1 = simplex[c][2] >= 3 ? 1 : 0;
//        int l1 = simplex[c][3] >= 3 ? 1 : 0;
//        // The number 2 in the "simplex" array is at the second largest
//        // coordinate.
//
//        // The integer offsets for the third simplex corner
//        int i2 = simplex[c][0] >= 2 ? 1 : 0;
//        int j2 = simplex[c][1] >= 2 ? 1 : 0;
//        int k2 = simplex[c][2] >= 2 ? 1 : 0;
//        int l2 = simplex[c][3] >= 2 ? 1 : 0;
//        // The number 1 in the "simplex" array is at the second smallest
//        // coordinate.
//
//        // The integer offsets for the fourth simplex corner
//        int i3 = simplex[c][0] >= 1 ? 1 : 0;
//        int j3 = simplex[c][1] >= 1 ? 1 : 0;
//        int k3 = simplex[c][2] >= 1 ? 1 : 0;
//        int l3 = simplex[c][3] >= 1 ? 1 : 0;
//        // The fifth corner has all coordinate offsets = 1, so no need to
//        // look that up.
//        double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
//        double y1 = y0 - j1 + G4;
//        double z1 = z0 - k1 + G4;
//        double w1 = w0 - l1 + G4;
//        double x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
//        double y2 = y0 - j2 + 2.0 * G4;
//        double z2 = z0 - k2 + 2.0 * G4;
//        double w2 = w0 - l2 + 2.0 * G4;
//        double x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
//        double y3 = y0 - j3 + 3.0 * G4;
//        double z3 = z0 - k3 + 3.0 * G4;
//        double w3 = w0 - l3 + 3.0 * G4;
//        double x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
//        double y4 = y0 - 1.0 + 4.0 * G4;
//        double z4 = z0 - 1.0 + 4.0 * G4;
//        double w4 = w0 - 1.0 + 4.0 * G4;
//
//        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63), s2 = (int)(seed >>> 12 & 63), s3 = (int)(seed >>> 18 & 63);
//        final int gi0 = (perm_x[(i) + s0 & 255] ^ perm_y[(j) + s1 & 255]           ^ perm_z[(k) + s2 & 255]      ^ perm_w[(l) + s3 & 255]) & 63;
//        final int gi1 = (perm_x[(i + i1) + s0 & 255] ^ perm_y[(j + j1) + s1 & 255] ^ perm_z[(k + k1) + s2 & 255] ^ perm_w[(l + l1) + s3 & 255]) & 63;
//        final int gi2 = (perm_x[(i + i2) + s0 & 255] ^ perm_y[(j + j2) + s1 & 255] ^ perm_z[(k + k2) + s2 & 255] ^ perm_w[(l + l2) + s3 & 255]) & 63;
//        final int gi3 = (perm_x[(i + i3) + s0 & 255] ^ perm_y[(j + j3) + s1 & 255] ^ perm_z[(k + k3) + s2 & 255] ^ perm_w[(l + l3) + s3 & 255]) & 63;
//        final int gi4 = (perm_x[(i + 1) + s0 & 255] ^ perm_y[(j + 1) + s1 & 255]   ^ perm_z[(k + 1) + s2  & 255] ^ perm_w[(l + 1) + s3 & 255]) & 63;
//        // Noise contributions from the five corners are n0 to n4
//
//        // Calculate the contribution from the five corners
//        double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0, n0;
//        if (t0 < 0) {
//            n0 = 0.0;
//        } else {
//            t0 *= t0;
//            n0 = t0 * t0 * dot(grad4f[gi0], x0, y0, z0, w0);
//        }
//        double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1, n1;
//        if (t1 < 0) {
//            n1 = 0.0;
//        } else {
//            t1 *= t1;
//            n1 = t1 * t1 * dot(grad4f[gi1], x1, y1, z1, w1);
//        }
//        double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2,  n2;
//        if (t2 < 0) {
//            n2 = 0.0;
//        } else {
//            t2 *= t2;
//            n2 = t2 * t2 * dot(grad4f[gi2], x2, y2, z2, w2);
//        }
//        double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3, n3;
//        if (t3 < 0) {
//            n3 = 0.0;
//        } else {
//            t3 *= t3;
//            n3 = t3 * t3 * dot(grad4f[gi3], x3, y3, z3, w3);
//        }
//        double t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4, n4;
//        if (t4 < 0) {
//            n4 = 0.0;
//        } else {
//            t4 *= t4;
//            n4 = t4 * t4 * dot(grad4f[gi4], x4, y4, z4, w4);
//        }
//        // Sum up and scale the result to cover the range [-1,1]
//        return 17.0 * (n0 + n1 + n2 + n3 + n4);
//    }

    /**
     * 2D simplex noise returning a float; extremely similar to {@link #noise(double, double)}, but this may be slightly
     * faster or slightly slower. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result
     * will be different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method.
     * This also cannot take a seed, while {@link #noise(double, double, long)} can.
     * @param x x input; works well if between 0.0 and 1.0, but anything is accepted
     * @param y y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static float noiseAlt(double x, double y) {
        //xin *= epi;
        //yin *= epi;
        float noise0, noise1, noise2; // from the three corners
        float xin = (float)x, yin = (float)y;
        // Skew the input space to figure out which simplex cell we're in
        float skew = (xin + yin) * F2f; // Hairy factor for 2D
        int i = fastFloor(xin + skew);
        int j = fastFloor(yin + skew);
        float t = (i + j) * G2f;
        float X0 = i - t; // Unskew the cell origin back to (x,y) space
        float Y0 = j - t;
        float x0 = xin - X0; // The x,y distances from the cell origin
        float y0 = yin - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // determine which simplex we are in.
        int i1, j1; // Offsets for second (middle) corner of simplex in (i,j)
        // coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y),
        // where: c = (3-sqrt(3))/6
        float x1 = x0 - i1 + G2f; // Offsets for middle corner in (x,y)
        // unskewed coords
        float y1 = y0 - j1 + G2f;
        float x2 = x0 - 1f + 2f * G2f; // Offsets for last corner in (x,y)
        // unskewed coords
        float y2 = y0 - 1f + 2f * G2f;
        // Work out the hashed gradient indices of the three simplex corners
//        int gi0 = determine256(i + determine(j));
//        int gi1 = determine256(i + i1 + determine(j + j1));
//        int gi2 = determine256(i + 1 + determine(j + 1));
        final int gi0 = perm_x[i & 255] ^ perm_y[j & 255];
        final int gi1 = perm_x[i + i1 & 255] ^ perm_y[j + j1 & 255];
        final int gi2 = perm_x[i + 1 & 255] ^ perm_y[j + 1 & 255];

        // Calculate the contribution from the three corners
        float t0 = 0.75f - x0 * x0 - y0 * y0;
        if (t0 < 0) {
            noise0 = 0.0f;
        } else {
            t0 *= t0;
            noise0 = t0 * t0 * dotf(phiGrad2f[gi0], x0, y0);
            // for 2D gradient
        }
        float t1 = 0.75f - x1 * x1 - y1 * y1;
        if (t1 < 0) {
            noise1 = 0.0f;
        } else {
            t1 *= t1;
            noise1 = t1 * t1 * dotf(phiGrad2f[gi1], x1, y1);
        }
        float t2 = 0.75f - x2 * x2 - y2 * y2;
        if (t2 < 0) {
            noise2 = 0.0f;
        } else {
            t2 *= t2;
            noise2 = t2 * t2 * dotf(phiGrad2f[gi2], x2, y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return 9.125f * (noise0 + noise1 + noise2);
    }

    /**
     * 3D simplex noise returning a float; extremely similar to {@link #noise(double, double, double)}, but this may
     * be slightly faster or slightly slower. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of
     * the result will be different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)}
     * and this method. This also cannot take a seed, while {@link #noise(double, double, double, long)} can.
     *
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static float noiseAlt(double x, double y, double z) {
        //xin *= epi;
        //yin *= epi;
        //zin *= epi;
        float xin = (float)x, yin = (float)y, zin = (float)z;
        float n0, n1, n2, n3; // Noise contributions from the four corners
        // Skew the input space to figure out which simplex cell we're in
        float s = (xin + yin + zin) * F3f; // Very nice and simple skew
        // factor for 3D
        int i = fastFloor(xin + s);
        int j = fastFloor(yin + s);
        int k = fastFloor(zin + s);
        float t = (i + j + k) * G3f;
        float X0 = i - t; // Unskew the cell origin back to (x,y,z) space
        float Y0 = j - t;
        float Z0 = k - t;
        float x0 = xin - X0; // The x,y,z distances from the cell origin
        float y0 = yin - Y0;
        float z0 = zin - Z0;
        // For the 3D case, the simplex shape is a slightly irregular
        // tetrahedron.
        // determine which simplex we are in.
        int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k)
        // coords
        int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k)
        // coords
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // X Y Z order
            else if (x0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // X Z Y order
            else {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // Z X Y order
        } else { // x0<y0
            if (y0 < z0) {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Z Y X order
            else if (x0 < z0) {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Y Z X order
            else {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // Y X Z order
        }
        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in
        // (x,y,z),
        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in
        // (x,y,z), and
        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in
        // (x,y,z), where
        // c = 1/6.
        float x1 = x0 - i1 + G3f; // Offsets for second corner in (x,y,z)
        // coords
        float y1 = y0 - j1 + G3f;
        float z1 = z0 - k1 + G3f;
        float x2 = x0 - i2 + F3f; // Offsets for third corner in
        // (x,y,z) coords
        float y2 = y0 - j2 + F3f;
        float z2 = z0 - k2 + F3f;
        float x3 = x0 - 0.5f; // Offsets for last corner in
        // (x,y,z) coords
        float y3 = y0 - 0.5f;
        float z3 = z0 - 0.5f;
        // Work out the hashed gradient indices of the four simplex corners

        /*
        int ii = i & 255;
        int jj = j & 255;
        int kk = k & 255;

        int gi0 = perm[ii + perm[jj + perm[kk]]] % 12;
        int gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]] % 12;
        int gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]] % 12;
        int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]] % 12;
        */
//        int gi0 = determine32(i + determine(j + determine(k)));
//        int gi1 = determine32(i + i1 + determine(j + j1 + determine(k + k1)));
//        int gi2 = determine32(i + i2 + determine(j + j2 + determine(k + k2)));
//        int gi3 = determine32(i + 1 + determine(j + 1 + determine(k + 1)));
        final int gi0 = (perm_x[(i) & 255] ^ perm_y[(j) & 255]           ^ perm_z[(k) + 67 & 255]) & 31;
        final int gi1 = (perm_x[(i + i1) & 255] ^ perm_y[(j + j1) & 255] ^ perm_z[(k + k1) + 67 & 255]) & 31;
        final int gi2 = (perm_x[(i + i2) & 255] ^ perm_y[(j + j2) & 255] ^ perm_z[(k + k2) + 67 & 255]) & 31;
        final int gi3 = (perm_x[(i + 1) & 255] ^ perm_y[(j + 1) & 255]   ^ perm_z[(k + 1) + 67  & 255]) & 31;


//        int gi0 = determineBounded(i + determine(j + determine(k)), 92);
//        int gi1 = determineBounded(i + i1 + determine(j + j1 + determine(k + k1)), 92);
//        int gi2 = determineBounded(i + i2 + determine(j + j2 + determine(k + k2)), 92);
//        int gi3 = determineBounded(i + 1 + determine(j + 1 + determine(k + 1)), 92);

        /*
        int hash = (int) rawNoise(i + ((j + k * 0x632BE5AB) * 0x9E3779B9),
                i + i1 + ((j + j1 + (k + k1) * 0x632BE5AB) * 0x9E3779B9),
                i + i2 + ((j + j2 + (k + k2) * 0x632BE5AB) * 0x9E3779B9),
                i + 1 + ((j + 1 + ((k + 1) * 0x632BE5AB)) * 0x9E3779B9),
                seed);
        int gi0 = (hash >>>= 4) % 12;
        int gi1 = (hash >>>= 4) % 12;
        int gi2 = (hash >>>= 4) % 12;
        int gi3 = (hash >>> 4) % 12;
        */

        //int hash = (int) rawNoise(i, j, k, seed);
        //int gi0 = (hash >>>= 4) % 12, gi1 = (hash >>>= 4) % 12, gi2 = (hash >>>= 4) % 12, gi3 = (hash >>>= 4) % 12;
        // Calculate the contribution from the four corners
        float t0 = 0.6f - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 < 0) {
            n0 = 0f;
        } else {
            t0 *= t0;
            n0 = t0 * t0 * dotf(grad3f[gi0], x0, y0, z0);
        }
        float t1 = 0.6f - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 < 0) {
            n1 = 0f;
        } else {
            t1 *= t1;
            n1 = t1 * t1 * dotf(grad3f[gi1], x1, y1, z1);
        }
        float t2 = 0.6f - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 < 0) {
            n2 = 0f;
        } else {
            t2 *= t2;
            n2 = t2 * t2 * dotf(grad3f[gi2], x2, y2, z2);
        }
        float t3 = 0.6f - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 < 0) {
            n3 = 0f;
        } else {
            t3 *= t3;
            n3 = t3 * t3 * dotf(grad3f[gi3], x3, y3, z3);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to stay just inside [-1,1]
        return  31.5f * (n0 + n1 + n2 + n3);
    }

}
