/*
 * Copyright (C) 2002-2015 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */
package squidpony.squidmath;

import java.util.*;

/**
 * A type-specific linked hash map with with a fast, primitive-based implementation, originally from fastutil as Int2DoubleLinkedOpenHashMap.
 * <p>
 * <P>Instances of this class use a hash table to represent a map. The table is filled up to a specified <em>load factor</em>, and then doubled in size to accommodate new entries. If the table is
 * emptied below <em>one fourth</em> of the load factor, it is halved in size. However, halving is not performed when deleting entries from an iterator, as it would interfere with the iteration
 * process.
 * <p>
 * <p>Note that {@link #clear()} does not modify the hash table size. Rather, a family of {@linkplain #trim() trimming methods} lets you control the size of the table; this is particularly useful if
 * you reuse instances of this class.
 * <p>
 * <P>Iterators generated by this map will enumerate pairs in the same order in which they have been added to the map (addition of pairs whose key is already present in the set does not change the
 * iteration order). Note that this order has nothing in common with the natural order of the keys. The order is kept by means of a doubly linked list, represented <i>via</i> an array of longs
 * parallel to the table.
 * <p>
 * <P>This class implements the interface of a sorted map, so to allow easy access of the iteration order: for instance, you can get the first key in iteration order with {@code firstKey()} without
 * having to create an iterator; however, this class partially violates the {@link java.util.SortedMap} contract because all submap methods throw an exception and {@link #comparator()} returns always
 * <code>null</code>.
 * <p>
 * <p>Additional methods, such as <code>getAndMoveToFirst()</code>, make it easy to use instances of this class as a cache (e.g., with LRU policy).
 * <p>
 * <P>The iterators provided by the views of this class using are type-specific {@linkplain java.util.ListIterator list iterators}, and can be started at any element <em>which is a key of the map</em>,
 * or a {@link NoSuchElementException} exception will be thrown. If, however, the provided element is not the first or last key in the set, the first access to the list index will require linear time,
 * as in the worst case the entire key set must be scanned in iteration order to retrieve the positional index of the starting key.
 * <br>
 * Thank you, Sebastiano Vigna, for making FastUtil available to the public with such high quality.
 * <br>
 * See https://github.com/vigna/fastutil for the original library.
 * @author Sebastiano Vigna (responsible for all the hard parts)
 * @author Tommy Ettinger (just responsible for squashing several layers of parent classes into one monster class)
 */
public class IntDoubleOrderedMap implements SortedMap<Integer, Double>, java.io.Serializable, Cloneable {
    private static final long serialVersionUID = 0L;
    /**
     * The array of keys.
     */
    protected int[] key;
    /**
     * The array of values.
     */
    protected double[] value;
    /**
     * The mask for wrapping a position counter.
     */
    protected int mask;
    /**
     * Whether this set contains the key zero.
     */
    protected boolean containsNullKey;
    /**
     * The index of the first entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int first = -1;
    /**
     * The index of the last entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int last = -1;
    /**
     * For each entry, the next and the previous entry in iteration order, stored as <code>((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)</code>. The first entry contains predecessor -1, and the
     * last entry contains successor -1.
     */
    protected long[] link;
    /**
     * The current table size.
     */
    protected int n;
    /**
     * Threshold after which we rehash. It must be the table size times {@link #f}.
     */
    protected int maxFill;
    /**
     * Number of entries in the set (including the key zero, if present).
     */
    protected int size;
    /**
     * The acceptable load factor.
     */
    public final float f;
    /**
     * Cached set of entries.
     */
    protected volatile MapEntrySet entries;
    /**
     * Cached set of keys.
     */
    protected volatile KeySet keys;
    /**
     * Cached collection of values.
     */
    protected volatile DoubleCollection values;
    /**
     * Default return value.
     */
    protected double defRetValue;

    /**
     * The initial default size of a hash table.
     */
    public static final int DEFAULT_INITIAL_SIZE = 16;
    /**
     * The default load factor of a hash table.
     */
    public static final float DEFAULT_LOAD_FACTOR = .1875f; // .75f;
    /**
     * The load factor for a (usually small) table that is meant to be particularly fast.
     */
    public static final float FAST_LOAD_FACTOR = .5f;
    /**
     * The load factor for a (usually very small) table that is meant to be extremely fast.
     */
    public static final float VERY_FAST_LOAD_FACTOR = .25f;

    public void defaultReturnValue(final double rv) {
        defRetValue = rv;
    }

    public double defaultReturnValue() {
        return defRetValue;
    }

    /**
     * Creates a new hash map.
     * <p>
     * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     */

    public IntDoubleOrderedMap(final int expected, final float f) {
        if (f <= 0 || f > 1)
            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
        if (expected < 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");
        this.f = f;
        n = arraySize(expected, f);
        mask = n - 1;
        maxFill = maxFill(n, f);
        key = new int[n + 1];
        value = new double[n + 1];
        link = new long[n + 1];
    }

    /**
     * Creates a new hash map with 0.75f as load factor.
     *
     * @param expected the expected number of elements in the hash map.
     */
    public IntDoubleOrderedMap(final int expected) {
        this(expected, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map with initial expected 16 entries and 0.75f as load factor.
     */
    public IntDoubleOrderedMap() {
        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map copying a given one.
     *
     * @param m a {@link Map} to be copied into the new hash map.
     * @param f the load factor.
     */
    public IntDoubleOrderedMap(final Map<? extends Integer, ? extends Double> m, final float f) {
        this(m.size(), f);
        putAll(m);
    }

    /**
     * Creates a new hash map with 0.75f as load factor copying a given one.
     *
     * @param m a {@link Map} to be copied into the new hash map.
     */
    public IntDoubleOrderedMap(final Map<? extends Integer, ? extends Double> m) {
        this(m, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map copying a given type-specific one.
     *
     * @param m a type-specific map to be copied into the new hash map.
     * @param f the load factor.
     */
    public IntDoubleOrderedMap(final IntDoubleOrderedMap m, final float f) {
        this(m.size(), f);
        putAll(m);
    }

    /**
     * Creates a new hash map with 0.75f as load factor copying a given type-specific one.
     *
     * @param m a type-specific map to be copied into the new hash map.
     */
    public IntDoubleOrderedMap(final IntDoubleOrderedMap m) {
        this(m, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map using the elements of two parallel arrays.
     *
     * @param k the array of keys of the new hash map.
     * @param v the array of corresponding values in the new hash map.
     * @param f the load factor.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
     */
    public IntDoubleOrderedMap(final int[] k, final double[] v, final float f) {
        this(k.length, f);
        if (k.length != v.length)
            throw new IllegalArgumentException("The key array and the value array have different lengths (" + k.length + " and " + v.length + ")");
        for (int i = 0; i < k.length; i++)
            this.put(k[i], v[i]);
    }

    /**
     * Creates a new hash map with 0.75f as load factor using the elements of two parallel arrays.
     *
     * @param k the array of keys of the new hash map.
     * @param v the array of corresponding values in the new hash map.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
     */
    public IntDoubleOrderedMap(final int[] k, final double[] v) {
        this(k, v, DEFAULT_LOAD_FACTOR);
    }


    public boolean containsKey(final Object ok) {
        return containsKey(((Integer) ok).intValue());
    }

    /**
     * Delegates to the corresponding type-specific method, taking care of returning <code>null</code> on a missing key.
     * <p>
     * <P>This method must check whether the provided key is in the map using <code>containsKey()</code>. Thus, it probes the map <em>twice</em>. Implementors of subclasses should override it with a
     * more efficient method.
     *
     * @deprecated Please use the corresponding type-specific method instead.
     */
    @Deprecated
    public Double get(final Object ok) {
        final int k = (Integer) ok;
        return containsKey(k) ? get(k) : null;
    }

    private int realSize() {
        return containsNullKey ? size - 1 : size;
    }

    private void ensureCapacity(final int capacity) {
        final int needed = arraySize(capacity, f);
        if (needed > n) rehash(needed);
    }

    private void tryCapacity(final long capacity) {
        final int needed = (int) Math.min(1 << 30, Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity / f))));
        if (needed > n) rehash(needed);
    }

    private double removeEntry(final int pos) {
        final double oldValue = value[pos];
        size--;
        fixPointers(pos);
        shiftKeys(pos);
        if (size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
        return oldValue;
    }

    private double removeNullEntry() {
        containsNullKey = false;
        final double oldValue = value[n];
        size--;
        fixPointers(n);
        if (size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
        return oldValue;
    }

    /**
     * {@inheritDoc}
     */
    public void putAll(Map<? extends Integer, ? extends Double> m) {
        if (f <= .5) ensureCapacity(m.size()); // The resulting map will be sized for m.size() elements
        else
            tryCapacity(size() + m.size()); // The resulting map will be tentatively sized for size() + m.size() elements
        int n = m.size();
        final Iterator<? extends Entry<? extends Integer, ? extends Double>> i = m.entrySet().iterator();
        if (m instanceof IntDoubleOrderedMap) {
            MapEntry e;
            while (n-- != 0) {
                e = (MapEntry) i.next();
                put(e.getIntKey(), e.getDoubleValue());
            }
        } else {
            Entry<? extends Integer, ? extends Double> e;
            while (n-- != 0) {
                e = i.next();
                put(e.getKey(), e.getValue());
            }
        }
    }
    public void putAll(IntDoubleOrderedMap m) {
        if (f <= .5) ensureCapacity(m.size()); // The resulting map will be sized for m.size() elements
        else
            tryCapacity(size() + m.size()); // The resulting map will be tentatively sized for size() + m.size() elements
        int n = m.size();
        final EntryIterator i = m.mapEntrySet().iterator();
        MapEntry e;
        while (n-- != 0) {
            e = i.next();
            put(e.getIntKey(), e.getDoubleValue());
        }
    }
    public void putAll(int[] k, double[] v)
    {
        for (int i = 0, length = Math.min(k.length, v.length); i < length; i++)
            this.put(k[i], v[i]);

    }

    private int insert(final int k, final double v) {
        int pos;
        if (k == 0) {
            if (containsNullKey) return n;
            containsNullKey = true;
            pos = n;
        } else {
            int curr;
            final int[] key = this.key;
            // The starting point.
            if (!((curr = key[pos = HashCommon.mix(k) & mask]) == 0)) {
                if (curr == k) return pos;
                while (!((curr = key[pos = (pos + 1) & mask]) == 0))
                    if (curr == k) return pos;
            }
        }
        key[pos] = k;
        value[pos] = v;
        if (size == 0) {
            first = last = pos;
            // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
            link[pos] = -1L;
        } else {
            link[last] ^= (link[last] ^ (pos & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
            link[pos] = ((last & 0xFFFFFFFFL) << 32) | 0xFFFFFFFFL;
            last = pos;
        }
        if (size++ >= maxFill) rehash(arraySize(size + 1, f));
        return -1;
    }

    public double put(final int k, final double v) {
        final int pos = insert(k, v);
        if (pos < 0) return defRetValue;
        final double oldValue = value[pos];
        value[pos] = v;
        return oldValue;
    }

    /**
     * {@inheritDoc}
     *
     * @deprecated Please use the corresponding type-specific method instead.
     */
    @Deprecated
    @Override
    public Double put(final Integer ok, final Double ov) {
        final double v = ov;
        final int pos = insert(ok, v);
        if (pos < 0) return null;
        final double oldValue = value[pos];
        value[pos] = v;
        return oldValue;
    }

    private double addToValue(final int pos, final double incr) {
        final double oldValue = value[pos];
        value[pos] = oldValue + incr;
        return oldValue;
    }

    /**
     * Adds an increment to value currently associated with a key.
     * <p>
     * <P>Note that this method respects the {@linkplain #defaultReturnValue() default return value} semantics: when called with a key that does not currently appears in the map, the key will be
     * associated with the default return value plus the given increment.
     *
     * @param k    the key.
     * @param incr the increment.
     * @return the old value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
     */
    public double addTo(final int k, final double incr) {
        int pos;
        if (k == 0) {
            if (containsNullKey) return addToValue(n, incr);
            pos = n;
            containsNullKey = true;
        } else {
            int curr;
            final int[] key = this.key;
            // The starting point.
            if (!((curr = key[pos = HashCommon.mix(k) & mask]) == 0)) {
                if (curr == k) return addToValue(pos, incr);
                while (!((curr = key[pos = (pos + 1) & mask]) == 0))
                    if (curr == k) return addToValue(pos, incr);
            }
        }
        key[pos] = k;
        value[pos] = defRetValue + incr;
        if (size == 0) {
            first = last = pos;
            // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
            link[pos] = -1L;
        } else {
            link[last] ^= (link[last] ^ (pos & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
            link[pos] = ((last & 0xFFFFFFFFL) << 32) | 0xFFFFFFFFL;
            last = pos;
        }
        if (size++ >= maxFill) rehash(arraySize(size + 1, f));
        return defRetValue;
    }

    /**
     * Shifts left entries with the specified hash code, starting at the specified position, and empties the resulting free entry.
     *
     * @param pos a starting position.
     */
    protected final void shiftKeys(int pos) {
        // Shift entries with the same hash.
        int last, slot;
        int curr;
        final int[] key = this.key;
        for (; ; ) {
            pos = ((last = pos) + 1) & mask;
            for (; ; ) {
                if ((curr = key[pos]) == 0) {
                    key[last] = 0;
                    return;
                }
                slot = HashCommon.mix(curr) & mask;
                if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) break;
                pos = (pos + 1) & mask;
            }
            key[last] = curr;
            value[last] = value[pos];
            fixPointers(pos, last);
        }
    }

    public double remove(final int k) {
        if (k == 0) {
            if (containsNullKey) return removeNullEntry();
            return defRetValue;
        }
        int curr;
        final int[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(k) & mask]) == 0) return defRetValue;
        if (k == curr) return removeEntry(pos);
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == 0) return defRetValue;
            if (k == curr) return removeEntry(pos);
        }
    }

    /**
     * {@inheritDoc}
     *
     * @deprecated Please use the corresponding type-specific method instead.
     */
    @Deprecated
    @Override
    public Double remove(final Object ok) {
        final int k = (Integer) ok;
        if (k == 0) {
            if (containsNullKey) return removeNullEntry();
            return null;
        }
        int curr;
        final int[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(k) & mask]) == 0) return null;
        if (curr == k) return removeEntry(pos);
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == 0) return null;
            if (curr == k) return removeEntry(pos);
        }
    }

    private double setValue(final int pos, final double v) {
        final double oldValue = value[pos];
        value[pos] = v;
        return oldValue;
    }

    /**
     * Removes the mapping associated with the first key in iteration order.
     *
     * @return the value previously associated with the first key in iteration order.
     * @throws NoSuchElementException is this map is empty.
     */
    public double removeFirstDouble() {
        if (size == 0) throw new NoSuchElementException();
        final int pos = first;
        // Abbreviated version of fixPointers(pos)
        first = (int) link[pos];
        if (0 <= first) {
            // Special case of SET_PREV( link[ first ], -1 )
            link[first] |= 0xFFFFFFFFL << 32;
        }
        size--;
        final double v = value[pos];
        if (pos == n) {
            containsNullKey = false;
        } else shiftKeys(pos);
        if (size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
        return v;
    }

    /**
     * Removes the mapping associated with the last key in iteration order.
     *
     * @return the value previously associated with the last key in iteration order.
     * @throws NoSuchElementException is this map is empty.
     */
    public double removeLastDouble() {
        if (size == 0) throw new NoSuchElementException();
        final int pos = last;
        // Abbreviated version of fixPointers(pos)
        last = (int) (link[pos] >>> 32);
        if (0 <= last) {
            // Special case of SET_NEXT( link[ last ], -1 )
            link[last] |= 0xFFFFFFFFL;
        }
        size--;
        final double v = value[pos];
        if (pos == n) {
            containsNullKey = false;
        } else shiftKeys(pos);
        if (size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
        return v;
    }

    private void moveIndexToFirst(final int i) {
        if (size == 1 || first == i) return;
        if (last == i) {
            last = (int) (link[i] >>> 32);
            // Special case of SET_NEXT( link[ last ], -1 );
            link[last] |= 0xFFFFFFFFL;
        } else {
            final long linki = link[i];
            final int prev = (int) (linki >>> 32);
            final int next = (int) linki;
            link[prev] ^= (link[prev] ^ (linki & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
            link[next] ^= (link[next] ^ (linki & 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L;
        }
        link[first] ^= (link[first] ^ ((i & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L;
        link[i] = (0xFFFFFFFFL << 32) | (first & 0xFFFFFFFFL);
        first = i;
    }

    private void moveIndexToLast(final int i) {
        if (size == 1 || last == i) return;
        if (first == i) {
            first = (int) link[i];
            // Special case of SET_PREV( link[ first ], -1 );
            link[first] |= 0xFFFFFFFFL << 32;
        } else {
            final long linki = link[i];
            final int prev = (int) (linki >>> 32);
            final int next = (int) linki;
            link[prev] ^= (link[prev] ^ (linki & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
            link[next] ^= (link[next] ^ (linki & 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L;
        }
        link[last] ^= (link[last] ^ (i & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
        link[i] = ((last & 0xFFFFFFFFL) << 32) | 0xFFFFFFFFL;
        last = i;
    }

    /**
     * Returns the value to which the given key is mapped; if the key is present, it is moved to the first position of the iteration order.
     *
     * @param k the key.
     * @return the corresponding value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
     */
    public double getAndMoveToFirst(final int k) {
        if (k == 0) {
            if (containsNullKey) {
                moveIndexToFirst(n);
                return value[n];
            }
            return defRetValue;
        }
        int curr;
        final int[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(k) & mask]) == 0) return defRetValue;
        if (k == curr) {
            moveIndexToFirst(pos);
            return value[pos];
        }
        // There's always an unused entry.
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == 0) return defRetValue;
            if (k == curr) {
                moveIndexToFirst(pos);
                return value[pos];
            }
        }
    }

    /**
     * Returns the value to which the given key is mapped; if the key is present, it is moved to the last position of the iteration order.
     *
     * @param k the key.
     * @return the corresponding value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
     */
    public double getAndMoveToLast(final int k) {
        if (k == 0) {
            if (containsNullKey) {
                moveIndexToLast(n);
                return value[n];
            }
            return defRetValue;
        }
        int curr;
        final int[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(k) & mask]) == 0) return defRetValue;
        if (k == curr) {
            moveIndexToLast(pos);
            return value[pos];
        }
        // There's always an unused entry.
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == 0) return defRetValue;
            if (k == curr) {
                moveIndexToLast(pos);
                return value[pos];
            }
        }
    }

    /**
     * Adds a pair to the map; if the key is already present, it is moved to the first position of the iteration order.
     *
     * @param k the key.
     * @param v the value.
     * @return the old value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
     */
    public double putAndMoveToFirst(final int k, final double v) {
        int pos;
        if (k == 0) {
            if (containsNullKey) {
                moveIndexToFirst(n);
                return setValue(n, v);
            }
            containsNullKey = true;
            pos = n;
        } else {
            int curr;
            final int[] key = this.key;
            // The starting point.
            if (!((curr = key[pos = HashCommon.mix(k) & mask]) == 0)) {
                if (curr == k) {
                    moveIndexToFirst(pos);
                    return setValue(pos, v);
                }
                while (!((curr = key[pos = (pos + 1) & mask]) == 0))
                    if (curr == k) {
                        moveIndexToFirst(pos);
                        return setValue(pos, v);
                    }
            }
        }
        key[pos] = k;
        value[pos] = v;
        if (size == 0) {
            first = last = pos;
            // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
            link[pos] = -1L;
        } else {
            link[first] ^= (link[first] ^ ((pos & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L;
            link[pos] = (0xFFFFFFFFL << 32) | (first & 0xFFFFFFFFL);
            first = pos;
        }
        if (size++ >= maxFill) rehash(arraySize(size, f));
        return defRetValue;
    }

    /**
     * Adds a pair to the map; if the key is already present, it is moved to the last position of the iteration order.
     *
     * @param k the key.
     * @param v the value.
     * @return the old value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
     */
    public double putAndMoveToLast(final int k, final double v) {
        int pos;
        if (k == 0) {
            if (containsNullKey) {
                moveIndexToLast(n);
                return setValue(n, v);
            }
            containsNullKey = true;
            pos = n;
        } else {
            int curr;
            final int[] key = this.key;
            // The starting point.
            if (!((curr = key[pos = HashCommon.mix(k) & mask]) == 0)) {
                if (curr == k) {
                    moveIndexToLast(pos);
                    return setValue(pos, v);
                }
                while (!((curr = key[pos = (pos + 1) & mask]) == 0))
                    if (curr == k) {
                        moveIndexToLast(pos);
                        return setValue(pos, v);
                    }
            }
        }
        key[pos] = k;
        value[pos] = v;
        if (size == 0) {
            first = last = pos;
            // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
            link[pos] = -1L;
        } else {
            link[last] ^= (link[last] ^ (pos & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
            link[pos] = ((last & 0xFFFFFFFFL) << 32) | 0xFFFFFFFFL;
            last = pos;
        }
        if (size++ >= maxFill) rehash(arraySize(size, f));
        return defRetValue;
    }

    public Double get(final Integer ok) {
        final int k = ok;
        if (k == 0) return containsNullKey ? value[n] : null;
        int curr;
        final int[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(k) & mask]) == 0) return null;
        if (k == curr) return value[pos];
        // There's always an unused entry.
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == 0) return null;
            if (k == curr) return value[pos];
        }
    }

    public double get(final int k) {
        if (k == 0) return containsNullKey ? value[n] : defRetValue;
        int curr;
        final int[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(k) & mask]) == 0) return defRetValue;
        if (k == curr) return value[pos];
        // There's always an unused entry.
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == 0) return defRetValue;
            if (k == curr) return value[pos];
        }
    }

    public boolean containsKey(final int k) {
        if (k == 0) return containsNullKey;
        int curr;
        final int[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(k) & mask]) == 0) return false;
        if (k == curr) return true;
        // There's always an unused entry.
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == 0) return false;
            if (k == curr) return true;
        }
    }

    public boolean containsValue(final double v) {
        final double value[] = this.value;
        final int key[] = this.key;
        if (containsNullKey && (value[n] == v)) return true;
        for (int i = n; i-- != 0; )
            if (!(key[i] == 0) && (value[i] == v)) return true;
        return false;
    }

    /* Removes all elements from this map.
     *
	 * <P>To increase object reuse, this method does not change the table size. If you want to reduce the table size, you must use {@link #trim()}. */
    public void clear() {
        if (size == 0) return;
        size = 0;
        containsNullKey = false;
        Arrays.fill(key, 0);
        first = last = -1;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * The entry class for a hash map does not record key and value, but rather the position in the hash table of the
     * corresponding entry. This is necessary so that calls to {@link java.util.Map.Entry#setValue(Object)} are reflected in the map
     */
    public final class MapEntry implements Entry<Integer, Double> {
        // The table index this entry refers to, or -1 if this entry has been deleted.
        int index;

        MapEntry(final int index) {
            this.index = index;
        }

        MapEntry() {
        }

        /**
         * {@inheritDoc}
         *
         * @deprecated Please use the corresponding type-specific method instead.
         */
        @Deprecated
        public Integer getKey() {
            return key[index];
        }

        public int getIntKey() {
            return key[index];
        }

        /**
         * {@inheritDoc}
         *
         * @deprecated Please use the corresponding type-specific method instead.
         */
        @Deprecated
        public Double getValue() {
            return value[index];
        }

        public double getDoubleValue() {
            return value[index];
        }

        public double setValue(final double v) {
            final double oldValue = value[index];
            value[index] = v;
            return oldValue;
        }

        public Double setValue(final Double v) {
            return setValue(v.doubleValue());
        }

        @SuppressWarnings("unchecked")
        public boolean equals(final Object o) {
            if (!(o instanceof Entry)) return false;
            Entry<Integer, Double> e = (Entry<Integer, Double>) o;
            return (key[index] == e.getKey()) && (value[index] == e.getValue());
        }

        public int hashCode() {
            return key[index] ^ NumberTools.doubleToMixedIntBits(value[index]);
        }

        public String toString() {
            return key[index] + "=>" + value[index];
        }
    }

    /**
     * Modifies the {@link #link} vector so that the given entry is removed. This method will complete in constant time.
     *
     * @param i the index of an entry.
     */
    protected void fixPointers(final int i) {
        if (size == 0) {
            first = last = -1;
            return;
        }
        if (first == i) {
            first = (int) link[i];
            if (0 <= first) {
                // Special case of SET_PREV( link[ first ], -1 )
                link[first] |= 0xFFFFFFFFL << 32;
            }
            return;
        }
        if (last == i) {
            last = (int) (link[i] >>> 32);
            if (0 <= last) {
                // Special case of SET_NEXT( link[ last ], -1 )
                link[last] |= 0xFFFFFFFFL;
            }
            return;
        }
        final long linki = link[i];
        final int prev = (int) (linki >>> 32);
        final int next = (int) linki;
        link[prev] ^= (link[prev] ^ (linki & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
        link[next] ^= (link[next] ^ (linki & 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L;
    }

    /**
     * Modifies the {@link #link} vector for a shift from s to d. <P>This method will complete in constant time.
     *
     * @param s the source position.
     * @param d the destination position.
     */
    protected void fixPointers(int s, int d) {
        if (size == 1) {
            first = last = d;
            // Special case of SET_UPPER_LOWER( link[ d ], -1, -1 )
            link[d] = -1L;
            return;
        }
        if (first == s) {
            first = d;
            link[(int) link[s]] ^= (link[(int) link[s]] ^ ((d & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L;
            link[d] = link[s];
            return;
        }
        if (last == s) {
            last = d;
            link[(int) (link[s] >>> 32)] ^= (link[(int) (link[s] >>> 32)] ^ (d & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
            link[d] = link[s];
            return;
        }
        final long links = link[s];
        final int prev = (int) (links >>> 32);
        final int next = (int) links;
        link[prev] ^= (link[prev] ^ (d & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
        link[next] ^= (link[next] ^ ((d & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L;
        link[d] = links;
    }

    /**
     * Returns the first key of this map in iteration order.
     *
     * @return the first key in iteration order.
     */
    public int firstIntKey() {
        if (size == 0) throw new NoSuchElementException();
        return key[first];
    }

    /**
     * Returns the last key of this map in iteration order.
     *
     * @return the last key in iteration order.
     */
    public int lastIntKey() {
        if (size == 0) throw new NoSuchElementException();
        return key[last];
    }

    public Comparator<Integer> comparator() {
        return null;
    }

    public IntDoubleOrderedMap tailMap(int from) {
        throw new UnsupportedOperationException();
    }

    public IntDoubleOrderedMap headMap(int to) {
        throw new UnsupportedOperationException();
    }

    public IntDoubleOrderedMap subMap(int from, int to) {
        throw new UnsupportedOperationException();
    }

    public IntDoubleOrderedMap tailMap(Integer from) {
        throw new UnsupportedOperationException();
    }

    public IntDoubleOrderedMap headMap(Integer to) {
        throw new UnsupportedOperationException();
    }

    public IntDoubleOrderedMap subMap(Integer from, Integer to) {
        throw new UnsupportedOperationException();
    }

    /**
     * A list iterator over a linked map.
     * <p>
     * <P>This class provides a list iterator over a linked hash map. The constructor runs in constant time.
     */
    private class MapIterator {
        /**
         * The entry that will be returned by the next call to {@link java.util.ListIterator#previous()} (or <code>null</code> if no previous entry exists).
         */
        int prev = -1;
        /**
         * The entry that will be returned by the next call to {@link java.util.ListIterator#next()} (or <code>null</code> if no next entry exists).
         */
        int next = -1;
        /**
         * The last entry that was returned (or -1 if we did not iterate or used {@link java.util.Iterator#remove()}).
         */
        int curr = -1;
        /**
         * The current index (in the sense of a {@link java.util.ListIterator}). Note that this value is not meaningful when this iterator has been created using the nonempty constructor.
         */
        int index = -1;

        private MapIterator() {
            next = first;
            index = 0;
        }

        private MapIterator(final int from) {
            if (from == 0) {
                if (IntDoubleOrderedMap.this.containsNullKey) {
                    next = (int) link[n];
                    prev = n;
                    return;
                } else throw new NoSuchElementException("The key " + from + " does not belong to this map.");
            }
            if (key[last] == from) {
                prev = last;
                index = size;
                return;
            }
            // The starting point.
            int pos = HashCommon.mix(from) & mask;
            // There's always an unused entry.
            while (!(key[pos] == 0)) {
                if (key[pos] == from) {
                    // Note: no valid index known.
                    next = (int) link[pos];
                    prev = pos;
                    return;
                }
                pos = (pos + 1) & mask;
            }
            throw new NoSuchElementException("The key " + from + " does not belong to this map.");
        }

        public boolean hasNext() {
            return next != -1;
        }

        public boolean hasPrevious() {
            return prev != -1;
        }

        private final void ensureIndexKnown() {
            if (index >= 0) return;
            if (prev == -1) {
                index = 0;
                return;
            }
            if (next == -1) {
                index = size;
                return;
            }
            int pos = first;
            index = 1;
            while (pos != prev) {
                pos = (int) link[pos];
                index++;
            }
        }

        public int nextIndex() {
            ensureIndexKnown();
            return index;
        }

        public int previousIndex() {
            ensureIndexKnown();
            return index - 1;
        }

        public int nextEntry() {
            if (!hasNext()) throw new NoSuchElementException();
            curr = next;
            next = (int) link[curr];
            prev = curr;
            if (index >= 0) index++;
            return curr;
        }

        public int previousEntry() {
            if (!hasPrevious()) throw new NoSuchElementException();
            curr = prev;
            prev = (int) (link[curr] >>> 32);
            next = curr;
            if (index >= 0) index--;
            return curr;
        }

        public void remove() {
            ensureIndexKnown();
            if (curr == -1) throw new IllegalStateException();
            if (curr == prev) {
				/*
				 * If the last operation was a next(), we are removing an entry that preceeds the current index, and thus we must decrement it. */
                index--;
                prev = (int) (link[curr] >>> 32);
            } else next = (int) link[curr];
            size--;
			/*
			 * Now we manually fix the pointers. Because of our knowledge of next and prev, this is going to be faster than calling fixPointers(). */
            if (prev == -1) first = next;
            else link[prev] ^= (link[prev] ^ (next & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
            if (next == -1) last = prev;
            else link[next] ^= (link[next] ^ ((prev & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L;
            int last, slot, pos = curr;
            curr = -1;
            if (pos == n) {
                IntDoubleOrderedMap.this.containsNullKey = false;
            } else {
                int curr;
                final int[] key = IntDoubleOrderedMap.this.key;
                // We have to horribly duplicate the shiftKeys() code because we need to update next/prev.
                for (; ; ) {
                    pos = ((last = pos) + 1) & mask;
                    for (; ; ) {
                        if ((curr = key[pos]) == 0) {
                            key[last] = 0;
                            return;
                        }
                        slot = HashCommon.mix(curr) & mask;
                        if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) break;
                        pos = (pos + 1) & mask;
                    }
                    key[last] = curr;
                    value[last] = value[pos];
                    if (next == pos) next = last;
                    if (prev == pos) prev = last;
                    fixPointers(pos, last);
                }
            }
        }

        public int skip(final int n) {
            int i = n;
            while (i-- != 0 && hasNext())
                nextEntry();
            return n - i - 1;
        }

        public int back(final int n) {
            int i = n;
            while (i-- != 0 && hasPrevious())
                previousEntry();
            return n - i - 1;
        }
    }

    public class EntryIterator extends MapIterator implements Iterator<MapEntry> {
        private MapEntry entry;

        public EntryIterator() {
        }

        public EntryIterator(int from) {
            super(from);
        }

        public MapEntry next() {
            return entry = new MapEntry(nextEntry());
        }

        public MapEntry previous() {
            return entry = new MapEntry(previousEntry());
        }

        @Override
        public void remove() {
            super.remove();
            entry.index = -1; // You cannot use a deleted entry.
        }

        public void set(MapEntry ok) {
            throw new UnsupportedOperationException();
        }

        public void add(MapEntry ok) {
            throw new UnsupportedOperationException();
        }
    }

    public class FastEntryIterator extends MapIterator implements ListIterator<MapEntry> {
        final MapEntry entry = new MapEntry();

        public FastEntryIterator() {
        }

        public FastEntryIterator(int from) {
            super(from);
        }

        public MapEntry next() {
            entry.index = nextEntry();
            return entry;
        }

        public MapEntry previous() {
            entry.index = previousEntry();
            return entry;
        }

        public void set(MapEntry ok) {
            throw new UnsupportedOperationException();
        }

        public void add(MapEntry ok) {
            throw new UnsupportedOperationException();
        }
    }

    public final class MapEntrySet implements Cloneable, SortedSet<MapEntry>, Set<MapEntry>, Collection<MapEntry> {
        public EntryIterator iterator() {
            return new EntryIterator();
        }

        public Comparator<? super MapEntry> comparator() {
            return null;
        }

        public MapEntrySet subSet(MapEntry fromElement, MapEntry toElement) {
            throw new UnsupportedOperationException();
        }

        public MapEntrySet headSet(MapEntry toElement) {
            throw new UnsupportedOperationException();
        }

        public MapEntrySet tailSet(MapEntry fromElement) {
            throw new UnsupportedOperationException();
        }


        public MapEntry first() {
            if (size == 0) throw new NoSuchElementException();
            return new MapEntry(first);
        }

        public MapEntry last() {
            if (size == 0) throw new NoSuchElementException();
            return new MapEntry(last);
        }

        @SuppressWarnings("unchecked")
        public boolean contains(final Object o) {
            if (!(o instanceof Entry)) return false;
            final Entry<Integer, Double> e = (Entry<Integer, Double>) o;
            final int k = e.getKey();
            if (k == 0)
                return IntDoubleOrderedMap.this.containsNullKey && (value[n] == e.getValue());
            int curr;
            final int[] key = IntDoubleOrderedMap.this.key;
            int pos;
            // The starting point.
            if ((curr = key[pos = HashCommon.mix(k) & mask]) == 0) return false;
            if (k == curr) return value[pos] == e.getValue();
            // There's always an unused entry.
            while (true) {
                if ((curr = key[pos = (pos + 1) & mask]) == 0) return false;
                if (k == curr) return value[pos] == e.getValue();
            }
        }

        @SuppressWarnings("unchecked")
        public boolean remove(final Object o) {
            if (!(o instanceof Entry)) return false;
            final Entry<Integer, Double> e = (Entry<Integer, Double>) o;
            final int k = e.getKey();
            final double v = e.getValue();
            if (k == 0) {
                if (containsNullKey && (value[n] == v)) {
                    removeNullEntry();
                    return true;
                }
                return false;
            }
            int curr;
            final int[] key = IntDoubleOrderedMap.this.key;
            int pos;
            // The starting point.
            if ((curr = key[pos = HashCommon.mix(k) & mask]) == 0) return false;
            if (curr == k) {
                if (value[pos] == v) {
                    removeEntry(pos);
                    return true;
                }
                return false;
            }
            while (true) {
                if ((curr = key[pos = (pos + 1) & mask]) == 0) return false;
                if (curr == k) {
                    if (value[pos] == v) {
                        removeEntry(pos);
                        return true;
                    }
                }
            }
        }

        public int size() {
            return size;
        }

        public void clear() {
            IntDoubleOrderedMap.this.clear();
        }

        public EntryIterator iterator(final MapEntry from) {
            return new EntryIterator(from.getIntKey());
        }

        public boolean equals(final Object o) {
            if (o == this) return true;
            if (!(o instanceof Set)) return false;
            Set<?> s = (Set<?>) o;
            if (s.size() != size()) return false;
            return containsAll(s);
        }

        /**
         * Returns a hash code for this set.
         * <p>
         * The hash code of a set is computed by summing the hash codes of its elements.
         *
         * @return a hash code for this set.
         */
        public int hashCode() {
            int h = 0, n = size();
            EntryIterator i = iterator();
            MapEntry k;
            while (n-- != 0) {
                k = i.next(); // We need k because KEY2JAVAHASH() is a macro with repeated evaluation.
                h += k == null ? 0 : k.hashCode();
            }
            return h;
        }

        public EntryIterator fastIterator() {
            return new EntryIterator();
        }

        public EntryIterator fastIterator(final MapEntry from) {
            return new EntryIterator(from.getIntKey());
        }

        public Object[] toArray() {
            final Object[] a = new Object[size()];
            objectUnwrap(iterator(), a);
            return a;
        }

        @SuppressWarnings("unchecked")
        public <T> T[] toArray(T[] a) {
            final int size = size();
            if (a.length < size)
                a = (T[]) new MapEntry[size];
            objectUnwrap(iterator(), a);
            if (size < a.length)
                a[size] = null;
            return a;
        }

        /**
         * Unsupported.
         *
         * @param c ignored
         * @return nothing, throws UnsupportedOperationException
         * @throws UnsupportedOperationException always
         */
        public boolean addAll(Collection<? extends MapEntry> c) {
            throw new UnsupportedOperationException("addAll not supported");
        }

        /**
         * Unsupported.
         *
         * @param k ignored
         * @return nothing, throws UnsupportedOperationException
         * @throws UnsupportedOperationException always
         */
        public boolean add(MapEntry k) {
            throw new UnsupportedOperationException("add not supported");
        }

        /**
         * Checks whether this collection contains all elements from the given
         * collection.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection contains all elements of the
         * argument.
         */
        public boolean containsAll(Collection<?> c) {
            int n = c.size();
            final Iterator<?> i = c.iterator();
            while (n-- != 0)
                if (!contains(i.next()))
                    return false;
            return true;
        }

        /**
         * Retains in this collection only elements from the given collection.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection changed as a result of the
         * call.
         */
        public boolean retainAll(Collection<?> c) {
            boolean retVal = false;
            int n = size();
            final Iterator<?> i = iterator();
            while (n-- != 0) {
                if (!c.contains(i.next())) {
                    i.remove();
                    retVal = true;
                }
            }
            return retVal;
        }

        /**
         * Remove from this collection all elements in the given collection. If the
         * collection is an instance of this class, it uses faster iterators.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection changed as a result of the
         * call.
         */
        public boolean removeAll(Collection<?> c) {
            boolean retVal = false;
            int n = c.size();
            final Iterator<?> i = c.iterator();
            while (n-- != 0)
                if (remove(i.next()))
                    retVal = true;
            return retVal;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        public String toString() {
            final StringBuilder s = new StringBuilder();
            final EntryIterator i = iterator();
            int n = size();
            MapEntry k;
            boolean first = true;
            s.append("{");
            while (n-- != 0) {
                if (first)
                    first = false;
                else
                    s.append(", ");
                k = i.next();
                s.append(key[k.index]).append("=>").append(value[k.index]);
            }
            s.append("}");
            return s.toString();
        }
        public Set<Entry<Integer, Double>> toBoxed()
        {
            return new OrderedSet<Entry<Integer, Double>>(this);
        }
    }

    /**
     * THIS ONE IS BAD; it copies the entry set to allow it to be considered a Set of Map.Entry with the right (boxed)
     * key and value types. Prefer {@code mapEntrySet()}!!!
     * @return a Set of Map.Entry with Integer keys and Double values
     * @see IntDoubleOrderedMap#mapEntrySet strongly preferred variant that allows primitive access
     * @deprecated prefer {@link IntDoubleOrderedMap#mapEntrySet}
     */
    @Override
    public Set<Entry<Integer, Double>> entrySet() {
        if (entries == null) entries = new MapEntrySet();
        return entries.toBoxed();
    }
    public MapEntrySet mapEntrySet() {
        if (entries == null) entries = new MapEntrySet();
        return entries;
    }

    /**
     * An iterator on keys.
     * <p>
     * <P>We simply override the {@link java.util.ListIterator#next()}/{@link java.util.ListIterator#previous()} methods (and possibly their type-specific counterparts) so that they return keys
     * instead of entries.
     */
    public final class KeyIterator extends MapIterator implements Iterator<Integer> {
        public KeyIterator(final int k) {
            super(k);
        }

        public int previousInt() {
            return key[previousEntry()];
        }

        public void set(int k) {
            throw new UnsupportedOperationException();
        }

        public void add(int k) {
            throw new UnsupportedOperationException();
        }

        public Integer previous() {
            return key[previousEntry()];
        }

        public void set(Integer ok) {
            throw new UnsupportedOperationException();
        }

        public void add(Integer ok) {
            throw new UnsupportedOperationException();
        }

        public KeyIterator() {
            super();
        }

        public int nextInt() {
            return key[nextEntry()];
        }

        public Integer next() {
            return key[nextEntry()];
        }
    }

    public final class KeySet implements SortedSet<Integer> {
        public KeyIterator iterator(final int from) {
            return new KeyIterator(from);
        }

        public KeyIterator iterator() {
            return new KeyIterator();
        }

        public int size() {
            return size;
        }

        public boolean contains(int k) {
            return containsKey(k);
        }

        public boolean remove(int k) {
            final int oldSize = size;
            IntDoubleOrderedMap.this.remove(k);
            return size != oldSize;
        }

        public boolean remove(Integer k) {
            final int oldSize = size;
            IntDoubleOrderedMap.this.remove(k);
            return size != oldSize;
        }

        public void clear() {
            IntDoubleOrderedMap.this.clear();
        }

        public int firstInt() {
            if (size == 0) throw new NoSuchElementException();
            return key[first];
        }

        public int lastInt() {
            if (size == 0) throw new NoSuchElementException();
            return key[last];
        }

        public Comparator<Integer> comparator() {
            return null;
        }

        public final SortedSet<Integer> tailSet(Integer from) {
            throw new UnsupportedOperationException();
        }

        public final SortedSet<Integer> headSet(Integer to) {
            throw new UnsupportedOperationException();
        }

        public final SortedSet<Integer> subSet(Integer from, Integer to) {
            throw new UnsupportedOperationException();
        }


        /**
         * Delegates to the corresponding type-specific method.
         *
         * @deprecated Please use the corresponding type-specific method instead.
         */
        @Deprecated
        public Integer first() {
            return firstInt();
        }

        /**
         * Delegates to the corresponding type-specific method.
         *
         * @deprecated Please use the corresponding type-specific method instead.
         */
        @Deprecated
        public Integer last() {
            return lastInt();
        }


        public int[] toArray(int a[]) {
            return toIntArray(a);
        }

        public int[] toIntArray() {
            return toIntArray(null);
        }

        public int[] toIntArray(int a[]) {
            if (a == null || a.length < size()) a = new int[size()];
            unwrap(iterator(), a);
            return a;
        }

        /**
         * Delegates to the type-specific <code>rem()</code> method.
         */
        public boolean remove(Object ok) {
            return rem(ok);
        }

        /**
         * Delegates to the corresponding type-specific method.
         */
        public boolean add(final Integer o) {
            return add(o.intValue());
        }

        /**
         * Delegates to the corresponding type-specific method.
         */
        public boolean rem(final Object o) {
            return rem(o);
        }

        /**
         * Delegates to the corresponding type-specific method.
         */
        public boolean contains(final Object o) {
            return contains(((Integer) o).intValue());
        }

        /**
         * Checks whether this collection contains all elements from the given type-specific collection.
         *
         * @param c a type-specific collection.
         * @return <code>true</code> if this collection contains all elements of the argument.
         */
        public boolean containsAll(Collection<?> c) {
            final Iterator<?> i = c.iterator();
            int n = c.size();
            while (n-- != 0)
                if (!contains(i.next())) return false;
            return true;
        }

        /**
         * Retains in this collection only elements from the given type-specific collection.
         *
         * @param c a type-specific collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean retainAll(Collection<?> c) {
            boolean retVal = false;
            int n = size();
            final Iterator<?> i = iterator();
            while (n-- != 0) {
                if (!c.contains(i.next())) {
                    i.remove();
                    retVal = true;
                }
            }
            return retVal;
        }

        /**
         * Remove from this collection all elements in the given type-specific collection.
         *
         * @param c a type-specific collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean removeAll(Collection<?> c) {
            boolean retVal = false;
            int n = c.size();
            final Iterator<?> i = c.iterator();
            while (n-- != 0)
                if (remove(i.next())) retVal = true;
            return retVal;
        }

        public Object[] toArray() {
            final Object[] a = new Object[size()];
            objectUnwrap(iterator(), a);
            return a;
        }

        @SuppressWarnings("unchecked")
        public <T> T[] toArray(T[] a) {
            objectUnwrap(iterator(), a);
            return a;
        }

        /**
         * Adds all elements of the given collection to this collection.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean addAll(Collection<? extends Integer> c) {
            boolean retVal = false;
            final Iterator<? extends Integer> i = c.iterator();
            int n = c.size();
            while (n-- != 0)
                if (add(i.next())) retVal = true;
            return retVal;
        }

        public boolean add(int k) {
            throw new UnsupportedOperationException();
        }


        /**
         * Unwraps an iterator into an array starting at a given offset for a given number of elements.
         * <p>
         * <P>This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of <code>length</code>, in the given array starting at <code>offset</code>. The
         * number of actually unwrapped elements is returned (it may be less than <code>max</code> if the iterator emits less than <code>max</code> elements).
         *
         * @param i      a type-specific iterator.
         * @param array  an array to contain the output of the iterator.
         * @param offset the first element of the array to be returned.
         * @param max    the maximum number of elements to unwrap.
         * @return the number of elements unwrapped.
         */
        public int unwrap(final KeyIterator i, final int array[], int offset, final int max) {
            if (max < 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
            if (offset < 0 || offset + max > array.length) throw new IllegalArgumentException();
            int j = max;
            while (j-- != 0 && i.hasNext())
                array[offset++] = i.nextInt();
            return max - j - 1;
        }

        /**
         * Unwraps an iterator into an array.
         * <p>
         * <P>This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end
         * of the array has been reached.
         *
         * @param i     a type-specific iterator.
         * @param array an array to contain the output of the iterator.
         * @return the number of elements unwrapped.
         */
        public int unwrap(final KeyIterator i, final int array[]) {
            return unwrap(i, array, 0, array.length);
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        public String toString() {
            final StringBuilder s = new StringBuilder();
            final KeyIterator i = iterator();
            int n = size();
            boolean first = true;
            s.append("{");
            while (n-- != 0) {
                if (first) first = false;
                else s.append(", ");
                s.append(i.nextInt());
            }
            s.append("}");
            return s.toString();
        }
    }

    public KeySet keySet() {
        if (keys == null) keys = new KeySet();
        return keys;
    }

    /**
     * An iterator on values.
     * <p>
     * <P>We simply override the {@link java.util.ListIterator#next()}/{@link java.util.ListIterator#previous()} methods (and possibly their type-specific counterparts) so that they return values
     * instead of entries.
     */
    public final class DoubleIterator extends MapIterator implements ListIterator<Double> {
        public double previousDouble() {
            return value[previousEntry()];
        }

        public Double previous() {
            return value[previousEntry()];
        }

        public void set(Double ok) {
            throw new UnsupportedOperationException();
        }

        public void add(Double ok) {
            throw new UnsupportedOperationException();
        }

        public void set(double v) {
            throw new UnsupportedOperationException();
        }

        public void add(double v) {
            throw new UnsupportedOperationException();
        }

        public DoubleIterator() {
            super();
        }

        public double nextDouble() {
            return value[nextEntry()];
        }

        /**
         * {@inheritDoc}
         *
         * @deprecated Please use the corresponding type-specific method instead.
         */
        @Deprecated
        public Double next() {
            return value[nextEntry()];
        }
    }

    public DoubleCollection values() {
        if (values == null) values = new DoubleCollection();
        return values;
    }

    /**
     * Rehashes the map, making the table as small as possible.
     * <p>
     * <P>This method rehashes the table to the smallest size satisfying the load factor. It can be used when the set will not be changed anymore, so to optimize access speed and size.
     * <p>
     * <P>If the table size is already the minimum possible, this method does nothing.
     *
     * @return true if there was enough memory to trim the map.
     * @see #trim(int)
     */
    public boolean trim() {
        final int l = arraySize(size, f);
        if (l >= n || size > maxFill(l, f)) return true;
        try {
            rehash(l);
        } catch (Exception cantDoIt) {
            return false;
        }
        return true;
    }

    /**
     * Rehashes this map if the table is too large.
     * <p>
     * <P>Let <var>N</var> be the smallest table size that can hold <code>max(n,{@link #size()})</code> entries, still satisfying the load factor. If the current table size is smaller than or equal to
     * <var>N</var>, this method does nothing. Otherwise, it rehashes this map in a table of size <var>N</var>.
     * <p>
     * <P>This method is useful when reusing maps. {@linkplain #clear() Clearing a map} leaves the table size untouched. If you are reusing a map many times, you can call this method with a typical
     * size to avoid keeping around a very large table just because of a few large transient maps.
     *
     * @param n the threshold for the trimming.
     * @return true if there was enough memory to trim the map.
     * @see #trim()
     */
    public boolean trim(final int n) {
        final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / f));
        if (l >= n || size > maxFill(l, f)) return true;
        try {
            rehash(l);
        } catch (Exception cantDoIt) {
            return false;
        }
        return true;
    }

    /**
     * Rehashes the map.
     * <p>
     * <P>This method implements the basic rehashing strategy, and may be overriden by subclasses implementing different rehashing strategies (e.g., disk-based rehashing). However, you should not
     * override this method unless you understand the internal workings of this class.
     *
     * @param newN the new size
     */

    protected void rehash(final int newN) {
        final int key[] = this.key;
        final double value[] = this.value;
        final int mask = newN - 1; // Note that this is used by the hashing macro
        final int newKey[] = new int[newN + 1];
        final double newValue[] = new double[newN + 1];
        int i = first, prev = -1, newPrev = -1, t, pos;
        final long link[] = this.link;
        final long newLink[] = new long[newN + 1];
        first = -1;
        for (int j = size; j-- != 0; ) {
            if (key[i] == 0) pos = newN;
            else {
                pos = HashCommon.mix(key[i]) & mask;
                while (!(newKey[pos] == 0))
                    pos = (pos + 1) & mask;
            }
            newKey[pos] = key[i];
            newValue[pos] = value[i];
            if (prev != -1) {
                newLink[newPrev] ^= (newLink[newPrev] ^ (pos & 0xFFFFFFFFL)) & 0xFFFFFFFFL;
                newLink[pos] ^= (newLink[pos] ^ ((newPrev & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L;
                newPrev = pos;
            } else {
                newPrev = first = pos;
                // Special case of SET(newLink[ pos ], -1, -1);
                newLink[pos] = -1L;
            }
            t = i;
            i = (int) link[i];
            prev = t;
        }
        this.link = newLink;
        this.last = newPrev;
        if (newPrev != -1)
            // Special case of SET_NEXT( newLink[ newPrev ], -1 );
            newLink[newPrev] |= 0xFFFFFFFFL;
        n = newN;
        this.mask = mask;
        maxFill = maxFill(n, f);
        this.key = newKey;
        this.value = newValue;
    }

    /**
     * Returns a deep copy of this map.
     * <p>
     * <P>This method performs a deep copy of this hash map; the data stored in the map, however, is not cloned. Note that this makes a difference only for object keys.
     *
     * @return a deep copy of this map.
     */

    public IntDoubleOrderedMap clone() {
        return new IntDoubleOrderedMap(this);
    }

    /**
     * Returns a hash code for this map.
     *
     * @return a hash code for this map.
     */
    public int hashCode() {
        int h = 0;
        for (int j = realSize(), i = 0, t; j-- != 0; ) {
            while (key[i] == 0)
                i++;
            t = key[i];
            h = h + (t ^ NumberTools.doubleToMixedIntBits(value[i])) | 0;
            i++;
        }
        // Zero / null keys have hash zero.
        if (containsNullKey) h = h + NumberTools.doubleToMixedIntBits(value[n]) | 0;
        return h;
    }
    public long hash64()
    {
        return 31L * CrossHash.hash64(key) + CrossHash.hash64(value);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof Map))
            return false;
        Map<?, ?> m = (Map<?, ?>) o;
        return m.size() == size() && mapEntrySet().containsAll(m.entrySet());
    }


    /**
     * Delegates to the corresponding type-specific method.
     *
     * @deprecated Please use the corresponding type-specific method instead.
     */
    @Deprecated
    public Integer firstKey() {
        return firstIntKey();
    }

    /**
     * Delegates to the corresponding type-specific method.
     *
     * @deprecated Please use the corresponding type-specific method instead.
     */
    @Deprecated
    public Integer lastKey() {
        return lastIntKey();
    }


    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static int maxFill(final int n, final float f) {
        /* We must guarantee that there is always at least
		 * one free entry (even with pathological load factors). */
        return Math.min((int) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static long maxFill(final long n, final float f) {
		/* We must guarantee that there is always at least
		 * one free entry (even with pathological load factors). */
        return Math.min((long) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the least power of two smaller than or equal to 2<sup>30</sup> and larger than or equal to <code>Math.ceil( expected / f )</code>.
     *
     * @param expected the expected number of elements in a hash table.
     * @param f        the load factor.
     * @return the minimum possible size for a backing array.
     * @throws IllegalArgumentException if the necessary size is larger than 2<sup>30</sup>.
     */
    public static int arraySize(final int expected, final float f) {
        final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));
        if (s > (1 << 30))
            throw new IllegalArgumentException("Too large (" + expected + " expected elements with load factor " + f + ")");
        return (int) s;
    }

    public class DoubleCollection implements Collection<Double> {

        public double[] toArray(double a[]) {
            return toDoubleArray(a);
        }

        public double[] toDoubleArray() {
            return toDoubleArray(null);
        }

        public double[] toDoubleArray(double a[]) {
            if (a == null || a.length < size()) a = new double[size()];
            unwrap(iterator(), a);
            return a;
        }

        /**
         * Adds all elements of the given type-specific collection to this collection.
         *
         * @param c a type-specific collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean addAll(DoubleCollection c) {
            boolean retVal = false;
            final DoubleIterator i = c.iterator();
            int n = c.size();
            while (n-- != 0)
                if (add(i.nextDouble())) retVal = true;
            return retVal;
        }

        /**
         * Checks whether this collection contains all elements from the given type-specific collection.
         *
         * @param c a type-specific collection.
         * @return <code>true</code> if this collection contains all elements of the argument.
         */
        public boolean containsAll(DoubleCollection c) {
            final DoubleIterator i = c.iterator();
            int n = c.size();
            while (n-- != 0)
                if (!contains(i.nextDouble())) return false;
            return true;
        }

        /**
         * Retains in this collection only elements from the given type-specific collection.
         *
         * @param c a type-specific collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean retainAll(DoubleCollection c) {
            boolean retVal = false;
            int n = size();
            final DoubleIterator i = iterator();
            while (n-- != 0) {
                if (!c.contains(i.nextDouble())) {
                    i.remove();
                    retVal = true;
                }
            }
            return retVal;
        }

        /**
         * Remove from this collection all elements in the given type-specific collection.
         *
         * @param c a type-specific collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean removeAll(DoubleCollection c) {
            boolean retVal = false;
            int n = c.size();
            final DoubleIterator i = c.iterator();
            while (n-- != 0)
                if (rem(i.nextDouble())) retVal = true;
            return retVal;
        }

        public Object[] toArray() {
            final Object[] a = new Object[size()];
            objectUnwrap(iterator(), a);
            return a;
        }

        @SuppressWarnings("unchecked")
        public <T> T[] toArray(T[] a) {
            objectUnwrap(iterator(), a);
            return a;
        }

        /**
         * Adds all elements of the given collection to this collection.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean addAll(Collection<? extends Double> c) {
            boolean retVal = false;
            final Iterator<? extends Double> i = c.iterator();
            int n = c.size();
            while (n-- != 0)
                if (add(i.next())) retVal = true;
            return retVal;
        }

        public boolean add(double k) {
            throw new UnsupportedOperationException();
        }

        /**
         * Delegates to the type-specific <code>rem()</code> method.
         */
        public boolean remove(Object ok) {
            return rem(((Double) ok).doubleValue());
        }

        /**
         * Delegates to the corresponding type-specific method.
         */
        public boolean add(final Double o) {
            return add(o.doubleValue());
        }

        /**
         * Delegates to the corresponding type-specific method.
         */
        public boolean rem(final Object o) {
            return rem(((Double) o).doubleValue());
        }

        /**
         * Delegates to the corresponding type-specific method.
         */
        public boolean contains(final Object o) {
            return contains(((Double) o).doubleValue());
        }

        public boolean rem(final double k) {
            final DoubleIterator iterator = iterator();
            while (iterator.hasNext())
                if (k == iterator.nextDouble()) {
                    iterator.remove();
                    return true;
                }
            return false;
        }

        /**
         * Checks whether this collection contains all elements from the given collection.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection contains all elements of the argument.
         */
        public boolean containsAll(Collection<?> c) {
            int n = c.size();
            final Iterator<?> i = c.iterator();
            while (n-- != 0)
                if (!contains(i.next())) return false;
            return true;
        }

        /**
         * Retains in this collection only elements from the given collection.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean retainAll(Collection<?> c) {
            boolean retVal = false;
            int n = size();
            final Iterator<?> i = iterator();
            while (n-- != 0) {
                if (!c.contains(i.next())) {
                    i.remove();
                    retVal = true;
                }
            }
            return retVal;
        }

        /**
         * Remove from this collection all elements in the given collection. If the collection is an instance of this class, it uses faster iterators.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean removeAll(Collection<?> c) {
            boolean retVal = false;
            int n = c.size();
            final Iterator<?> i = c.iterator();
            while (n-- != 0)
                if (remove(i.next())) retVal = true;
            return retVal;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        public String toString() {
            final StringBuilder s = new StringBuilder();
            final DoubleIterator i = iterator();
            int n = size();
            boolean first = true;
            s.append("{");
            while (n-- != 0) {
                if (first) first = false;
                else s.append(", ");
                s.append(i.nextDouble());
            }
            s.append("}");
            return s.toString();
        }

        public DoubleIterator iterator() {
            return new DoubleIterator();
        }

        public int size() {
            return size;
        }

        public boolean contains(double v) {
            return containsValue(v);
        }

        public void clear() {
            IntDoubleOrderedMap.this.clear();
        }

        public double sum()
        {
            DoubleIterator i = iterator();
            int j = 0;
            while (i.hasNext())
                j += i.nextDouble();
            return j;
        }
    }

    public boolean containsValue(Object ov) {
        return containsValue(((Double) ov).doubleValue());
    }

    /**
     * Unwraps an iterator into an array starting at a given offset for a given number of elements.
     * <p>
     * <P>This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of <code>length</code>, in the given array starting at <code>offset</code>. The
     * number of actually unwrapped elements is returned (it may be less than <code>max</code> if the iterator emits less than <code>max</code> elements).
     *
     * @param i      a type-specific iterator.
     * @param array  an array to contain the output of the iterator.
     * @param offset the first element of the array to be returned.
     * @param max    the maximum number of elements to unwrap.
     * @return the number of elements unwrapped.
     */
    private static int unwrap(final DoubleIterator i, final double array[], int offset, final int max) {
        if (max < 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
        if (offset < 0 || offset + max > array.length) throw new IllegalArgumentException();
        int j = max;
        while (j-- != 0 && i.hasNext())
            array[offset++] = i.nextDouble();
        return max - j - 1;
    }

    /**
     * Unwraps an iterator into an array.
     * <p>
     * <P>This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end
     * of the array has been reached.
     *
     * @param i     a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @return the number of elements unwrapped.
     */
    private static int unwrap(final DoubleIterator i, final double array[]) {
        return unwrap(i, array, 0, array.length);
    }


    /** Unwraps an iterator into an array starting at a given offset for a given number of elements.
     *
     * <P>This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of <code>length</code>, in the given array starting at <code>offset</code>. The
     * number of actually unwrapped elements is returned (it may be less than <code>max</code> if the iterator emits less than <code>max</code> elements).
     *
     * @param i a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @param offset the first element of the array to be returned.
     * @param max the maximum number of elements to unwrap.
     * @return the number of elements unwrapped. */
    public static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[], int offset, final int max ) {
        if ( max < 0 ) throw new IllegalArgumentException( "The maximum number of elements (" + max + ") is negative" );
        if ( offset < 0 || offset + max > array.length ) throw new IllegalArgumentException();
        int j = max;
        while ( j-- != 0 && i.hasNext() )
            array[ offset++ ] = i.next();
        return max - j - 1;
    }

    /** Unwraps an iterator into an array.
     *
     * <P>This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end
     * of the array has been reached.
     *
     * @param i a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @return the number of elements unwrapped. */
    public static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[] ) {
        return objectUnwrap(i, array, 0, array.length );
    }


}
