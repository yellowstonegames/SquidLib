/*
 * Copyright (C) 2002-2015 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */
package squidpony.squidmath;

import squidpony.annotation.Beta;
import squidpony.annotation.GwtIncompatible;

import java.util.*;

/**
 * A generic linked hash set with with a fast implementation, originally from fastutil as ObjectLinkedOpenHashSet but
 * modified to support indexed access of items, reordering, and optional hash strategies for array keys (which fastutil
 * does differently).
 * <p>
 * Instances of this class use a hash table to represent a set. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em> of
 * the load factor, it is halved in size. However, halving is not performed when
 * deleting entries from an iterator, as it would interfere with the iteration
 * process.
 * </p>
 * <p>
 * Note that {@link #clear()} does not modify the hash table size. Rather, a
 * family of {@linkplain #trim() trimming methods} lets you control the size of
 * the table; this is particularly useful if you reuse instances of this class.
 * </p>
 * <p>
 * Iterators generated by this set will enumerate elements in the same order in
 * which they have been added to the set (addition of elements already present
 * in the set does not change the iteration order). Note that this order has
 * nothing in common with the natural order of the keys. The order is kept by
 * means of an array list, represented <i>via</i> an IntVLA parallel to the
 * table that can be modified with methods like {@link #shuffle(RNG)}.
 * </p>
 * <p>
 * This class implements the interface of a sorted set, so to allow easy access
 * of the iteration order: for instance, you can get the first element in
 * iteration order with {@code first()} without having to create an iterator;
 * however, this class partially violates the {@link SortedSet}
 * contract because all subset methods throw an exception and
 * {@link #comparator()} returns always <code>null</code>.
 * <p>
 * <p>
 * Additional methods, such as <code>addAndMoveToFirst()</code>, make it easy to
 * use instances of this class as a cache (e.g., with LRU policy).
 * </p>
 * <p>
 * This class allows approximately constant-time lookup of keys or values by their index in the ordering, which can
 * allow some novel usage of the data structure. OrderedSet can be used like a list of unique elements, keeping order
 * like a list does but also allowing rapid checks for whether an item exists in the OrderedSet, and {@link OrderedMap}
 * can be used like that but with values associated as well (where OrderedSet uses contains(), OrderedMap uses
 * containsKey()). You can also set the item at a position with {@link #addAt(Object, Object, int)}, or alter an item
 * while keeping index the same with {@link #alter(Object, Object, Object, Object)}. Reordering works here too, both with completely
 * random orders from {@link #shuffle(RNG)} or with a previously-generated ordering from {@link #reorder(int...)} (you
 * can produce such an ordering for a given size and reuse it across multiple Ordered data structures with
 * {@link RNG#randomOrdering(int)}).
 * </p>
 * <p>
 * You can pass an {@link CrossHash.IHasher} instance such as {@link CrossHash#generalHasher} as an extra parameter to
 * most of this class' constructors, which allows the OrderedSet to use arrays (usually primitive arrays) as items. If
 * you expect only one type of array, you can use an instance like {@link CrossHash#intHasher} to hash int arrays, or
 * the aforementioned generalHasher to hash most kinds of arrays (it can't handle most multi-dimensional arrays well).
 * If you aren't using array items, you don't need to give an IHasher to the constructor and can ignore this feature.
 * </p>
 * <br>
 * Thank you, Sebastiano Vigna, for making FastUtil available to the public with such high quality.
 * <br>
 * See https://github.com/vigna/fastutil for the original library.
 *
 * @author Sebastiano Vigna (responsible for all the hard parts)
 * @author Tommy Ettinger (mostly responsible for squashing several layers of parent classes into one monster class)
 */
@Beta
public class TableSet<C, R> implements java.io.Serializable {
    private static final long serialVersionUID = 0L;
    /**
     * The array of column keys.
     */
    protected C[] cols;
    /**
     * The array of row keys.
     */
    protected R[] rows;
    /*
     * The array of values.
     */
    //protected V[] value;
    /**
     * The mask for wrapping a position counter.
     */
    protected int mask;
    /**
     * Whether this set contains the key zero.
     */
    protected boolean containsNull;
    /**
     * The index of the first entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int first = -1;
    /**
     * The index of the last entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int last = -1;
    /*
     * For each entry, the next and the previous entry in iteration order, stored as <code>((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)</code>. The first entry contains predecessor -1, and the
     * last entry contains successor -1.
     */
    //protected long[] link;
    protected IntVLA order;
    /**
     * The current table size.
     */
    protected int n;
    /**
     * Threshold after which we rehash. It must be the table size times {@link #f}.
     */
    protected int maxFill;
    /**
     * Number of entries in the set (including the key zero, if present).
     */
    protected int size;
    /**
     * The acceptable load factor.
     */
    public final float f;

    /**
     * The initial default size of a hash table.
     */
    public static final int DEFAULT_INITIAL_SIZE = 16;
    /**
     * The default load factor of a hash table.
     */
    public static final float DEFAULT_LOAD_FACTOR = .375f; // .1875f; // .75f;
    /**
     * The load factor for a (usually small) table that is meant to be particularly fast.
     */
    public static final float FAST_LOAD_FACTOR = .5f;
    /**
     * The load factor for a (usually very small) table that is meant to be extremely fast.
     */
    public static final float VERY_FAST_LOAD_FACTOR = .25f;

    protected CrossHash.IHasher columnHasher = CrossHash.defaultHasher, rowHasher = CrossHash.defaultHasher;

    /**
     * Creates a new hash map.
     * <p>
     * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     */

    @SuppressWarnings("unchecked")
    public TableSet(final int expected, final float f) {
        if (f <= 0 || f > 1)
            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
        if (expected < 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");
        this.f = f;
        n = arraySize(expected, f);
        mask = n - 1;
        maxFill = maxFill(n, f);
        cols = (C[]) new Object[n + 1];
        rows = (R[]) new Object[n + 1];
        //link = new long[n + 1];
        order = new IntVLA(expected);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor.
     *
     * @param expected the expected number of elements in the hash set.
     */
    public TableSet(final int expected) {
        this(expected, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set with initial expected
     * {@link #DEFAULT_INITIAL_SIZE} elements and
     * {@link #DEFAULT_LOAD_FACTOR} as load factor.
     */
    public TableSet() {
        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor copying a given collection.
     *
     * @param t an existing (non-null) TableSet to be copied into the new TableSet.
     */
    public TableSet(final TableSet<? extends C, ? extends R> t) {
        this(t.size(), t.f);
        int s = t.size();
        for (int i = 0; i < s; i++) {
            add(columnAt(i), rowAt(i));
        }
    }

    /**
     * Creates a new hash set using elements provided by a type-specific
     * iterator.
     *
     * @param c an iterator whose elements will fill the set's columns
     * @param r an iterator whose elements will fill the set's rows
     * @param f the load factor.
     */
    public TableSet(final Iterator<? extends C> c, final Iterator<? extends R> r, final float f) {
        this(DEFAULT_INITIAL_SIZE, f);
        while (c.hasNext() && r.hasNext())
            add(c.next(), r.next());
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor using elements provided by a type-specific iterator.
     *
     * @param c an iterator whose elements will fill the set's columns
     * @param r an iterator whose elements will fill the set's rows
     */
    public TableSet(final Iterator<? extends C> c, final Iterator<? extends R> r) {
        this(c, r, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set and fills it with the elements of a given array.
     *
     * @param c        an array whose elements will be used to fill the set's columns
     * @param offset_c the first element of r to use.
     * @param r        an array whose elements will be used to fill the set's rows
     * @param offset_r the first element of r to use.
     * @param length   the number of elements to use in total.
     * @param f        the load factor.
     */
    public TableSet(final C[] c, final int offset_c, final R[] r, final int offset_r,
                    final int length, final float f) {
        this(length < 0 ? 0 : length, f);
        if (c == null || r == null) throw new NullPointerException("Array passed to TableSet constructor cannot be null");
        if (offset_c < 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset_c + ") is negative");
        if (offset_r < 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset_r + ") is negative");
        if (length < 0) throw new IllegalArgumentException("Length (" + length + ") is negative");
        if (offset_c + length > c.length) {
            throw new ArrayIndexOutOfBoundsException(
                    "Last index (" + (offset_c + length) + ") is greater than array length (" + c.length + ")");
        }
        if (offset_r + length > r.length) {
            throw new ArrayIndexOutOfBoundsException(
                    "Last index (" + (offset_r + length) + ") is greater than array length (" + r.length + ")");
        }
        for (int i = 0; i < length; i++)
            add(c[offset_c + i], r[offset_r + i]);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor and fills it with the elements of a given array.
     *
     * @param c        an array whose elements will be used to fill the set's columns
     * @param offset_c the first element of r to use.
     * @param r        an array whose elements will be used to fill the set's rows
     * @param offset_r the first element of r to use.
     * @param length   the number of elements to use in total.
     */
    public TableSet(final C[] c, final int offset_c, final R[] r, final int offset_r,
                    final int length) {
        this(c, offset_c, r, offset_r, length, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set copying the elements of an array.
     *
     * @param c an array to be copied into the new hash set's columns
     * @param r an array to be copied into the new hash set's rows
     * @param f the load factor.
     */
    public TableSet(final C[] c, final R[] r, final float f) {
        this(c, 0, r, 0, c.length, f);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor copying the elements of an array.
     *
     * @param c an array to be copied into the new hash set's columns
     * @param r an array to be copied into the new hash set's rows
     */
    public TableSet(final C[] c, final R[] r) {
        this(c, r, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map.
     * <p>
     * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     * @param columnHasher   used to hash items; typically only needed when C is an array, where CrossHash has implementations
     */
    @SuppressWarnings("unchecked")
    public TableSet(final int expected, final float f, final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
        if (f <= 0 || f > 1)
            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
        if (expected < 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");
        this.f = f;
        n = arraySize(expected, f);
        mask = n - 1;
        maxFill = maxFill(n, f);
        cols = (C[]) new Object[n + 1];
        rows = (R[]) new Object[n + 1];
        //link = new long[n + 1];
        order = new IntVLA(expected);
        this.columnHasher = columnHasher == null ? CrossHash.defaultHasher : columnHasher;
        this.rowHasher = rowHasher == null ? CrossHash.defaultHasher : rowHasher;
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor.
     *
     * @param columnHasher used to hash items for columns; typically only needed when C is an array, where CrossHash has implementations
     * @param rowHasher    used to hash items for rows; typically only needed when C is an array, where CrossHash has implementations
     */
    public TableSet(final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, columnHasher, rowHasher);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor.
     *
     * @param columnHasher used to hash items for columns; typically only needed when C is an array, where CrossHash has implementations
     * @param rowHasher    used to hash items for rows; typically only needed when C is an array, where CrossHash has implementations
     */
    public TableSet(final int expected, final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
        this(expected, DEFAULT_LOAD_FACTOR, columnHasher, rowHasher);
    }

    /**
     * Creates a new hash set copying a given collection.
     *
     * @param c      a {@link Collection} to be copied into the new hash set.
     * @param f      the load factor.
     * @param columnHasher used to hash items; typically only needed when C is an array, where CrossHash has implementations
     */
    public TableSet(final Collection<? extends C> c, final Collection<? extends R> r,
                    final float f, final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
        this(c.size(), f, columnHasher, rowHasher);
        addAll(c, r);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor copying a given collection.
     *
     * @param c      a {@link Collection} to be copied into the new hash set.
     * @param columnHasher used to hash items; typically only needed when C is an array, where CrossHash has implementations
     */
    public TableSet(final Collection<? extends C> c, final Collection<? extends R> r, final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
        this(c, r, DEFAULT_LOAD_FACTOR, columnHasher, rowHasher);
    }

    /**
     * Creates a new hash set and fills it with the elements of a given array.
     *
     * @param c        an array whose elements will be used to fill the set's columns
     * @param offset_c the first element of r to use.
     * @param r        an array whose elements will be used to fill the set's rows
     * @param offset_r the first element of r to use.
     * @param length   the number of elements to use in total.
     * @param f        the load factor.
     */
    public TableSet(final C[] c, final int offset_c, final R[] r, final int offset_r,
                    final int length, final float f, final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
        this(length < 0 ? 0 : length, f, columnHasher, rowHasher);
        if (c == null || r == null) throw new NullPointerException("Array passed to TableSet constructor cannot be null");
        if (offset_c < 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset_c + ") is negative");
        if (offset_r < 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset_r + ") is negative");
        if (length < 0) throw new IllegalArgumentException("Length (" + length + ") is negative");
        if (offset_c + length > c.length) {
            throw new ArrayIndexOutOfBoundsException(
                    "Last index (" + (offset_c + length) + ") is greater than array length (" + c.length + ")");
        }
        if (offset_r + length > r.length) {
            throw new ArrayIndexOutOfBoundsException(
                    "Last index (" + (offset_r + length) + ") is greater than array length (" + r.length + ")");
        }
        for (int i = 0; i < length; i++)
            add(c[offset_c + i], r[offset_r + i]);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor and fills it with the elements of a given array.
     *
     * @param c        an array whose elements will be used to fill the set's columns
     * @param offset_c the first element of r to use.
     * @param r        an array whose elements will be used to fill the set's rows
     * @param offset_r the first element of r to use.
     * @param length   the number of elements to use in total.
     */
    public TableSet(final C[] c, final int offset_c, final R[] r, final int offset_r,
                    final int length, final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
        this(c, offset_c, r, offset_r, length, DEFAULT_LOAD_FACTOR, columnHasher, rowHasher);
    }

    /**
     * Creates a new hash set copying the elements of an array.
     *
     * @param c        an array whose elements will be used to fill the set's columns
     * @param r        an array whose elements will be used to fill the set's rows
     * @param f        the load factor.
     */
    public TableSet(final C[] c, final R[] r,
                    final float f, final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
        this(c, 0, r, 0, c.length, f, columnHasher, rowHasher);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor copying the elements of an array.
     *
     * @param c        an array whose elements will be used to fill the set's columns
     * @param r        an array whose elements will be used to fill the set's rows
     */
    public TableSet(final C[] c, final R[] r,
                    final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
        this(c, 0, r, 0, c.length, DEFAULT_LOAD_FACTOR, columnHasher, rowHasher);
    }

    private int realSize() {
        return containsNull ? size - 1 : size;
    }

    private void ensureCapacity(final int capacity) {
        final int needed = arraySize(capacity, f);
        if (needed > n)
            rehash(needed);
    }

    private void tryCapacity(final long capacity) {
        final int needed = (int) Math.min(
                1 << 30,
                Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity
                        / f))));
        if (needed > n)
            rehash(needed);
    }

    public boolean addAll(Collection<? extends C> c, Collection<? extends R> r) {
        // The resulting collection will be at least c.size() big
        if (f <= .5)
            ensureCapacity(Math.min(c.size(), r.size())); // The resulting collection will be sized
            // for c.size() elements
        else
            tryCapacity(size() + Math.min(c.size(), r.size())); // The resulting collection will be
        // tentatively sized for size() +
        // c.size() elements
        boolean retVal = false;
        final Iterator<? extends C> i = c.iterator();
        final Iterator<? extends R> j = r.iterator();
        int n = Math.min(c.size(), r.size());
        while (n-- != 0)
            if (add(i.next(), j.next()))
                retVal = true;
        return retVal;
    }

    public boolean add(final C c, final R r) {
        int pos;
        if (c == null && r == null) {
            if (containsNull)
                return false;
            pos = n;
            containsNull = true;
        } else {
            C curr;
            R rurr;
            final C[] key = this.cols;
            final R[] row = this.rows;
            // The starting point.
            if ((curr = key[pos = PintRNG.determine(columnHasher.hash(c), rowHasher.hash(r)) & mask]) != null &&
                    (rurr = row[pos]) != null) {
                if (columnHasher.areEqual(curr, c) && rowHasher.areEqual(rurr, r))
                    return false;
                while (((curr = key[pos = pos + 1 & mask]) != null) && (rurr = row[pos]) != null)
                    if (columnHasher.areEqual(curr, c) && rowHasher.areEqual(rurr, r))
                        return false;
            }
            key[pos] = c;
            row[pos] = r;
        }
        if (size == 0) {
            first = last = pos;
        } else {
            last = pos;
        }
        order.add(pos);
        if (size++ >= maxFill)
            rehash(arraySize(size + 1, f));
        return true;
    }

    public boolean addAt(final C c, final R r, int idx) {
        if (idx < 0)
            idx = 0;
        else if (idx > size)
            idx = size;

        int pos;
        if (c == null && r == null) {
            if (containsNull)
                return false;
            pos = n;
            containsNull = true;
        } else {
            C curr;
            R rurr;
            final C[] key = this.cols;
            final R[] row = this.rows;
            // The starting point.
            if ((curr = key[pos = PintRNG.determine(columnHasher.hash(c), rowHasher.hash(r)) & mask]) != null &&
                    (rurr = row[pos]) != null) {
                if (columnHasher.areEqual(curr, c) && rowHasher.areEqual(rurr, r))
                    return false;
                while (((curr = key[pos = pos + 1 & mask]) != null) && (rurr = row[pos]) != null)
                    if (columnHasher.areEqual(curr, c) && rowHasher.areEqual(rurr, r))
                        return false;
            }
            key[pos] = c;
            row[pos] = r;
        }
        if(idx == size) {
            order.add(pos);
            last = pos;
        } else {
            order.insert(idx, pos);
        }
        if (idx == 0) {
            first = pos;
        }
        if (size++ >= maxFill)
            rehash(arraySize(size + 1, f));
        return true;
    }

    /**
     * Shifts left entries with the specified hash code, starting at the
     * specified position, and empties the resulting free entry.
     *
     * @param pos a starting position.
     */
    protected final void shiftKeys(int pos) {
        // Shift entries with the same hash.
        int last, slot;
        C curr;
        R rurr;
        final C[] col = this.cols;
        final R[] row = this.rows;
        for (; ; ) {
            pos = (last = pos) + 1 & mask;
            for (; ; ) {
                if ((curr = col[pos]) == null || (rurr = row[pos]) == null) {
                    col[last] = null;
                    row[last] = null;
                    return;
                }
                slot = PintRNG.determine(columnHasher.hash(curr), rowHasher.hash(rurr)) & mask;
                if (last <= pos ? last >= slot || slot > pos : last >= slot
                        && slot > pos)
                    break;
                pos = pos + 1 & mask;
            }
            col[last] = curr;
            row[last] = rurr;
            fixOrder(pos, last);
        }
    }

    private boolean removeEntry(final int pos) {
        size--;
        fixOrder(pos);
        shiftKeys(pos);
        if (size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE)
            rehash(n / 2);
        return true;
    }

    private boolean removeNullEntry() {
        containsNull = false;
        cols[n] = null;
        rows[n] = null;
        size--;
        fixOrder(n);
        if (size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE)
            rehash(n / 2);
        return true;
    }

    @SuppressWarnings("unchecked")
    public boolean remove(final Object c, final Object r) {
        if (c == null && r == null)
            return containsNull && removeNullEntry();
        C curr;
        R rurr;
        final C[] col = this.cols;
        final R[] row = this.rows;
        int pos;
        // The starting point.
        if ((curr = col[pos = PintRNG.determine(columnHasher.hash(c), rowHasher.hash(r)) & mask]) == null
                || (rurr = row[pos]) == null)
            return false;
        if (columnHasher.areEqual(c, curr) && rowHasher.areEqual(r, rurr))
            return removeEntry(pos);
        while (true) {
            if ((curr = col[pos = pos + 1 & mask]) == null || (rurr = row[pos]) == null)
                return false;
            if (columnHasher.areEqual(c, curr) && rowHasher.areEqual(r, rurr))
                return removeEntry(pos);
        }
    }

    public C column(final Object c, final Object r) {
        final int pos = positionOf(c, r);
        if(pos == -1 || pos >= size)
            return null;
        return cols[pos];
    }

    public R row(final Object c, final Object r) {
        final int pos = positionOf(c, r);
        if(pos == -1 || pos >= size)
            return null;
        return rows[pos];
    }

    public boolean contains(final Object c, final Object r) {
        if (c == null && r == null)
            return containsNull;
        C curr;
        R rurr;
        final C[] col = this.cols;
        final R[] row = this.rows;
        int pos;
        // The starting point.
        if ((curr = col[pos = PintRNG.determine(columnHasher.hash(c), rowHasher.hash(r)) & mask]) == null
                || (rurr = row[pos]) == null)
            return false;
        if (columnHasher.areEqual(c, curr) && rowHasher.areEqual(r, rurr))
            return true;
        // There's always an unused entry.
        while (true) {
            if ((curr = col[pos = pos + 1 & mask]) == null || (rurr = row[pos]) == null)
                return false;
            if (columnHasher.areEqual(c, curr) && rowHasher.areEqual(r, rurr))
                return true;
        }
    }

    protected int positionOf(final Object c, final Object r) {

        if (c == null && r == null)
            return containsNull ? n : -1;
        C curr;
        R rurr;
        final C[] col = this.cols;
        final R[] row = this.rows;
        int pos;
        // The starting point.
        if ((curr = col[pos = PintRNG.determine(columnHasher.hash(c), rowHasher.hash(r)) & mask]) == null
                || (rurr = row[pos]) == null)
            return -1;
        if (columnHasher.areEqual(c, curr) && rowHasher.areEqual(r, rurr))
            return pos;
        // There's always an unused entry.
        while (true) {
            if ((curr = col[pos = pos + 1 & mask]) == null || (rurr = row[pos]) == null)
                return -1;
            if (columnHasher.areEqual(c, curr) && rowHasher.areEqual(r, rurr))
                return pos;
        }
    }

    /*
     * Removes all elements from this set.
     *
     * <P>To increase object reuse, this method does not change the table size.
     * If you want to reduce the table size, you must use {@link #trim()}.
     */
    public void clear() {
        if (size == 0)
            return;
        size = 0;
        containsNull = false;
        Arrays.fill(cols, null);
        first = last = -1;
        order.clear();
    }

    public int size() {
        return size;
    }

    /**
     * Checks whether this collection contains all elements from the given
     * collection.
     *
     * @param c a collection.
     * @return <code>true</code> if this collection contains all elements of the
     * argument.
     */
    public boolean containsAll(Collection<?> c, Collection<?> r) {
        int n = Math.min(c.size(), r.size());
        final Iterator<?> i = c.iterator();
        final Iterator<?> j = r.iterator();
        while (n-- != 0)
            if (!contains(i.next(), j.next()))
                return false;
        return true;
    }

    /*
     * Retains in this collection only elements from the given collection.
     *
     * @param c a collection.
     * @return <code>true</code> if this collection changed as a result of the
     * call.
     * /
    public boolean retainAll(Collection<?> c, Collection<?> r) {
        boolean retVal = false;
        int n = size();
        final Iterator<?> i = iterator();
        while (n-- != 0) {
            if (!c.contains(i.next())) {
                i.remove();
                retVal = true;
            }
        }
        return retVal;
    }
    */

    /**
     * Remove from this collection all elements in the given collection. If the
     * collection is an instance of this class, it uses faster iterators.
     *
     * @param c a collection.
     * @return <code>true</code> if this collection changed as a result of the
     * call.
     */
    public boolean removeAll(Collection<?> c, Collection<?> r) {
        boolean retVal = false;
        int n = Math.min(c.size(), r.size());
        final Iterator<?> i = c.iterator();
        final Iterator<?> j = r.iterator();
        while (n-- != 0)
            if (remove(i.next(), j.next()))
                retVal = true;
        return retVal;
    }

    public boolean isEmpty() {
        return size() == 0;
    }


    /**
     * Modifies the link vector so that the given entry is removed. This method will complete in logarithmic time.
     *
     * @param i the index of an entry.
     */
    protected int fixOrder(final int i) {
        if (size == 0) {
            order.clear();
            first = last = -1;
            return 0;
        }
        int idx = order.removeValue(i);
        if (first == i) {
            first = order.get(0);
        }
        if (last == i) {
            last = order.peek();
        }
        return idx;
    }

    /**
     * Modifies the ordering for a shift from s to d.
     * <br>
     * This method will complete in logarithmic time or better.
     *
     * @param s the source position.
     * @param d the destination position.
     */
    protected void fixOrder(int s, int d) {
        if (size == 1) {
            first = last = d;
            order.set(0, d);
        } else if (first == s) {
            first = d;
            order.set(0, d);
        } else if (last == s) {
            last = d;
            order.set(order.size - 1, d);
        } else {
            order.set(order.indexOf(s), d);
        }
    }

    /**
     * Returns the first element of this set in iteration order.
     *
     * @return the first element in iteration order.
     */
    public C first() {
        if (size == 0)
            throw new NoSuchElementException();
        return cols[first];
    }

    /**
     * Returns the last element of this set in iteration order.
     *
     * @return the last element in iteration order.
     */
    public C last() {
        if (size == 0)
            throw new NoSuchElementException();
        return cols[last];
    }

    public SortedSet<C> tailSet(C from) {
        throw new UnsupportedOperationException();
    }

    public SortedSet<C> headSet(C to) {
        throw new UnsupportedOperationException();
    }

    public SortedSet<C> subSet(C from, C to) {
        throw new UnsupportedOperationException();
    }

    public Comparator<? super C> comparator() {
        return null;
    }

    /**
     * A list iterator over a linked set.
     * <p>
     * <p>
     * This class provides a list iterator over a linked hash set. The
     * constructor runs in constant time.
     */
    private class SetIterator implements ListIterator<C> {
        /**
         * The entry that will be returned by the next call to
         * {@link ListIterator#previous()} (or <code>null</code> if no
         * previous entry exists).
         */
        int prev = -1;
        /**
         * The entry that will be returned by the next call to
         * {@link ListIterator#next()} (or <code>null</code> if no
         * next entry exists).
         */
        int next = -1;
        /**
         * The last entry that was returned (or -1 if we did not iterate or used
         * {@link #remove()}).
         */
        int curr = -1;
        /**
         * The current index (in the sense of a {@link ListIterator}).
         * When -1, we do not know the current index.
         */
        int index = -1;

        SetIterator() {
            next = first;
            index = 0;
        }

        public boolean hasNext() {
            return next != -1;
        }

        public boolean hasPrevious() {
            return prev != -1;
        }

        public C next() {
            if (!hasNext())
                throw new NoSuchElementException();
            curr = next;
            if (++index >= order.size)
                next = -1;
            else
                next = order.get(index);//(int) link[curr];
            prev = curr;
            return cols[curr];
        }

        public C previous() {
            if (!hasPrevious())
                throw new NoSuchElementException();
            curr = prev;
            if (--index < 1)
                prev = -1;
            else
                prev = order.get(index - 1);
            next = curr;
            return cols[curr];
        }

        private void ensureIndexKnown() {
            if (index >= 0)
                return;
            if (prev == -1) {
                index = 0;
                return;
            }
            if (next == -1) {
                index = size;
                return;
            }
            index = 0;
        }

        public int nextIndex() {
            ensureIndexKnown();
            return index + 1;
        }

        public int previousIndex() {
            ensureIndexKnown();
            return index - 1;
        }

        public void remove() {
            ensureIndexKnown();
            if (curr == -1)
                throw new IllegalStateException();
            if (curr == prev) {
                /*
                 * If the last operation was a next(), we are removing an entry
				 * that precedes the current index, and thus we must decrement
				 * it.
				 */
                if (--index >= 1)
                    prev = order.get(index - 1); //(int) (link[curr] >>> 32);
                else
                    prev = -1;
            } else {
                if (index < order.size - 1)
                    next = order.get(index + 1);
                else
                    next = -1;
            }
            /*
			 * Now we manually fix the pointers. Because of our knowledge of
			 * next and prev, this is going to be faster than calling
			 * fixOrder().
			 */
            if (prev == -1)
                first = next;
            if (next == -1)
                last = prev;
            order.removeIndex(index);
            size--;
            int last, slot, pos = curr;
            curr = -1;
            if (pos == n) {
                containsNull = false;
                cols[n] = null;
                //order.removeValue(pos);
            } else {
                C curr;
                final C[] key = TableSet.this.cols;
                // We have to horribly duplicate the shiftKeys() code because we
                // need to update next/prev.
                for (; ; ) {
                    pos = (last = pos) + 1 & mask;
                    for (; ; ) {
                        if ((curr = key[pos]) == null) {
                            key[last] = null;
                            return;
                        }
                        slot = HashCommon.mix(columnHasher.hash(curr)) & mask;
                        if (last <= pos
                                ? last >= slot || slot > pos
                                : last >= slot && slot > pos)
                            break;
                        pos = pos + 1 & mask;
                    }
                    key[last] = curr;
                    if (next == pos)
                        next = last;
                    if (prev == pos)
                        prev = last;
                    fixOrder(pos, last);
                }
            }

        }

        /**
         * Replaces the last element returned by {@link #next} or
         * {@link #previous} with the specified element (optional operation).
         * This call can be made only if neither {@link #remove} nor {@link
         * #add} have been called after the last call to {@code next} or
         * {@code previous}.
         *
         * @param c the element with which to replace the last element returned by
         *          {@code next} or {@code previous}
         * @throws UnsupportedOperationException if the {@code set} operation
         *                                       is not supported by this list iterator
         * @throws ClassCastException            if the class of the specified element
         *                                       prevents it from being added to this list
         * @throws IllegalArgumentException      if some aspect of the specified
         *                                       element prevents it from being added to this list
         * @throws IllegalStateException         if neither {@code next} nor
         *                                       {@code previous} have been called, or {@code remove} or
         *                                       {@code add} have been called after the last call to
         *                                       {@code next} or {@code previous}
         */
        @Override
        public void set(C c) {
            throw new UnsupportedOperationException("set() not supported on OrderedSet iterator");
        }

        /**
         * Inserts the specified element into the list (optional operation).
         * The element is inserted immediately before the element that
         * would be returned by {@link #next}, if any, and after the element
         * that would be returned by {@link #previous}, if any.  (If the
         * list contains no elements, the new element becomes the sole element
         * on the list.)  The new element is inserted before the implicit
         * cursor: a subsequent call to {@code next} would be unaffected, and a
         * subsequent call to {@code previous} would return the new element.
         * (This call increases by one the value that would be returned by a
         * call to {@code nextIndex} or {@code previousIndex}.)
         *
         * @param c the element to insert
         * @throws UnsupportedOperationException if the {@code add} method is
         *                                       not supported by this list iterator
         * @throws ClassCastException            if the class of the specified element
         *                                       prevents it from being added to this list
         * @throws IllegalArgumentException      if some aspect of this element
         *                                       prevents it from being added to this list
         */
        @Override
        public void add(C c) {
            throw new UnsupportedOperationException("add() not supported on OrderedSet iterator");
        }
    }

    public ListIterator<C> iterator() {
        return new SetIterator();
    }

    /**
     * Rehashes the map, making the table as small as possible.
     * <p>
     * <P>This method rehashes the table to the smallest size satisfying the load factor. It can be used when the set will not be changed anymore, so to optimize access speed and size.
     * <p>
     * <P>If the table size is already the minimum possible, this method does nothing.
     *
     * @return true if there was enough memory to trim the map.
     * @see #trim(int)
     */
    public boolean trim() {
        final int l = arraySize(size, f);
        if (l >= n || size > maxFill(l, f)) return true;
        try {
            rehash(l);
        } catch (Exception cantDoIt) {
            return false;
        }
        return true;
    }

    /**
     * Rehashes this map if the table is too large.
     * <p>
     * <P>Let <var>N</var> be the smallest table size that can hold <code>max(n,{@link #size()})</code> entries, still satisfying the load factor. If the current table size is smaller than or equal to
     * <var>N</var>, this method does nothing. Otherwise, it rehashes this map in a table of size <var>N</var>.
     * <p>
     * <P>This method is useful when reusing maps. {@linkplain #clear() Clearing a map} leaves the table size untouched. If you are reusing a map many times, you can call this method with a typical
     * size to avoid keeping around a very large table just because of a few large transient maps.
     *
     * @param n the threshold for the trimming.
     * @return true if there was enough memory to trim the map.
     * @see #trim()
     */
    public boolean trim(final int n) {
        final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / f));
        if (l >= n || size > maxFill(l, f)) return true;
        try {
            rehash(l);
        } catch (Exception cantDoIt) {
            return false;
        }
        return true;
    }

    /**
     * Rehashes the map.
     * <p>
     * <p>
     * This method implements the basic rehashing strategy, and may be overriden
     * by subclasses implementing different rehashing strategies (e.g.,
     * disk-based rehashing). However, you should not override this method
     * unless you understand the internal workings of this class.
     *
     * @param newN the new size
     */

    @SuppressWarnings("unchecked")
    protected void rehash(final int newN) {
        final C col[] = this.cols, newCol[] = (C[]) new Object[newN + 1];
        final R row[] = this.rows, newRow[] = (R[]) new Object[newN + 1];
        final int mask = newN - 1;
        int i, pos, sz = order.size, originalFirst = first, originalLast = last;
        for (int q = 0; q < sz; q++) {
            i = order.get(q);
            if (col[i] == null)
                pos = newN;
            else {
                pos = PintRNG.determine(columnHasher.hash(col[i]), rowHasher.hash(row[i])) & mask;
                while (!(newCol[pos] == null))
                    pos = pos + 1 & mask;
            }
            newCol[pos] = col[i];
            newRow[pos] = row[i];
            order.set(q, pos);
            if (i == originalFirst)
                first = pos;
            if (i == originalLast)
                last = pos;
        }
        n = newN;
        this.mask = mask;
        maxFill = maxFill(n, f);
        this.cols = newCol;
        this.rows = newRow;
    }
    /*
    @SuppressWarnings("unchecked")
    protected void rehash(final int newN) {
        final C key[] = this.key;
        final V value[] = this.value;
        final int mask = newN - 1; // Note that this is used by the hashing
        // macro
        final C newKey[] = (C[]) new Object[newN + 1];
        final V newValue[] = (V[]) new Object[newN + 1];
        int i = first, prev = -1, newPrev = -1, t, pos;
        final long link[] = this.link;
        final long newLink[] = new long[newN + 1];
        first = -1;
        for (int j = size; j-- != 0;) {
            if (((key[i]) == null))
                pos = newN;
            else {
                pos = (HashCommon.mix((key[i]).hashCode())) & mask;
                while (!((newKey[pos]) == null))
                    pos = (pos + 1) & mask;
            }
            newKey[pos] = key[i];
            newValue[pos] = value[i];
            if (prev != -1) {
                newLink[newPrev] ^= ((newLink[newPrev] ^ (pos & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
                newLink[pos] ^= ((newLink[pos] ^ ((newPrev & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L);
                newPrev = pos;
            } else {
                newPrev = first = pos;
                // Special case of SET(newLink[ pos ], -1, -1);
                newLink[pos] = -1L;
            }
            t = i;
            i = (int) link[i];
            prev = t;
        }
        this.link = newLink;
        this.last = newPrev;
        if (newPrev != -1)
            // Special case of SET_NEXT( newLink[ newPrev ], -1 );
            newLink[newPrev] |= -1 & 0xFFFFFFFFL;
        n = newN;
        this.mask = mask;
        maxFill = maxFill(n, f);
        this.key = newKey;
        this.value = newValue;
    }
    */

    public int hashCode() {
        return CrossHash.Wisp.hash(cols) * 967 + CrossHash.Wisp.hash(rows) * 31 + order.hashWisp();
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static int maxFill(final int n, final float f) {
        /* We must guarantee that there is always at least
		 * one free entry (even with pathological load factors). */
        return Math.min((int) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static long maxFill(final long n, final float f) {
		/* We must guarantee that there is always at least
		 * one free entry (even with pathological load factors). */
        return Math.min((long) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the least power of two smaller than or equal to 2<sup>30</sup> and larger than or equal to <code>Math.ceil( expected / f )</code>.
     *
     * @param expected the expected number of elements in a hash table.
     * @param f        the load factor.
     * @return the minimum possible size for a backing array.
     * @throws IllegalArgumentException if the necessary size is larger than 2<sup>30</sup>.
     */
    public static int arraySize(final int expected, final float f) {
        final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));
        if (s > 1 << 30)
            throw new IllegalArgumentException("Too large (" + expected + " expected elements with load factor " + f + ")");
        return (int) s;
    }

    @Override
    public String toString() {
        final StringBuilder s = new StringBuilder();
        int n = size(), i = 0;
        boolean first = true;
        s.append("TableSet{");
        while (i < n) {
            if (first) first = false;
            else s.append(", ");
            s.append(columnAt(i)).append(" with ").append(rowAt(i++));
        }
        s.append("}");
        return s.toString();
    }

    @Override
    public boolean equals(final Object o) {
        if (o == this)
            return true;
        if (!(o instanceof TableSet))
            return false;
        TableSet<?, ?> s = (TableSet<?, ?>) o;
        if (s.size() != size || columnHasher != s.columnHasher || rowHasher != s.rowHasher)
            return false;
        int p;
        for (int i = 0; i < size; i++) {
            if(!columnHasher.areEqual(cols[p = order.get(i)], s.cols[p]) || !rowHasher.areEqual(rows[p], s.rows[p]))
                return false;
        }
        return true;
    }

    @GwtIncompatible
    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        final ListIterator<C> i = iterator();
        s.defaultWriteObject();
        s.writeObject(columnHasher);
        for (int j = size; j-- != 0; )
            s.writeObject(i.next());
    }

    @GwtIncompatible
    @SuppressWarnings("unchecked")
    private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();
        columnHasher = (CrossHash.IHasher) s.readObject();
        n = arraySize(size, f);
        maxFill = maxFill(n, f);
        mask = n - 1;
        final C key[] = this.cols = (C[]) new Object[n + 1];
        final IntVLA order = this.order = new IntVLA(n + 1);
        int prev = -1;
        first = last = -1;
        C c;
        for (int i = size, pos; i-- != 0; ) {
            c = (C) s.readObject();
            if (c == null) {
                pos = n;
                containsNull = true;
            } else {
                if (!(key[pos = HashCommon.mix(columnHasher.hash(c)) & mask] == null))
                    while (!(key[pos = pos + 1 & mask] == null)) ;
            }
            key[pos] = c;
            if (first != -1) {
                last = pos;
            } else {
                first = last = pos;
            }
            order.add(pos);
        }
    }

    /**
     * Gets the item at the given index in the iteration order in constant time (random-access).
     *
     * @param idx the index in the iteration order of the key to fetch
     * @return the key at the index, if the index is valid, otherwise null
     */
    public C columnAt(final int idx) {
        if (idx < 0 || idx >= order.size)
            return null;
        // The starting point.
        return this.cols[order.get(idx)];
    }

    /**
     * Gets the item at the given index in the iteration order in constant time (random-access).
     *
     * @param idx the index in the iteration order of the key to fetch
     * @return the key at the index, if the index is valid, otherwise null
     */
    public R rowAt(final int idx) {
        if (idx < 0 || idx >= order.size)
            return null;
        // The starting point.
        return this.rows[order.get(idx)];
    }

    /**
     * Removes the item at the given index in the iteration order in not-exactly constant time (though it still should
     * be efficient).
     *
     * @param idx the index in the iteration order of the item to remove
     * @return true if this Set was changed as a result of this call, or false if nothing changed.
     */
    public boolean removeAt(final int idx) {
        if (idx < 0 || idx >= order.size)
            throw new NoSuchElementException();
        int pos = order.get(idx);
        if(pos > n)
            return false;
        if (cols[pos] == null && rows[pos] == null) {
            if (containsNull)
                return removeNullEntry();
            return false;
        }
        return removeEntry(pos);
    }

    /**
     * Gets a random value from this OrderedSet in constant time, using the given RNG to generate a random number.
     *
     * @param rng used to generate a random index for a value
     * @return a random value from this OrderedSet
     */
    public C randomColumn(RNG rng) {
        return columnAt(rng.nextIntHasty(order.size));
    }

    /**
     * Gets a random value from this OrderedSet in constant time, using the given RNG to generate a random number.
     *
     * @param rng used to generate a random index for a value
     * @return a random value from this OrderedSet
     */
    public R randomRow(RNG rng) {
        return rowAt(rng.nextIntHasty(order.size));
    }

    /**
     * Randomly alters the iteration order for this OrderedSet using the given RNG to shuffle.
     *
     * @param rng used to generate a random ordering
     * @return this for chaining
     */
    public TableSet<C, R> shuffle(RNG rng) {
        if (size < 2 || rng == null)
            return this;
        order.shuffle(rng);
        first = order.get(0);
        last = order.peek();
        return this;
    }

    /**
     * Given an array or varargs of replacement indices for this OrderedSet's iteration order, reorders this so the
     * first item in the returned version is the same as {@code getAt(ordering[0])} (with some care taken for negative
     * or too-large indices), the second item in the returned version is the same as {@code getAt(ordering[1])}, etc.
     * <br>
     * Negative indices are considered reversed distances from the end of ordering, so -1 refers to the same index as
     * {@code ordering[ordering.length - 1]}. If ordering is smaller than {@code size()}, only the indices up to the
     * length of ordering will be modified. If ordering is larger than {@code size()}, only as many indices will be
     * affected as {@code size()}, and reversed distances are measured from the end of this Set's entries instead of
     * the end of ordering. Duplicate values in ordering will produce duplicate values in the returned Set.
     * <br>
     * This method modifies this OrderedSet in-place and also returns it for chaining.
     *
     * @param ordering an array or varargs of int indices, where the nth item in ordering changes the nth item in this
     *                 Set to have the value currently in this Set at the index specified by the value in ordering
     * @return this for chaining, after modifying it in-place
     */
    public TableSet<C, R> reorder(int... ordering) {
        order.reorder(ordering);
        first = order.get(0);
        last = order.peek();
        return this;
    }

    private boolean alterEntry(final int pos, final C creplacement, final R rreplacement) {
        int rep;
        if (creplacement == null && rreplacement == null) {
            if (containsNull)
                return false;
            rep = n;
            containsNull = true;
        } else {
            C curr;
            R rurr;
            final C[] col = this.cols;
            final R[] row = this.rows;
            col[pos] = null;
            row[pos] = null;
            // The starting point.
            if (((curr = col[rep = PintRNG.determine(columnHasher.hash(creplacement), rowHasher.hash(rreplacement))
                    & mask]) != null) && (rurr = row[rep]) != null) {
                if (columnHasher.areEqual(curr, creplacement) && rowHasher.areEqual(rurr, rreplacement))
                    return false;
                while ((curr = col[rep = rep + 1 & mask]) != null && (rurr = row[rep]) != null)
                    if (columnHasher.areEqual(curr, creplacement) && rowHasher.areEqual(rurr, rreplacement))
                        return false;
            }
            col[rep] = creplacement;
            row[rep] = rreplacement;
        }
        fixOrder(pos, rep);
        return true;
    }

    private boolean alterNullEntry(final C creplacement, final R rreplacement) {
        containsNull = false;
        cols[n] = null;
        rows[n] = null;
        int rep;
        if (creplacement == null && rreplacement == null) {
            rep = n;
            containsNull = true;
        } else {
            C curr;
            R rurr;
            final C[] col = this.cols;
            final R[] row = this.rows;
            // The starting point.
            if (((curr = col[rep = PintRNG.determine(columnHasher.hash(creplacement), rowHasher.hash(rreplacement))
                    & mask]) != null) && (rurr = row[rep]) != null) {
                if (columnHasher.areEqual(curr, creplacement) && rowHasher.areEqual(rurr, rreplacement))
                    return false;
                while ((curr = col[rep = rep + 1 & mask]) != null && (rurr = row[rep]) != null)
                    if (columnHasher.areEqual(curr, creplacement) && rowHasher.areEqual(rurr, rreplacement))
                        return false;
            }
            col[rep] = creplacement;
            row[rep] = rreplacement;
        }
        fixOrder(n, rep);
        return true;
    }

    /*
    public boolean alter(C original, C replacement)
    {
        if (original == null) {
            if (containsNull) {
                return replacement != null && alterNullEntry(replacement);
            }
            else
                return add(replacement);
        }
        else if(hasher.areEqual(original, replacement))
            return false;
        C curr;
        final C[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(hasher.hash(original)) & mask]) == null)
            return add(replacement);
        if (hasher.areEqual(original, curr))
            return alterEntry(pos, replacement);
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == null)
                return add(replacement);
            if (hasher.areEqual(original, curr))
                return alterEntry(pos, replacement);
        }
    }*/
    private int alterEntry(final int pos) {
        size--;
        int idx = fixOrder(pos);
        shiftKeys(pos);
        if (size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE)
            rehash(n / 2);
        return idx;
    }

    private int alterNullEntry() {
        containsNull = false;
        cols[n] = null;
        size--;
        int idx = fixOrder(n);
        if (size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE)
            rehash(n / 2);
        return idx;
    }

    /**
     * Changes a pair of C and R, originalC and originalR, to another pair, replacementC and replacementR.
     * Keeps the replacement at the same point in the ordering.
     *
     * @param originalC    the column part of a pair that will be removed from this TableSet if present, and its iteration index remembered
     * @param originalR    the row part of a pair that will be removed from this TableSet if present, and its iteration index remembered
     * @param replacementC another column value that will replace originalC at the remembered index
     * @param replacementR another row value that will replace originalR at the remembered index
     * @return true if the Set changed, or false if it didn't (such as if the two arguments are equal, or replacement was already in the Set but original was not)
     */
    public boolean alter(C originalC, R originalR, C replacementC, R replacementR) {
        int idx;
        if (originalC == null && originalR == null) {
            if (containsNull) {
                if (replacementC != null && replacementR != null) {
                    idx = alterNullEntry();
                    addAt(replacementC, replacementR, idx);
                    return true;
                } else
                    return false;
            }
            ;
            return false;
        }
        if (columnHasher.areEqual(originalC, replacementR) && rowHasher.areEqual(originalR, replacementR))
            return false;
        C curr;
        R rurr;
        final C[] col = this.cols;
        final R[] row = this.rows;
        int pos;
        // The starting point.
        if ((curr = col[pos = PintRNG.determine(columnHasher.hash(originalC), rowHasher.hash(originalR)) & mask]) == null
                || (rurr = row[pos]) == null)
            return false;
        if (columnHasher.areEqual(originalC, curr) && rowHasher.areEqual(originalR, rurr)) {
            idx = alterEntry(pos);
            addAt(replacementC, replacementR, idx);
            return true;
        }
        while (true) {
            if ((curr = col[pos = pos + 1 & mask]) == null || (rurr = row[pos]) == null)
                return false;
            if (columnHasher.areEqual(originalC, curr) && rowHasher.areEqual(originalR, rurr)) {
                idx = alterEntry(pos);
                addAt(replacementC, replacementR, idx);
                return true;
            }
        }
    }

}
